# üî® Code Review ‚Äî Sentinel Trading Terminal (Linus-style)

## Verdict

Works by accident, fails by design. You‚Äôre throwing data away based on whatever the user happens to be looking at, dimming the hell out of what‚Äôs left, and then wondering why zoom-out shows black holes and colors look washed. The core idea is fine; the execution fractures the history model, the visual model, and a bit of the performance model.

---

# üö© Major Architecture Bugs

## 1) Viewport-dependent storage (fatal)

You literally decide what history exists based on the current camera. In `LiquidityTimeSeriesEngine::addOrderBookSnapshot(...)`:

* Lines 66‚Äì70:

  ```cpp
  // Only store price levels within viewport + buffer
  double priceBuffer = (maxPrice - minPrice) * 0.5;
  double filteredMinPrice = minPrice - priceBuffer;
  double filteredMaxPrice = maxPrice + priceBuffer;
  ```
* Lines 76‚Äì90: you drop anything outside that range before it ever hits the snapshot maps.

Then every 100 ms, `DataProcessor::captureOrderBookSnapshot()` feeds **viewport bounds** into the engine (L91‚Äì96). So the ‚Äúdatabase‚Äù is a keyhole. Zoom out later and‚Äîsurprise‚Äînothing‚Äôs there.

**Fix**: Storage must be **UI-agnostic**. Maintain a rolling *global* band independent of the viewport (e.g., ¬±k¬∑ATR or ¬±œÉ around mid, or a configured absolute range), and persist within that. The viewport should only affect **rendering**, not **what we saved**.

---

## 2) Arbitrary depth limiting

You cap bids/asks by `m_depthLimit` and then `resize()` the vectors (L52‚Äì61) without proving the book vectors are sorted by best price or distance to mid. If the feed order changes, you keep the first 2,000 *whatever*, not the top of book or nearest levels. That‚Äôs sloppy.

**Fix**: Depth limit should be **price-aware**: compute mid, sort by |price‚àímid| (or by level index if the feed is already top-down) and then trim. Or trim by the *global band* above.

---

## 3) Double intensity shrink (why so gray?)

* `IRenderStrategy::calculateIntensity`: `log1p(liq) * intensityScale * 0.1`
* `HeatmapStrategy::calculateColor`: `alpha = min(intensity * 0.8, 1.0)`

You‚Äôre nuking the signal twice before it even hits blending. The result is \~8% of a log-scaled value. That‚Äôs why everything looks like a ghost.

**Fix**:

* Drop the magic scalars; tune with a single curve:

  ```
  intensity = clamp(pow(log1p(liq) * k, gamma), 0, 1)
  alpha     = clamp(intensity * alphaScale, 0, 1)
  ```
* Start with `k‚âà1`, `gamma‚âà0.7‚Äì1.0`, `alphaScale‚âà1.0`. Ship sane defaults, expose dials.

---

## 4) Bid/ask color bleed

You draw two semi-transparent quads for **the same cell** (same quantized price & same time slice) ‚Äî one green, one red ‚Äî using `QSGVertexColorMaterial` with blending enabled. Of course you get yellow mud when both have non-zero alpha.

**Fix** (pick one):

* **Dominance**: for a given (price,time) cell, compute bid/ask and draw **one** rect using a signed color map (green‚Üîred by imbalance).
* **Layer split**: separate nodes for bids and asks with Z-ordering; optionally make the dominant side opaque where both exist.

---

## 5) Anti-spoofing hammer (0.8 persistence)

You hard-code `> 0.8` slice persistence to qualify as ‚Äúresting‚Äù (L346 & L354). That might be okay for long slices, but on short slices it will throw out legitimate liquidity that churns fast.

**Fix**: Make it timeframe-aware and symbol-adaptive:

* Require **min dwell ms + ratio**, not just ratio.
* Provide profiles: ‚ÄúStrict / Normal / Loose‚Äù with documented semantics.

---

## 6) History retention couples to the largest timeframe

`cleanupOldData()` computes snapshot limit as `m_maxHistorySlices * (max_timeframe / base)` and pops from the front. Combined with the viewport filter, this guarantees gaps. Even without the viewport bug, it‚Äôs a blunt tool.

**Fix**: Bound memory per **timeframe** (per-deque caps) and spill snapshots to disk (mmap/LMDB) for long sessions. Keep a hot RAM window + on-demand rebuild from persisted deltas.

---

# üìå File-by-File Notes

## LiquidityTimeSeriesEngine.{h,cpp}

* **Quantization**: `$1` buckets (`m_priceResolution = 1.0`). That‚Äôs a joke for low-priced coins and too fine for five-figure instruments unless you‚Äôre zoomed in. Tie this to **tick size** or **% of price**; switch LOD with zoom.
* **`getTimeSlice` pointer lifetime**: returning pointers into `std::deque` is OK (deques are stable on push/pop), but document it and never return refs to `m_currentSlices` you‚Äôre about to move.
* **`rebuildTimeframe`** rebuilds by replaying snapshots ‚Äî good ‚Äî but if snapshots were viewport-filtered, rebuild can‚Äôt resurrect missing price levels. Another reason storage must be viewport-agnostic.

## DataProcessor.cpp

* 100 ms QTimer on the GUI thread: fine for now, but the engine work (quantization, map updates) should live off the render thread. If you see jank, move the engine behind a worker + signal the renderer with immutable batches.

## UnifiedGridRenderer.cpp

* `createLiquidityCell(...)` builds identical rects for both sides. That‚Äôs the bleed. Add a dominance pass or split batches by side.
* Culling is fine. Consider batching by price tile to minimize node churn.

## HeatmapStrategy.cpp / IRenderStrategy.cpp

* See intensity/alpha above. Also consider **premultiplied alpha** if you start doing manual color math; make sure the material matches.

---

# üß™ Repro & Diagnostics You Should Add

* Deterministic replay of an L2 capture. Assert that:

  * Zooming out after several minutes **never** introduces black gaps.
  * Dominance/imbalance coloring removes yellow mud on overlapping cells.
  * Intensity curve yields a visible gradient across 3‚Äì4 orders of magnitude.

* Debug overlay on hover: show `(side, price, sliceTime, avg/max/resting, persistence)`.

---

# ‚úÖ Minimal Patchset (ship this now)

### 1) Stop filtering by viewport immediately

**DataProcessor.cpp**

```diff
- if (m_viewState && m_viewState->isTimeWindowValid()) {
-     m_liquidityEngine->addOrderBookSnapshot(
-         m_latestOrderBook,
-         m_viewState->getMinPrice(), m_viewState->getMaxPrice());
- } else {
-     m_liquidityEngine->addOrderBookSnapshot(m_latestOrderBook);
- }
+ // Temporarily decouple storage from the viewport: always store full snapshot.
+ m_liquidityEngine->addOrderBookSnapshot(m_latestOrderBook);
```

**LiquidityTimeSeriesEngine.cpp**

```diff
- // Only store price levels within viewport + buffer
- double priceBuffer = (maxPrice - minPrice) * 0.5;
- double filteredMinPrice = minPrice - priceBuffer;
- double filteredMaxPrice = maxPrice + priceBuffer;
- ...
- if (bid.price >= filteredMinPrice && bid.price <= filteredMaxPrice) {
-     double q = quantizePrice(bid.price);
-     snapshot.bids[q] += bid.size;
- }
+ // TEMP: no viewport filtering; keep everything (will be constrained by depth or global band later)
+ double q = quantizePrice(bid.price);
+ snapshot.bids[q] += bid.size;
```

(Same for asks.)

### 2) Fix intensity/alpha so the heatmap is readable

**IRenderStrategy.cpp**

```diff
- double intensity = logLiquidity * intensityScale * 0.1;
+ double intensity = logLiquidity * intensityScale; // drop arbitrary 0.1
  return std::min(1.0, intensity);
```

**HeatmapStrategy.cpp**

```diff
- double alpha = std::min(intensity * 0.8, 1.0);
+ double alpha = std::min(intensity, 1.0); // let intensity speak
```

### 3) Kill bid/ask blending mud

Option A (fastest): single signed color per cell in `UnifiedGridRenderer::createCellsFromLiquiditySlice`:

* For each (price, slice), compute `net = bid - ask`. Emit **one** cell with color ‚Üî sign and alpha from |net|.

Option B (still simple): split batches:

* Build `GridSliceBatch` **per side**; draw asks first, bids second; make the dominant side clamp `alpha=1.0` to occlude.

### 4) Make resting threshold sane

```diff
- if (metrics.persistenceRatio(slice.duration_ms) > 0.8)
+ if (metrics.persistenceRatio(slice.duration_ms) > m_restingRatio   // default 0.6‚Äì0.7
+     && (metrics.lastSeen_ms - metrics.firstSeen_ms) >= m_minDwellMs) // e.g. >= 200ms
```

Expose `m_restingRatio` and `m_minDwellMs` as settings.

### 5) Depth limit that actually means ‚Äúdepth‚Äù

Before `resize(m_depthLimit)`, ensure bids/asks are sorted by price (or by distance to mid). If you can‚Äôt guarantee feed order, sort locally when applying the limit.

---

# üß≠ Longer-Term Design (don‚Äôt skip this)

* **Decouple storage from UI** permanently. Keep a *global band* with ring buffers per timeframe. Optionally spill old snapshots to disk.
* **LOD by price**: pre-aggregate tiles (e.g., \$10 / \$5 / \$1 / \$0.25 buckets) and pick the tile set per zoom.
* **Signed color map** for imbalance. Your users want to *read* pressure at a glance, not solve a color-mixing puzzle.
* **Replay harness** for regressions. If you can‚Äôt deterministically show before/after for these bugs, you‚Äôll re-introduce them.

---

## Bottom line

You can‚Äôt build history from the viewport. Fix that, stop mangling intensity, sort your depth limiting, and choose a sane policy for overlapping sides. Do the minimal patches today, then refactor storage/LOD so zoomed-out views are faithful and fast.
