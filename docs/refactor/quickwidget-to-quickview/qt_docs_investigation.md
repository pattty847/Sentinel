# Refactoring Sentinel's GPU Rendering Pipeline - Deep Dive and Plan

## Introduction

Sentinel's current GUI uses a hybrid Qt Widgets + Qt Quick approach, embedding a **QQuickWidget** inside a QWidget-based window. While functional, this architecture imposes significant overhead (an extra FBO render pass, forced single-threaded rendering) that bottlenecks frame rates to ~60-90 FPS. We aim to achieve **120 FPS at 4K on an RTX 4070** (and 60 FPS on integrated GPUs) by eliminating these overheads without discarding months of existing scenegraph and threading logic. This report investigates the Qt Quick rendering pipeline, diagnoses the **QQuickWidget** bottlenecks, and outlines a refactored architecture - using a **QQuickWindow** for direct GPU rendering - to unlock full performance. We also cover scenegraph best practices (for 50k+ geometry nodes), update throttling for 120 Hz data, cross-platform rendering via **QRhi**, real-world case studies, and when a custom engine (ImGui/Vulkan) might be warranted.

_(Throughout, we provide citations to Qt docs and blogs for authoritative reference, and use diagrams and step-by-step plans to illustrate the path forward.)_

## Diagnosing the QQuickWidget Bottleneck (Architecture & Overhead)

**QQuickWidget** is a convenience class that lets us embed a Qt Quick scene (QML) into a QWidget UI. Internally, however, it incurs extra cost: it **renders the QML scene to an offscreen framebuffer object (FBO)**, then composites that into the widget's paint system[\[1\]](https://doc.qt.io/qt-6/qquickwidget.html#:~:text=,animations%2C%20will%20not%20be%20available). This means every frame does an extra GPU pass (render scene to texture, then draw textured quad into the widget), adding ~2-4 ms per frame in Sentinel's measurements. More critically, using QQuickWidget **disables Qt Quick's threaded render loop** on all platforms[\[2\]](https://doc.qt.io/qt-6/qquickwidget.html#:~:text=especially%20for%20the%20fragment%20processing,animations%2C%20will%20not%20be%20available), forcing rendering onto the GUI (main) thread. We lose the concurrency benefits of a dedicated render thread and vsync-driven timing. The table below summarizes these architectural differences:

| Aspect | **QQuickWidget** (Current) | **QQuickWindow/QQuickView** (Proposed) |
| --- | --- | --- |
| Rendering Path | Qt Quick scene → **FBO** → QWidget paint[\[1\]](https://doc.qt.io/qt-6/qquickwidget.html#:~:text=,animations%2C%20will%20not%20be%20available) | Qt Quick scene → **direct GPU window** (no extra pass) |
| Render Loop | **Basic (single-thread)**[\[2\]](https://doc.qt.io/qt-6/qquickwidget.html#:~:text=especially%20for%20the%20fragment%20processing,animations%2C%20will%20not%20be%20available) - rendering on GUI thread | **Threaded Scenegraph** - separate render thread, parallel to GUI[\[3\]](https://forum.qt.io/topic/55762/performance-of-qquickwidget#:~:text=,performance%20when%20compared%20to%20QQuickWidget) |
| Overhead per Frame | High: FBO bind, GPU fill, readback/blit, QWidget composition[\[4\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=,widget%20backing%20store%20%E2%86%92%20screen)[\[5\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=For%20120%20Hz%20updates%2C%20this,compositor%29) | Low: direct back-buffer render, no extra blit |
| Input Event Handling | Needs translation from QWidget events to QML[\[6\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=,widget%20vs%20QML) (some overhead) | Native QML event handling (no translation needed) |
| Widget Stacking | Can mix with QWidget controls (QQuickWidget is a QWidget) | QQuickWindow is a separate window (embedded via container), some stacking/z-order limitations[\[7\]](https://doc.qt.io/qt-6/qtquick-quickwidgets-qquickwidgetversuswindow-opengl-example.html#:~:text=The%20example%20allows%20showing%20the,from%20a%20true%20%2011)[\[8\]](https://doc.qt.io/qt-6/qtquick-quickwidgets-qquickwidgetversuswindow-opengl-example.html#:~:text=Clicking%20on%20the%20Show%20Overlay,makes%20it%20render%20as%20expected) |
| Graphics API | Historically OpenGL-only; Qt6 uses **QRhi** (supports Metal/Vulkan/D3D) but with caveats[\[9\]](https://doc.qt.io/qt-6/qtquick-quickwidgets-qquickwidgetversuswindow-opengl-example.html#:~:text=The%20Qt%20Quick%20scene%20also,Vulkan%2C%20Metal%2C%20Direct%203D)[\[10\]](https://doc.qt.io/qt-6/qquickwidget.html#:~:text=QQuickWidget%20is%20functional%20with%20all,QQuickWidget%20will%20lead%20to%20problems) | Full **QRhi** support (Metal, Vulkan, D3D11/12, GL) via Qt Quick's backend selection[\[10\]](https://doc.qt.io/qt-6/qquickwidget.html#:~:text=QQuickWidget%20is%20functional%20with%20all,QQuickWidget%20will%20lead%20to%20problems) |

**Frame Timeline with QQuickWidget:** To understand the performance hit, consider Sentinel's frame loop when new market data arrives (target 120 Hz = 8.3 ms frame budget):

- **Data Thread → GUI**: DataProcessor (worker thread) emits a signal carrying new data.
- **Schedule Update**: On the GUI thread, UnifiedGridRenderer::update() is called (via Qt's queued signal). This schedules a scene update.
- **QQuickItem::updatePaintNode**: Qt invokes UnifiedGridRenderer::updatePaintNode() on the GUI thread, where our custom QSG node tree is (re)built for the new data.
- **Scenegraph Render**: The Qt Quick scenegraph (on **render thread** in theory) draws the QSG node tree into an **offscreen FBO** (OpenGL/Metal/… texture).
- **FBO → Image**: The FBO content is **copied or bound** into a form usable by QWidget. In Qt's default implementation, this often means reading/backing the FBO into a native image/texture accessible to the Qt widget compositor[\[5\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=For%20120%20Hz%20updates%2C%20this,compositor%29). This step can introduce a GPU-CPU sync if not optimized (though Qt likely avoids full readback, it still incurs GPU blit cost).
- **Widget Composition**: The QQuickWidget's paint event draws the FBO texture onto the QWidget surface (e.g. as a quad). This happens on the GUI thread via the raster paint engine or platform compositor.
- **Screen Presentation**: The composed QWidget window is finally sent to the screen (window system composites it on screen, possibly with vsync).

Steps **5-7 are overhead unique to QQuickWidget** - a QQuickView/QQuickWindow would skip those by rendering the scenegraph directly to the window's backbuffer[\[5\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=For%20120%20Hz%20updates%2C%20this,compositor%29). In practice, Sentinel measured ~2-4 ms spent in these extra steps (per frame). That overhead alone can consume almost half of a 8.3 ms frame, explaining why 120 Hz was unattainable. Moreover, because **QQuickWidget forces the "basic" (single-threaded) render loop**, the scenegraph's rendering in step 4 is actually happening on the GUI thread (blocking UI), not truly on a separate thread[\[11\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=,Quick%27s%20threaded%20scenegraph%20renderer%20optimally). This prevents overlapping CPU processing with GPU rendering. Qt's docs explicitly note this trade-off: QQuickWidget's flexibility (mixing with widgets) _"comes at the expense of performance"_, requiring an extra render pass and losing threaded rendering[\[1\]](https://doc.qt.io/qt-6/qquickwidget.html#:~:text=,animations%2C%20will%20not%20be%20available).

Finally, embedding QQuickWidget means **event loop integration** overhead: input events (mouse, keyboard, wheel) received by the QWidget must be forwarded into the QML scene. QQuickWidget handles this internally, but it adds some overhead and potential for subtle focus or event order issues[\[6\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=,widget%20vs%20QML). For example, certain widget shortcuts or focus changes might conflict with QML key event handling. In Sentinel's case no major event issues were noted, but it's a complexity to keep in mind.

**Conclusion:** The profiling and architecture review confirm that **QQuickWidget is the bottleneck**. It introduces a separate GL context and FBO, an extra copy, and falls back to single-threaded rendering[\[4\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=,widget%20backing%20store%20%E2%86%92%20screen)[\[5\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=For%20120%20Hz%20updates%2C%20this,compositor%29). None of these issues are due to our scenegraph code - they are inherent to QQuickWidget's design. As Qt's Gerrit and forums suggest, if you don't _absolutely_ need QWidget stacking, a native QQuickWindow will _"always lead to better performance"_ than QQuickWidget[\[3\]](https://forum.qt.io/topic/55762/performance-of-qquickwidget#:~:text=,performance%20when%20compared%20to%20QQuickWidget). We will leverage that by refactoring the UI to use a QQuickWindow (or QQuickView) for the high-frequency chart, thereby **eliminating the FBO composition cost and restoring threaded rendering**.

_(To verify these findings, one can enable QSG_INFO=1 environment variable. This causes Qt to log scenegraph timing info to console. In a QQuickWidget, you'll see logs indicating the basic render loop and FBO usage. We can also instrument updatePaintNode() with QElapsedTimer to measure our scene build time vs. total frame time_[_\[12\]_](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=4.%20Add%20timing%20to%20,return%20node%3B)_. If the total frame time greatly exceeds updatePaintNode time by ~2-4ms, it corroborates that the wrapper overhead is at fault_[_\[13\]_](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=,%E2%86%92%20QQuickWidget%20is%20the%20problem)_.)_

## How Qt Quick's Threaded Scenegraph and QQuickWindow Pipeline Work

In a pure Qt Quick scenario (using **QQuickWindow** or **QQuickView**), the rendering pipeline is more direct and optimized:

- **QQuickWindow** is a specialized QWindow that hosts a QML scene. When using it (or a QQuickView, which is a QQuickWindow subclass for convenience), Qt Quick can use its default **threaded scenegraph render loop**. This means all QML rendering happens on a dedicated render thread, allowing the GUI thread to continue processing events or building new frames in parallel[\[14\]](https://medium.com/@thawfeekyahya/understanding-qt-graphics-part-3-scene-graph-b316e3ab01f2#:~:text=A%20fundamental%20distinction%20lies%20in,for%20grasping%20the%20rendering%20process)[\[15\]](https://medium.com/@thawfeekyahya/understanding-qt-graphics-part-3-scene-graph-b316e3ab01f2#:~:text=Since%20rendering%20happens%20in%20a,very%20efficient%20when%20used%20correctly). The GUI thread is responsible for running QML/JavaScript and triggering updatePaintNode(), but once the QSG nodes are prepared, the render thread takes over to issue GPU commands.
- **Scenegraph Overview:** The Qt Quick scene is represented as a tree of **QSGNode** objects (opaque geometry, transforms, etc.) completely separate from QML objects[\[16\]](https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html#:~:text=The%20Qt%20Quick%20items%20in,state%20and%20generate%20draw%20calls). Each QQuickItem that has visual content will produce a QSGNode subtree (via its updatePaintNode() implementation or via the QML defaults for simple items). QQuickWindow orchestrates rendering: on each frame, it traverses the QSGNode tree, batches drawing commands, and sends them to the GPU via OpenGL/Metal/Vulkan. With the threaded loop, this traversal and GPU command submission happen on the render thread, often concurrently with the next frame's Qt Quick computations on the main thread.
- **No Extra FBO Pass:** Unlike QQuickWidget, a QQuickWindow renders _directly to the window surface/backbuffer_. On a typical platform, this means the render thread will make the context current on the window's surface and issue draws once per frame. There's **no intermediate FBO** that then needs copying. This not only saves GPU time, but avoids any CPU readback or Qt's backingstore composition. The result is typically a 2-4 ms reduction in frame time (exact number depends on resolution and content - 4K frames amplify the cost of the extra blit).
- **Threaded Render Loop Benefits:** With threaded rendering, animations and vsync timing are handled more cleanly. Qt's scenegraph will tick at the monitor refresh rate (assuming an animation or update is pending) and can potentially **overlap** the CPU work of preparing the next frame. For example, at 120 Hz the render thread might be drawing frame N while the GUI thread is processing data for frame N+1. This pipeline parallelism is crucial for high frame rates. (In our case, data arrives at up to 120 Hz; the threaded loop ensures the render thread can keep up if GPU is fast, and if the GPU falls behind, the GUI thread may be lightly stalled by frame throttling but not doing the rendering work itself.) Animator classes (like QML Animations) also run independently on the vsync-driven timeline when using threaded mode[\[17\]](https://doc.qt.io/qt-6/qquickwidget.html#:~:text=especially%20for%20the%20fragment%20processing,animations%2C%20will%20not%20be%20available).
- **Frame Timing:** In QQuickWindow's render loop, calling QQuickItem::update() will schedule a new render pass on the next vsync. Internally, Qt Quick consolidates multiple update() calls (it won't schedule more than one frame per tick). This means if the data source pushes many updates, Qt Quick can coalesce them to the next frame. The **render loop runs at the screen's refresh rate** by default (e.g. 144 Hz display would tick at 144 FPS if possible). It's also possible to use a custom QAnimationDriver or manually drive the render loop, but typically vsync is desired to avoid tearing.
- **No GUI Blocking:** Because painting is offloaded, the GUI thread remains free to process input events. In a QQuickWidget, heavy rendering would block the event loop (since they share a thread), but with a QQuickWindow the UI stays responsive even under load. The separation also means things like resizing the window or OS event processing remain smoother.

**Why QQuickWindow Solves the FBO Problem:** Simply put, QQuickWindow avoids the offscreen-to-onscreen copy by making the Qt Quick scenegraph the primary renderer of the window's content. Qt Quick effectively "owns" the window's framebuffer. This eliminates the need for QQuickWidget's integration layer that had to merge into an existing widget hierarchy. The performance gain is both on the CPU (less overhead in Qt's paint system) and GPU (one less full-screen draw). In our projected metrics, removing the QQuickWidget wrapper saves **2-4 ms** per frame and allows the **frame time to drop to ~4-6 ms**, easily hitting 120 Hz[\[18\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=%7C,EXCELLENT)[\[19\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=match%20at%20L247%20Projected%20,6ms%20%28easily%20120%2B%20Hz%20capable). Additionally, the threaded renderer can overlap some of our data processing (e.g. the DataProcessor's work in parallel with rendering)[\[20\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=%7C%20,%28total%20rewrite)[\[21\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=Projected%20%28QQuickView%2FQQuickWindow%29%20,6ms%20%28easily%20120%2B%20Hz%20capable).

It's worth noting that **QWidget::createWindowContainer()** (which allows embedding a QQuickWindow into a widget UI) does introduce _some_ minor overhead or quirks, but far less than QQuickWidget. The Qt documentation indicates that createWindowContainer, like QQuickWidget, might incur a "minor performance overhead" due to effectively embedding a native child window[\[22\]](https://runebook.dev/en/articles/qt/qwidget/createWindowContainer#:~:text=verify%20compatibility.%20,this%20might%20be%20a%20factor). However, unlike QQuickWidget, the QQuickWindow within still uses the threaded loop and direct rendering[\[3\]](https://forum.qt.io/topic/55762/performance-of-qquickwidget#:~:text=,performance%20when%20compared%20to%20QQuickWidget). The overhead is mostly around event handling and possibly an extra composition by the OS if the child window is translucent. In practice, many Qt apps have successfully used createWindowContainer for high-performance OpenGL content.

**Summary:** The QQuickWindow pipeline restores Qt Quick's intended high-performance path: **threaded GPU rendering with no extra composition pass**. We'll exploit this by refactoring Sentinel's chart to render via a QQuickWindow. We expect full 120 FPS throughput on powerful GPUs and significantly improved CPU headroom. The next sections cover how to implement this change and optimize the scenegraph usage for our specific case of dense geometry (50k+ cells).

## Deep Dive: updatePaintNode(), Buffer Reuse, and Scenegraph Node Management at Scale

Sentinel's custom renderer (UnifiedGridRenderer) already uses Qt Quick's scenegraph API: it subclasses QQuickItem and implements updatePaintNode(QSGNode \*oldNode, UpdatePaintNodeData \*). This is the hook where we construct or update the **QSGNode tree** representing our chart. Understanding this function deeply is key to performance, especially with tens of thousands of data points. Let's break down best practices:

- **One-Time Node Allocation:** The first time updatePaintNode() is called, oldNode will be null (no existing node tree). We should allocate a persistent QSGNode hierarchy here and reuse it on subsequent calls[\[23\]](https://stackoverflow.com/questions/46394155/how-to-use-qsggeometrynode-without-causing-a-memory-leak-and-ensure-correct-clea#:~:text=QSGNode%20,updatePaintNodeData%29). Sentinel does this correctly: we create a root GridSceneNode (subclass of QSGTransformNode perhaps) and child QSGGeometryNodes for heatmap cells, etc. On later calls, we _should not_ delete and recreate the nodes; instead, update their data. Reusing nodes avoids repeated malloc/free and lets Qt Quick potentially retain GPU resources (vertex buffers, etc.) across frames[\[24\]](https://stackoverflow.com/questions/46394155/how-to-use-qsggeometrynode-without-causing-a-memory-leak-and-ensure-correct-clea#:~:text=Second%20question%3A%20Is%20this%20a,good%20way)[\[25\]](https://stackoverflow.com/questions/46394155/how-to-use-qsggeometrynode-without-causing-a-memory-leak-and-ensure-correct-clea#:~:text=QSGGeometryNode%20,node%20%3D%20new%20QSGGeometryNode). In practice, we check if oldNode exists - if not, create and set up geometry & material; if yes, update it.
- **Reuse and Mark Dirty vs. Reallocate:** For dynamic content like a heatmap, the geometry (vertices) will change each frame or frequently. The naive approach would call removeAllChildNodes() or create new QSGGeometry on each update, which is **inefficient**[\[24\]](https://stackoverflow.com/questions/46394155/how-to-use-qsggeometrynode-without-causing-a-memory-leak-and-ensure-correct-clea#:~:text=Second%20question%3A%20Is%20this%20a,good%20way). Instead, allocate a large enough QSGGeometry buffer once and then fill it with new vertex data each frame. Qt provides QSGGeometry::vertexDataAs...() to get a pointer to the array - we can efficiently memcpy or write into it. After updating, call node->markDirty(QSGNode::DirtyGeometry) to signal the changes[\[26\]](https://medium.com/@thawfeekyahya/understanding-qt-graphics-part-3-scene-graph-b316e3ab01f2#:~:text=The%20QSGFlatColorMaterial%20sets%20the%20color,a%20fragment%20shader%20in%20OpenGL)[\[27\]](https://stackoverflow.com/questions/46394155/how-to-use-qsggeometrynode-without-causing-a-memory-leak-and-ensure-correct-clea#:~:text=QSGGeometry%20,markDirty%28QSGNode%3A%3ADirtyGeometry%29%20because%20setGeometry%20is%20called). This approach avoids heap churn and often allows the underlying GPU buffer to be reused (Qt's scenegraph may use persistent buffers and just orphan/replace data). **Key rule:** _never delete and recreate QSGNodes or materials every frame if you can update in place_. The StackOverflow answer confirms: _"There is no point in creating and deleting nodes every time… reuse them"_[\[24\]](https://stackoverflow.com/questions/46394155/how-to-use-qsggeometrynode-without-causing-a-memory-leak-and-ensure-correct-clea#:~:text=Second%20question%3A%20Is%20this%20a,good%20way).
- **Ownership Flags:** When creating geometry or materials, set the proper ownership flags so Qt will clean them up when the node is deleted (e.g. node->setFlag(QSGNode::OwnsGeometry) if we allocate a new QSGGeometry, and OwnsMaterial similarly)[\[28\]](https://stackoverflow.com/questions/46394155/how-to-use-qsggeometrynode-without-causing-a-memory-leak-and-ensure-correct-clea#:~:text=node%20%3D%20new%20QSGGeometryNode%3B)[\[29\]](https://stackoverflow.com/questions/46394155/how-to-use-qsggeometrynode-without-causing-a-memory-leak-and-ensure-correct-clea#:~:text=QSGVertexColorMaterial%20,setFlag%28QSGNode%3A%3AOwnsMaterial%29%3B). This ensures no leaks if the scene is destroyed or if we ever do replace the geometry object.
- **Efficient QSGGeometry Usage:** For 50k cells, each cell might be represented as two triangles (a quad) - that's 100k triangles, 200k vertices. Qt Quick can handle on the order of millions of vertices, but we should be mindful of how we send data. Using QSGGeometry::allocate() with the exact vertex count needed is reasonable[\[30\]](https://forum.qt.io/topic/30848/qsggeometry-scenegraph-how-to-reuse-data-from-qsggeometry#:~:text=%40%20QSGGeometry%2A%20geometryNewLine%20%3D%20mNodeNewLine,vertexDataAsColoredPoint2D), but it may reallocate the buffer each time if the count changes. It might be better to over-allocate a maximum buffer once (say for 60k cells) and then just use the first N vertices as needed. Unfortunately, QSGGeometry doesn't have an explicit "used vertex count" aside from the allocate size; but we can keep track not to write beyond the needed count and still call markDirty. Another approach is to maintain multiple smaller geometries grouped logically (e.g. one QSGGeometryNode per row or per region of the heatmap) so that updates that affect only part of the scene don't require touching one giant buffer - though too many nodes can add overhead too. This is a balancing act: **one giant node vs. many smaller nodes**:
- One giant node (all 50k quads): Minimizes draw calls (potentially one draw), but any change means that large buffer is touched. If using the same material for all, Qt's renderer will anyway batch them as one draw[\[31\]](https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html#:~:text=The%20default%20renderer%20focuses%20on,of%20geometry%20on%20the%20GPU)[\[32\]](https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html#:~:text=The%20default%20scene%20graph%20renderer,calls%2C%20resulting%20in%20optimal%20performance).
- Many smaller nodes: Could allow frustum culling and partial updates (Qt Quick could skip drawing nodes entirely outside view). But too many nodes (tens of thousands) might strain the scenegraph bookkeeping. A reasonable compromise might be one node per "strip" of the chart (e.g. one QSGGeometryNode per time interval or price level bucket).
- **Scenegraph Batching:** Qt Quick's **default renderer will batch geometry with identical state** to reduce draw calls[\[31\]](https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html#:~:text=The%20default%20renderer%20focuses%20on,of%20geometry%20on%20the%20GPU)[\[32\]](https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html#:~:text=The%20default%20scene%20graph%20renderer,calls%2C%20resulting%20in%20optimal%20performance). It sorts drawables into opaque and translucent and can merge consecutive primitives with the same material into one GPU draw[\[33\]](https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html#:~:text=When%20each%20primitive%20is%20large%2C,up%20to%20a%20considerable%20overhead)[\[32\]](https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html#:~:text=The%20default%20scene%20graph%20renderer,calls%2C%20resulting%20in%20optimal%20performance). Therefore, if we split our heatmap into multiple QSGGeometryNodes but they use the same QSGVertexColorMaterial and no overlapping transparency issues, Qt might batch them under the hood, so draw call count might remain low. If the data is mostly opaque (no alpha blending needed except maybe for some overlay), we benefit because Qt can reorder and batch opaque calls freely[\[34\]](https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html#:~:text=Opaque%20Primitives). With translucent (alpha) geometry (like semi-transparent volume bars), Qt will batch as long as they don't overlap out of order[\[35\]](https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html#:~:text=Once%20opaque%20primitives%20have%20been,front%20manner). Our heatmap likely uses alpha for some blending, but if each cell is a separate quad, overlapping is minimal (just edge touching), so some batching still occurs. **Bottom line:** We can structure our scenegraph into logical chunks, confident that Qt will merge them when possible, but we should avoid unnecessary state differences (e.g. don't use 50k distinct materials - use one material with per-vertex color as we do).
- **Culling and LOD:** For 50k cells, if many are outside the current view (due to zoom/pan), we should avoid drawing them. Qt's scenegraph frustum culling is limited - it will frustum-cull at the level of QSGOpacityNode or QSGTransformNode subtrees, but it doesn't clip individual geometry within a node. So if we have one node for the whole heatmap, Qt either draws it or not, depending if its bounding box intersects the view. If our entire dataset is always onscreen (like a dense matrix filling the view), then culling is moot. But if user zooms in, many data points might lie outside the view. In that case, splitting geometry into subnodes (each with its own bounding rect) allows Qt to skip whole nodes outside the viewport[\[36\]](file://file_00000000826461f5a6e37eebce169eaf#:~:text=material%3F%20,nodes%20vs%20one%20giant%20node). We might use a QSGClipNode (which defines a scissor rect) to limit drawing to the viewport, but that won't skip processing vertices outside - it just discards fragments outside the clip. So better is to actually not include far-away data in the node at all. Our GridSceneNode (root transform) could have children per certain range. We'll incorporate such LOD grouping in the design.
- **When updatePaintNode() Runs (Threading):** In threaded mode, updatePaintNode() still runs on the GUI thread, _not_ the render thread[\[37\]](file://file_00000000826461f5a6e37eebce169eaf#:~:text=3.%20%2A%2AThreaded%20Scenegraph%2A%2A%3A%20,thread%20safety%20in%20scenegraph%20code). The GUI thread calls it, and the returned QSGNode tree is handed off to the render thread. This means our updatePaintNode must be careful to not access any GUI-only state improperly, but since it's on GUI thread it can safely read our data model (we ensure data is synchronized before calling update). Communication between threads should happen via the standard signal-slot we have (DataProcessor emits signal, Qt queues to GUI, calls update). That architecture is correct as noted in the code review: data arrives on a worker thread, and we use Qt's thread-safe signal to schedule UI update - good✅[\[38\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=3.%20%2A%2A%E2%9C%85%20Threading%20Architecture%2A%2A%20,No%20blocking%20on%20GUI%20thread). We just need to ensure minimal locking (we already have a mutex for the shared data buffer, presumably).
- **Thread-Safety Rules:** Inside updatePaintNode (GUI thread) we must not directly touch OpenGL or QRhi (that's render thread's job). We should also avoid heavy computations here - any heavy CPU work (aggregation, etc.) ideally is done before, in the data processor. The updatePaintNode should mostly take prepared data (e.g. an array of vertices from our core) and copy it into QSGGeometry arrays. This is O(n) with n=300k vertices, which at 120 Hz is ~36 million writes per second - borderline but possibly okay in C++ if optimized (36M float writes ~ 144 MB/s, which is fine on modern memory). Still, we should watch this in the profiler.
- **Material Choice:** We use QSGVertexColorMaterial, which is convenient (built-in shader that takes per-vertex colors). This is fine for a heatmap with varying colors. Its performance is generally good, but if we find the fragment shader becomes heavy, we could consider a custom shader. For example, one idea: instead of sending a colored quad per cell, we could send value data to the GPU and have a shader compute color based on a colormap. But that would require a custom QSGMaterial with a custom shader (which Qt 6 allows via the new shader pipeline in QSGMaterialShader). At our scale, vertex color is okay, but note that QSGVertexColorMaterial doesn't enable blending by default unless the colors have alpha &lt; 1. If we need blending (transparency effects), we should ensure to set material-&gt;setFlag(QSGMaterial::Blending) or use a translucent material variant.
- **Max Node Count:** 50k cells as individual QSGNodes (if one were to do that naïvely with QQuickItems or QSGNodes per cell) would be disastrous - too many items. Instead, our approach uses far fewer nodes (one node per layer or so). The "max practical size" for one QSGGeometryNode is mostly limited by memory - a few hundred thousand vertices is fine. Qt's renderer even notes that even if every frame is unique and uploaded from scratch, it can handle it[\[39\]](https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html#:~:text=graphics%20chip). The primary limit is ensuring we stay within GPU memory and bus limits for dynamic uploads. 300k vertices \* 2 floats \* 2 (position and maybe texture coords or just position+color?), plus color per vertex (4 bytes RGBA each) - roughly: position (8 bytes per vertex), color (4 bytes per vertex) = 12 bytes per vertex. 300k vertices = ~3.6 MB per frame - even at 120 Hz that's ~432 MB/s, which is borderline but possibly manageable over PCIe, especially if using persistent mapping (though Qt may be doing some double-buffering of these VBOs). On integrated GPUs, that might saturate memory bandwidth. This is where partial updates or LOD could help: if the user zooms out showing all data, maybe reduce detail (skip some points), and if zoomed in, fewer points are in view anyway.
- **Persistent Mapping and QRhi:** In Qt 6, the scenegraph uses QRhi under the hood. We don't directly control if the vertex buffer is mapped persistently or using dynamic strategy, but Qt's renderer tries to retain geometry on GPU[\[31\]](https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html#:~:text=The%20default%20renderer%20focuses%20on,of%20geometry%20on%20the%20GPU). It likely uses a strategy where QSGGeometry is uploaded to a GPU buffer that persists until it needs resize. If we call QSGGeometry::allocate() larger than last time, a new buffer may be allocated; if same size or smaller, maybe it reuses the existing. We can hint usage by how we call allocate: unfortunately Qt doesn't expose a usage flag like GL_DYNAMIC_DRAW - it manages that internally.

In summary, **updatePaintNode best practices for Sentinel**: _Allocate once, reuse nodes/geometry, update in place, mark dirty, batch where possible, and structure the scenegraph to allow culling and LOD._ The code is already mostly doing this - e.g. the use of GridSceneNode and strategy pattern is good✅[\[40\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=What%27s%20RIGHT%20With%20Your%20Code)[\[41\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=,QSGFlatColorMaterial). We should double-check that we are not inadvertently recreating sub-nodes each frame. If our HeatmapStrategy currently builds new QSGGeometryNodes on each call, we should refactor it to cache those nodes in the strategy object and only update their geometry. This might involve storing pointers to created QSGNodes within the strategy class so that on subsequent calls we don't allocate again.

Finally, we must utilize Qt's tools to ensure we manage the scenegraph efficiently: - The **Qt Quick Profiler** (in Qt Creator) can show how much time is spent in painting, sync, render, etc. Look specifically at "Sync" stage (which includes updatePaintNode) and "Render" stage. This can confirm if our update logic or Qt's render is the hotspot. - Enabling QSG_VISUALIZE=overdraw or QSG_VISUALIZE=batches can help debug batching and overdraw in our scene[\[32\]](https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html#:~:text=The%20default%20scene%20graph%20renderer,calls%2C%20resulting%20in%20optimal%20performance). It color-codes batches so we can see how many separate draw calls occur. We'd want to see either one big batch or a small number of batches for our heatmap.

By following these practices, a 50k cell update should comfortably fit in ~4-5 ms on CPU (updatePaintNode) and maybe similar on GPU, keeping us within 8 ms per frame budget on a powerful system.

## Best Practices for Dense Visualizations (Dirty Flags, Partial Updates, LOD)

High-frequency trading visuals combine _dense data_ with _frequent updates_. This demands careful design to avoid unnecessary work per frame. Here are specific best practices relevant to Sentinel:

- **Dirty Flags & Partial Updates:** Qt's scenegraph allows marking only certain aspects as dirty. Use node->markDirty(QSGNode::DirtyGeometry) when only vertex data changed, and DirtyMaterial if colors or other material properties changed[\[26\]](https://medium.com/@thawfeekyahya/understanding-qt-graphics-part-3-scene-graph-b316e3ab01f2#:~:text=The%20QSGFlatColorMaterial%20sets%20the%20color,a%20fragment%20shader%20in%20OpenGL)[\[29\]](https://stackoverflow.com/questions/46394155/how-to-use-qsggeometrynode-without-causing-a-memory-leak-and-ensure-correct-clea#:~:text=QSGVertexColorMaterial%20,setFlag%28QSGNode%3A%3AOwnsMaterial%29%3B). Avoid calling a blanket update() on the entire QQuickItem if only a small part changed, unless it's simpler. If data changes are localized (e.g. only one region of the heatmap updated), consider structuring the QSGNodes so that you can call update() (which triggers updatePaintNode) only on that sub-component. However, since our renderer is one QQuickItem for the whole chart, calling update() will refresh the whole item. We might implement our own internal partial update: e.g., if only a small set of cells change, we could update their vertices in the geometry array and mark dirty without rebuilding everything. This requires we keep the old geometry around and know which indices to modify. It might be over-optimization if the whole data changes each frame anyway (e.g. new order book data shifts the entire heatmap). **In practice**, due to the nature of order book heatmaps, a large portion of the map can change each tick (many price levels updated). So partial update granularity might not buy much - we likely rebuild most vertices each frame. But if there are cases (like a slow feed) where only 10 cells change, we could still be efficient by only updating those in the array (still calling markDirty so Qt knows something changed - it doesn't know _which_ part, so it might retransfer the whole buffer anyway).
- **Level of Detail (LOD):** Implementing LOD means drawing less detail when zoomed out. For time-series heatmaps, one approach is CPU aggregation: e.g., at 1-hour view, aggregate 100 price levels into 1, etc. Sentinel's LiquidityTimeSeriesEngine likely already aggregates data for different zoom levels on the CPU. The scenegraph can then be simplified (fewer quads) for coarse views. On the GPU side, another concept is using **mipmaps or hierarchical textures**: you could render the heatmap into a texture at full resolution and let the GPU downsample it for zoomed-out views (or precompute mipmaps). Qt Quick doesn't have built-in support for dynamic mipmaps, but we could use a custom QSGImage with a generated texture. However, generating that texture each frame is essentially doing the same work as drawing quads. Unless we offload aggregation to a **compute shader** (see below), it might not help. A simpler LOD is: _skip drawing certain elements when they'd be smaller than a pixel_. For example, if zoomed far out, multiple price levels map to 1 screen pixel column - drawing all might be overkill. We can choose to draw a representative or average. This logic would live in updatePaintNode (decide how many quads to draw). It trades accuracy for speed at extreme zoom out.
- **LOD in GPU (Compute Shaders):** Qt 6's QRhi does allow compute shaders. We could, in theory, maintain a GPU buffer of raw order book data and run a compute shader to aggregate it into a texture or vertex buffer for rendering. This is advanced and might be overkill if CPU can do it fast enough (which it usually can for 50k points). Still, Qt Quick 6.6+ supports using QSGRenderNode or QQuickFramebufferObject to inject custom GL/Vulkan code. Or one can use QRhi directly in C++ to do compute and then display via a custom QSGMaterial. This is complex and would diminish code reuse. Unless profiling shows the CPU aggregation as a bottleneck (which at 150µs per update, it is not[\[42\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=,~150%C2%B5s%20update%20latency%20%28GOOD)), we should avoid this complexity.
- **Vertex Buffer Reuse & Persistent Mapping:** If possible, ensure that the vertex buffer is updated efficiently. Some low-level optimization: On OpenGL, using a persistently mapped buffer or triple buffering dynamic data can improve throughput by avoiding glMapBuffer stalls. Qt's scenegraph likely already does something akin to double-buffering the geometry uploads behind the scenes (especially since Qt Quick 2.0 days, they optimized that). We don't directly control it, but we can observe if the GPU thread is waiting on buffer uploads. Tools like **RenderDoc or Nsight** can capture a frame and show if multiple buffers are used or if a buffer is orphaned. If issues are found, one could consider using QSGDynamicTexture or QQuickFramebufferObject to manually manage data - but that's a huge effort. Most likely, sticking to QSGGeometry with proper Dirty flags is enough.
- **Minimize State Changes:** If we had multiple materials or states, ensure we group geometry by material to leverage Qt's batching. In our case, using one QSGVertexColorMaterial for everything is ideal. If we later add overlays (like points or lines), try to use the same material if possible (e.g. also vertex-colored geometry) so they could batch with the heatmap - or layer them carefully. If layering requires different blend modes or shaders, that's fine, but just note each unique material might result in a separate batch/draw.
- **Clipping & Scissor:** If using QSGClipNode for the viewport, ensure it's only one and wraps the entire chart content. ClipNodes can prevent batching optimization if overused, and they cost some scissor state change. One clip is fine (for example, if the chart is in a scrolling view, a clip might delineate the scroll area). But avoid per-cell clipping or anything like that.
- **Text Rendering:** Not directly asked, but if we have price labels or axes: Qt Quick's Text items or custom text can be heavy if many. If we ever need to render thousands of labels, consider using distance field text or QSGGlyphNode directly. But likely our axes have at most dozens of labels - fine with Qt Quick Text.

To summarize, for dense visualization in Qt Quick: _Use large, single-pass draws with reused geometry, exploit Qt's internal batching, reduce per-frame allocations, and only draw what's necessary (via culling or LOD)._ Sentinel's current implementation already embodies many of these, given its modular strategies and scenegraph usage✅[\[41\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=,QSGFlatColorMaterial). We will refine it by eliminating any unnecessary node churn and possibly introducing basic LOD (like not drawing every single pixel when zoomed way out).

## Data Pipeline → Scenegraph → GPU: End-to-End Diagram

Let's paint a clear picture of how data flows from market feed to rendered pixels in the new architecture:

Worker Thread (Data) GUI Thread (Qt Quick) Render Thread (Qt Quick)  
\----------------------- ------------------------- --------------------------  
Exchange feed --> MarketDataCore --> DataProcessor --> \[Signal\] --> UnifiedGridRenderer::update()  
(posts update request)  
|--> Qt Quick's update cycle runs (vsync driven)  
| calls UnifiedGridRenderer::updatePaintNode(oldNode)  
| - oldNode != null: reuse QSGNode tree  
| - copy new vertex data into QSGGeometry (e.g. 50k quads)  
| - markDirty on nodes as needed  
| - return root QSGNode (scenegraph ready)  
|--> Qt Quick scenegraph sync completes, hands off nodes -->  
|--> Scenegraph render begins  
| (QQuickWindow render thread)  
|--> Traverse QSGNode tree:  
| group/batch geometry by material  
| issue draw calls via QRhi (GL/Metal/Vulkan)  
|--> GPU executes draws (possibly overlaps next CPU frame)  
|--> Frame rendered to backbuffer (window)  
|--> Display via vsync swapbuffers

**Explanation:** The data arrives on a worker, which signals the GUI. The GUI thread doesn't block - it just schedules an update. On the next frame, Qt calls our updatePaintNode to prepare the geometry. Once that's done, the QSGNode tree is updated. Then the render thread wakes up (on vsync or immediately if driving at full speed without vsync) and renders the QSGNode content. The render thread uses **QRhi** to interface with the GPU: on Windows, this might be D3D11 or OpenGL, on macOS Metal, etc. (Qt chooses best available; we can override if needed). The GPU execution might take e.g. 2-3 ms, during which the GUI thread could already handle user input or start preparing the next update if one is queued. This pipeline repeats each frame.

This architecture is **double-buffered** by nature: the GUI can work on frame N+1 while frame N is being drawn. There's a synchronization point at the end of updatePaintNode/scenegraph sync where the render thread must wait for the GUI to finish preparing nodes each frame (or vice versa if GUI is slower). But overall it's a pipelined approach conducive to high throughput.

We should also include what happens if data updates outrun the frame rate: Qt Quick will drop or merge some updates. For example, if DataProcessor emits 200 signals per second but we cap rendering at 120 FPS, the GUI thread might already have an update pending, so additional update() calls might be coalesced. Qt's QQuickItem::update() documentation implies it does not immediately render but flags the item for update on the next cycle[\[43\]](https://stackoverflow.com/questions/30676393/how-to-set-the-qquickitem-position-at-a-precise-frame-from-c#:~:text=C%2B%2B%3F%20stackoverflow,think%20that%20it%27s%20not). Thus, if an update is already pending, further calls don't queue a separate frame - they just ensure that by the time the render happens, the latest data will be used. (Of course, if we push new data in between frames, we might miss intermediate states - which is usually fine for high-frequency streams: better to drop some frames than fall behind.)

Below is a conceptual diagram comparing **Current vs. New** pipeline:

Current (QQuickWidget) Pipeline: New (QQuickWindow) Pipeline:  
\------------------------------- ----------------------------  
Data thread signal (120 Hz) Data thread signal (120 Hz)  
| |  
GUI thread: QQuickWidget::update() GUI thread: QQuickWindow (QQmlEngine) update()  
| \[Scenegraph: Basic (no separate thread)\] | \[Scenegraph: Threaded\]  
GUI thread: updatePaintNode() (create QSGNodes) GUI thread: updatePaintNode() (update QSGNodes)  
| |  
GUI thread: Scenegraph renders to FBO (CPU waits) \*\*Render thread\*\*: Scenegraph renders to backbuffer  
| | (GPU commands via QRhi)  
GUI thread: FBO -> QImage/texture copy (GPU->GPU) |  
| | (GUI thread in parallel can process input)  
GUI thread: QWidget paints image to window |  
| |  
OS compositor presents window (vsync) OS compositor presents window (vsync)

In the new pipeline, the **render thread** does the heavy GPU work, and the intermediate copy step is gone[\[5\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=For%20120%20Hz%20updates%2C%20this,compositor%29). The GUI thread and render thread run in parallel for much of the frame, increasing throughput.

_(Note: The actual Qt Quick internals are more complex - there's a sync stage where GUI and render threads synchronize scene state. But the above is conceptually accurate for our purposes.)_

## Throttling and Coalescing Updates for 120+ Hz

Publishing data at 120 Hz or more can potentially overwhelm the rendering pipeline if not managed. Even with an optimized render loop, we need to ensure we handle bursts of updates gracefully:

- **Upstream Throttling:** Ideally, throttle updates at the source - if the exchange feed is, say, 500 updates/sec in bursts, the DataProcessor could down-sample or coalesce them to ~120/sec. This can be done by accumulating changes in a short time window. For example, if 5 updates arrive within 8ms, applying them all then issuing one render update is better than 5 separate frames (we can only draw at ~8ms intervals anyway). Sentinel already has _"throttled updates (250ms in initializeV2Architecture)"_ configured[\[44\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=4.%20%2A%2A%E2%9C%85%20Data%20Pipeline%2A%2A%20,initializeV2Architecture) - perhaps that was a coarse throttle. For 120 Hz, we want ~8ms throttle, not 250ms. We might implement a dynamic throttle: allow up to one update per frame. A simple strategy: if an update signal arrives while a previous update is still waiting to render, skip or merge it. This might be automatically achieved by Qt's update mechanism, but if not, we can incorporate a boolean flag or timestamp.
- **Coalescing Data:** When merging updates, ensure no important data is lost. If we drop intermediate states, it's usually fine if we're just drawing the latest state of an order book. But if the visualization needs to show every tick (e.g. a blip for each trade), dropping might lose info. In such cases, rather than dropping, we can compress multiple events into one (e.g. sum the volume of all trades in that frame). For heatmap and depth, likely the latest state is what matters (order book depth at the time of render), so last-update-wins is acceptable.
- **Frame Timing & Vsync:** Qt Quick's render loop is tied to vsync by default. On a 120 Hz monitor, that's perfect. If a monitor is 60 Hz, Qt will cap at 60 FPS unless we disable vsync (not recommended, as it causes tearing). We should allow the app to run uncapped if the user wants (e.g. offscreen or high-speed mode), but in general matching display refresh is ideal. Qt Quick will wait for vsync to present frames, implicitly throttling the generation of frames to the display rate. We might not need additional throttling in that case; we just need to ensure our data source doesn't produce backlog.
- **Using QQuickWindow Signals:** We can connect to QQuickWindow::beforeRendering() or afterRendering() signals to coordinate timing. For example, some apps use a technique: after each frame, schedule the next data update. But since our data is externally driven (exchange feed), a more useful approach is to keep a **lock-free queue** of incoming data and have the GUI thread pull from it at a steady rate (max 120 Hz). Sentinel's mention of a LockFreeQueue.h suggests a queue is used[\[45\]](file://file_00000000826461f5a6e37eebce169eaf#:~:text=,thread%20safety%20in%20scenegraph%20code)[\[46\]](file://file_00000000826461f5a6e37eebce169eaf#:~:text=,render%20thread%20when%20fetching%20data). We can modify the GUI side to not process every single queued item individually, but rather to always replace the current data with the latest available when a frame is about to render.
- **Implementation idea (coalescing):** Suppose DataProcessor pushes OrderBook snapshots into a lock-free queue. The GUI thread sets up a timer or uses the QQuickWindow's animation frame callback to pull from the queue at most once per frame. If multiple snapshots accumulated, it takes the latest. This ensures we never do more than one updatePaintNode per frame, no matter how fast data comes. This is a standard producer-consumer throttle.
- **Where to Throttle:** Likely on the GUI thread side, since that's where rendering happens. The DataProcessor can push freely, and the GUI decides how much to consume. Alternatively, the DataProcessor can do some coalescing itself (like only emit if no update signal is pending). Qt's queued signals won't queue up infinitely by default - if the slots take time, signals might pile up though. We could drop signals if they are too frequent. A pattern is using QObject::disconnect temporarily or using a single-shot timer: e.g., on first data, call update(), then ignore further data for the next X ms. But a cleaner approach is the queue approach above.
- **Avoiding Jank:** We must be careful that throttling doesn't introduce visible stutter. If data really updates 120 times/sec and we throttle to 60, the visual might lag behind or look stepped. Our goal is to not drop below 120 unless necessary. On integrated GPUs, we target 60 FPS, so maybe we _will_ throttle to 60. We could adaptively throttle based on measured frame time. For example, if we detect our frame time is >16ms (i.e. system can't maintain 60), we might drop to 60 updates/sec intake.
- **Testing Throttle:** We can simulate a worst-case: push 1000 updates/sec of random data and ensure the UI remains stable at 120 FPS and doesn't memory-bloat. The log or QSG_INFO can indicate if frames are being skipped.
- **"Just-In-Time" updates:** If we can align data arrival with frame boundaries, that's ideal. This is rarely possible with live feeds (they come when they come). But imagine if data is at 120 Hz _and_ vsync is 120 Hz, and if they drift, sometimes a frame might have no new data, sometimes one, sometimes two updates. That causes uneven frame times or wasted renders (frame did nothing because no new data). One could buffer an update until just before rendering. QQuickWindow doesn't expose explicit vsync timestamps easily (though afterRendering is just after swap). A pragmatic solution: if an update arrives very soon after the last frame was rendered, maybe delay processing it slightly so that it will still be fresh by next vsync. This is micro-optimization and probably unnecessary unless we see jitter.
- **Lock-Free Data Transfer:** If using a lock-free queue, ensure thread safety when reading on GUI and writing on worker. These structures can be tricky but high-perf. Alternatively, a ring buffer with atomic indices can work. The key is to avoid locking the render thread. We likely already do this (the code's threading was marked correct✅[\[38\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=3.%20%2A%2A%E2%9C%85%20Threading%20Architecture%2A%2A%20,No%20blocking%20on%20GUI%20thread)). Just ensure the queue doesn't grow unbounded - if GUI is slow, old data should be dropped. Lock-free does not automatically drop; we might need to explicitly only keep the latest.
- **Partial Updates vs Full:** As mentioned earlier, if only 5% of cells changed, we _could_ only update those. But detecting that and updating partial geometry adds complexity. In a high-frequency scenario, often most of the scene changes (e.g. the entire order book shifts when a new trade happens). However, if we find that deep in the order book nothing changed, we need not redraw it. Some strategies:
- Maintain flags or timestamps per row/column indicating if it changed.
- If unchanged, perhaps skip marking that part dirty. But if it's part of one big geometry, we cannot partially skip - we'd need separate nodes per row to skip an unchanged row, etc. That might be over-engineering if changes are typically widespread.

In practice, our plan is: **one update per frame max, using latest data, and possibly dropping intermediate states**. This guarantees no flooding. We already have the scenegraph able to handle full redraw at 120 FPS, which is ~8ms. If we meet that performance, we're golden. If not, then we consider partial updates or further throttle.

## Cross-Platform Rendering via QRhi (Qt Rendering Hardware Interface)

Qt 6 introduced **QRhi** - an abstraction layer that Qt Quick uses to target different graphics APIs (OpenGL, Vulkan, Metal, DirectX) with the same scenegraph code[\[47\]](https://doc.qt.io/qt-6/qrhi.html#:~:text=QRhi%20is%20an%20abstraction%20for,ES%2C%20Direct3D%2C%20Metal%2C%20and%20Vulkan)[\[48\]](https://doc.qt.io/qt-6/qrhi.html#:~:text=The%20Qt%20Rendering%20Hardware%20Interface,ES%2C%20Direct3D%2C%20Metal%2C%20and%20Vulkan). For Sentinel, cross-platform means: - Windows: likely Direct3D 11 by default (Qt 6 uses D3D11 on Windows unless told otherwise). - macOS: Metal by default. - Linux: OpenGL by default (or Vulkan if configured, but OpenGL is still common due to driver maturity, or possibly via ANGLE). - We could also choose Vulkan on Windows/Linux if we want the same API everywhere.

**Why QRhi matters:** It gives consistent behavior and performance across backends. We should verify that our custom QSG code works fine on all backends: - QSGGeometryNode and default materials should be supported on all (they are). - There are subtle differences: for instance, on Direct3D, the coordinate system might be different (Y-up vs Y-down or half-pixel offsets). Qt hides this, but one must be careful with e.g. antialiasing (which we might not use) or certain shader code. If we write a custom shader later, QRhi requires writing in SPIR-V or cross-platform format (Qt's new shader pipeline uses .qsb files that contain multiple versions). - If using any **OpenGL-specific calls** (we are not, except QSGGeometry which Qt handles), they must be removed. E.g. old QQuickFramebufferObject-based code might have direct GL calls; then on Metal it fails. We are not using those, so likely all good.

**Consistency:** By using Qt Quick's scenegraph API, we automatically get the benefit of QRhi. As the Qt docs state, QQuickWidget and QQuickWindow can work with OpenGL, Vulkan, Metal, D3D through the RHI[\[10\]](https://doc.qt.io/qt-6/qquickwidget.html#:~:text=QQuickWidget%20is%20functional%20with%20all,QQuickWidget%20will%20lead%20to%20problems). In Qt 6.6+, the default on each platform is chosen for you, but you can override via QQuickWindow::setGraphicsApi(). We should ensure that on macOS we are indeed using Metal (Qt might default to Metal or possibly still OpenGL via MoltenGL in some cases - but pretty sure Qt6 defaults to Metal if available). On Windows, ensure ANGLE (OpenGL-on-D3D) is not accidentally used - Qt may choose D3D11 directly since Qt6. If we encounter an issue like lower performance or compatibility on one backend, we can try switching. For example, some users reported Qt Quick on Nvidia Windows might be faster with OpenGL than D3D, or vice versa, depending on driver. QRhi allows easy switch.

**QRhi and Custom Rendering:** If in the future we want to integrate custom Vulkan or compute code, we can get the QRhi instance from the QQuickWindow (via QQuickWindow::rendererInterface()->getResource(window, QSGRendererInterface::RhiResource)). This would allow us to use the same graphics device as Qt Quick. For instance, if we wanted to do a compute shader for LOD, we could retrieve the QRhi (which is, say, a D3D11 device) and submit compute jobs. This is advanced and not needed for initial refactor, but good to be aware of.

**Metal (macOS) considerations:** Metal doesn't support some legacy features - but Qt Quick's implementation in Qt 6 is pretty robust. A potential area to watch: if our code had relied on OpenGL-specific things (like gl_PointSize in old Qt Graphical Effects, etc.). In our case, using QSGGeometry and stock materials should work seamlessly. We should test on macOS for any performance issues - historically, QQuickWidget on macOS (which used to rely on OpenGL via an OpenGL->Metal layer or software) was problematic. But with QQuickWindow and native Metal, it should be smooth.

**Direct3D (Windows):** Ensure that the GPU (like RTX 4070) is being used via the Direct3D 11 or 12 RHI. Qt 6.5+ actually has a D3D12 backend as well (optional). D3D11 is default. The performance between D3D11 and OpenGL - often D3D11 is more consistent on Windows (especially on integrated GPUs). D3D has slightly higher driver overhead per draw call, but since Qt batches draws, that's fine.

**Forcing a Backend:** We can allow a user or config to select backend via environment var QSG_RHI_BACKEND. E.g., QSG_RHI_BACKEND=opengl or metal etc. It might be worth exposing this for debugging ("safe mode" with OpenGL if Metal has an issue, etc). But it's not required.

**QRhi and Feature Parity:** The good news is our use-case (2D rectangles with colors) is supported everywhere. If we were using advanced features like 3D API-specific compute or tessellation, we'd have to check each. But 2D scene is fine.

**Testing across platforms:** We should test on at least one Mac, one Windows, one Linux. If hardware access is an issue, maybe use a cloud CI with virtual GPU (though those often only support software rendering). Local testing or community testing might be needed. Known issues might include: - _macOS:_ possibly different color space or if using very large metal buffers, etc., but unlikely an issue at 50k quads. - _Windows:_ If using Intel integrated, ensure latest drivers. Sometimes Qt's D3D can fall back to WARP (software) if driver issues - check logs if performance is unexpectedly low. - _Linux:_ If using NVIDIA binary driver with GL vs. AMD vs. Intel - any driver-specific problems. Qt Quick on NVIDIA GL can sometimes have high CPU overhead due to Qt's use of buffer orphaning; but hopefully with RHI that's improved.

**QRhi Future:** Qt 6.10 and beyond might add more uniform features (like extended compute or RT). For us, the key is that by sticking with Qt Quick, we automatically ride improvements to the RHI and scenegraph. If Qt optimizes something in 6.9, we benefit by upgrading, without changing our code. This is a strong argument _against_ abandoning Qt - it's doing a lot of heavy lifting for cross-platform rendering.

In conclusion, **QRhi ensures our Qt Quick scenegraph solution is future-proof and cross-platform.** We should use it as-is (no special action needed besides not using deprecated GL-only APIs). If any platform shows subpar performance, we can try toggling the backend or checking Qt bug reports, but generally it should be solid. We will document how to switch backend (for instance, an advanced user might set an env var to force OpenGL on Mac if they suspect an issue with Metal).

## Case Studies: High-Performance Trading Visualizations

To validate our approach and possibly draw lessons, let's look at how other trading/charting platforms handle rendering:

- **Bookmap:** A well-known high-frequency order book visualization. Bookmap is implemented in Java but uses native C++ with OpenGL for rendering[\[49\]](https://bookmap.com/knowledgebase/docs/KB-API-GeneralInfo#:~:text=Bookmap%20is%20a%20Java%20program,developed%20in%20Java%20and). Essentially, it embeds an OpenGL context in a Java UI (likely using JOGL or similar). This is analogous to what we're doing (embedding a high-speed renderer in a UI), except they rolled their own engine. Bookmap achieves 100+ FPS with thousands of updates because their rendering is low-level optimized (probably drawing quads for heatmap directly with OpenGL calls, and using techniques like shaders for intensity, etc.). They likely also throttle updates - e.g. not every single order might cause a redraw if it's minor. The key takeaway is that GPU acceleration (OpenGL) is mandatory for such apps, and mixing UI toolkits (Swing + OpenGL) requires an approach like we use with Qt (QWidget + QQuickWindow). Our use of Qt Quick is effectively using a GPU-accelerated scene similar to Bookmap's custom OpenGL, but Qt abstracts it. The fact that Bookmap uses C++ OpenGL under the hood suggests that if Qt Quick (which also uses C++ OpenGL/Vulkan) is properly used, it can match that performance. One difference: Bookmap's UI may be simpler to integrate because they treat the GL canvas almost like a game loop.
- **Sierra Chart:** An older platform, known for being extremely fast but with an outdated UI. Sierra Chart historically rendered charts using GDI (CPU) which was very efficient in the early 2000s, but they have since added an **OpenGL rendering option**[\[50\]](https://boostyourcharts.com/speed-performance/#:~:text=Performance%20boostyourcharts,movements%20and%20faster%20rendering). Users report that enabling OpenGL drastically improves chart draw times (500ms -> 50ms in one case)[\[51\]](https://www.sierrachart.com/SupportBoard.php?ThreadID=60826#:~:text=Helping%20guide%20for%20Building%20A,acceleration%2C%20it%27s%20day%20and%20night). This shows that even Sierra, which is heavily optimized C++ on Windows, needed GPU acceleration for more intensive visuals. Sierra's UI is not Qt; it's custom MFC or Win32. The OpenGL implementation is likely custom. They might not hit 120 FPS simply because their UI doesn't need to, but the capability is there when needed. The Sierra example underscores: if you stick to CPU rendering too long, you hit a wall - which Qt Quick solves by default with GPU.
- **TradingView:** It's web-based, but the charts use WebGL for performance. They maintain 60 FPS even with many indicators by drawing to WebGL canvas. The environment is different but principle is same: use GPU, batch draw calls, throttle updates (websocket data often coalesced to maybe 10 Hz unless you scroll actively, for efficiency). TradingView's smoothness also comes from easing animations and maybe not truly doing 120 FPS (browsers often do 60). It is, however, capable of more on high refresh displays thanks to requestAnimationFrame.
- **Quantower, NinjaTrader 8, ExoCharts:** These are .NET based. NinjaTrader 8 uses WPF for UI, which runs on DirectX under the hood. It likely doesn't achieve very high FPS if pushing lots of elements, as WPF isn't tuned for that many draw calls (plus .NET overhead). Some trader forums mention NinjaTrader feels slower in heavy scenarios compared to Sierra. Quantower is newer and maybe uses SharpDX or Skia for charts. Without concrete data, we assume they aim for 60 FPS and achieve it except in extreme cases. The architecture difference is that they might not utilize a retained-mode scenegraph like Qt Quick; some may just blit using GPU but not fully optimized.
- **Custom Engines (Game engines):** There have been attempts to use Unity or Unreal Engine for financial visualization (taking advantage of their optimized rendering). While rendering would be fast, integrating UI and data feed might be complex. Qt Quick is a nice middle ground where we get a scenegraph without going full game-engine.
- **ImGui (Immediate mode GUI):** Some suggest using ImGui (Dear ImGui) for such apps. ImGui is basically an immediate-mode GUI for game UIs, very efficient in drawing (it also batches all draw calls by default). If one were to rewrite Sentinel with ImGui, you'd manually draw quads via ImGui's draw lists each frame. It can be fast (ImGui can easily do 120 FPS for moderately complex scenes), but you lose Qt's higher-level features (layouts, etc.). Many trading apps don't use ImGui; they either use traditional GUI or custom. ImGui could serve as a lightweight UI wrapper around a custom OpenGL/Vulkan renderer. But that's a drastic move (we'll discuss in the next section when that might be needed).

**Key lessons from case studies:**  
1\. GPU acceleration is non-negotiable for modern, high-frequency charts (we're on the right path with Qt Quick).  
2\. Custom solutions (Bookmap, Sierra's OpenGL) confirm that the approach of drawing lots of geometry directly works - and Qt Quick essentially gives us the same capability with less effort. We just must optimize within Qt's framework (which we're doing by eliminating QQuickWidget).  
3\. Performance is a combination of _engine_ and _data handling_. All these platforms likely throttle or aggregate data. None try to draw every single tick if it's pointless to the user's perception. We should be mindful of not over-rendering changes that the user can't visually discern (e.g. 5 updates within 1/120s is imperceptible difference - skip some).  
4\. UI complexity (like multiple sub-windows, docks) can complicate using a purely game-engine approach. Qt gives us docking, menus, etc., which is a boon. Bookmap for instance has a simpler UI (just the chart and some side panels) - presumably easier to integrate with their GL. We have a full-fledged UI (docks, controls) that we don't want to throw away - which favors staying with Qt.

To sum up, our plan to use QQuickWindow aligns with the approaches seen in high-perf apps: **use the GPU directly**, avoid unnecessary abstraction layers, and keep most of the heavy lifting in C++ on the GPU. With Qt 6's modern scenegraph, we are effectively matching what a custom OpenGL engine would do.

## Refactor Plan - Step by Step Architecture Guide

Finally, we outline the concrete migration plan and optimizations in phases:

### Phase 0: Profiling & Bottleneck Confirmation

_Goal:_ Ensure we have solid baseline measurements and verify that QQuickWidget is indeed the culprit (and not some mistake in our renderer). This de-risks the migration.

**Tasks:**  
\- Enable QSG_INFO=1 and run Sentinel. Observe in the logs the frame timings. In QQuickWidget mode, we expect to see something like "window render time X ms, composition Y ms" etc. Note the time spent in "sync" vs "render" stages. Also note if it says Threaded render loop: no (which it will, since QQuickWidget disables it).  
\- Instrument UnifiedGridRenderer::updatePaintNode() with a timer as shown earlier[\[12\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=4.%20Add%20timing%20to%20,return%20node%3B) to log how many microseconds it takes. Ensure this is, say, 1-5 ms (if it's much higher, our scene building might need optimizing too).  
\- Use **Qt Quick Profiler** in Qt Creator: run a few seconds of the app, then inspect the timeline of frames. Look for "Render Thread" activity vs "GUI Thread". In QQuickWidget, you'll see all work on GUI thread; in new version, you'll see separation. This also helps spot if, for example, our GUI thread is idle while GPU busy or vice versa.  
\- Optionally, capture a frame with **RenderDoc**. This will show all GL draw calls for a frame. In QQuickWidget, you might see an extra blit or that the final output is a textured quad. This can visually confirm the extra pass.  
\- CPU profiling (with VerySleepy, perf, or Qt Creator's CPU analyzer) can also quantify how much time per frame is in QQuickWidget overhead (QWidget paint events, etc.).

**Success Criteria:** If we find >2 ms per frame in QQuickWidget overhead, we have concrete proof to stakeholders that refactoring is needed[\[5\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=For%20120%20Hz%20updates%2C%20this,compositor%29)[\[4\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=,widget%20backing%20store%20%E2%86%92%20screen). (From the prompt, we already have that evidence, but measuring ourselves removes doubt.) If, hypothetically, we found our updatePaintNode was taking 12 ms (meaning our own code is too slow), we'd have to address that as well. However, given DataProcessor <150µs and updatePaintNode <5ms are reported[\[52\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=Current%20%28QQuickWidget%29%20,~150%C2%B5s%20update%20latency%20%28GOOD)[\[53\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=,~150%C2%B5s%20update%20latency%20%28GOOD), the scenegraph code is efficient.

### Phase 1: Migrate QQuickWidget → QQuickWindow via createWindowContainer

_Goal:_ Replace the QQuickWidget with an embedded QQuickWindow, removing the FBO overhead while keeping our existing UI and QML content.

**Steps:**  
1\. **Create a QQuickWindow for the chart:** We'll write a small wrapper (e.g. ChartWindow class) that encapsulates a QQuickWindow. This window will load our QML scene (the DepthChartView.qml, which uses UnifiedGridRenderer). We can use QQmlEngine and QQmlComponent to instantiate the QML and set it as content of the QQuickWindow[\[54\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=,setColor%28Qt%3A%3Ablack). Alternatively, use QQmlApplicationEngine if we want to load an entire QML UI - but here we only want the chart part in QML, and keep the rest as QWidget. So manual component creation is fine. We'll also need to pass the existing QQmlEngine (if we have one) or create a new engine. Probably, in main we currently instantiate QQuickWidget with a QML source; that means a QQmlEngine is used under the hood. We can instantiate one QQmlEngine at app start, reuse it for creating the QQuickWindow's content (sharing an engine means QML singletons and context can be reused, which might be nice).  
Example:  

QQmlEngine \*engine = new QQmlEngine();  
QQmlComponent comp(engine, QUrl("qrc:/DepthChartView.qml"));  
QQuickWindow \*chartWindow = new QQuickWindow();  
// If DepthChartView.qml is an Item (not a Window), we have to parent it to chartWindow.  
QQuickItem \*chartItem = qobject_cast&lt;QQuickItem\*&gt;(comp.create());  
chartItem->setParentItem(chartWindow->contentItem());  
chartWindow->setTitle("ChartWindow"); // not visible but for debugging  
chartWindow->setColor(Qt::black); // background color

If our QML DepthChartView is actually a Rectangle or Item meant to be inside something, the above works. If it was a Window itself, we might instead do comp.create as a window directly; but likely it's an Item since we put it in QQuickWidget before.

- **Embed in QWidget UI:** Use QWidget::createWindowContainer(chartWindow, parentWidget). The parent widget is our MainWindow (or a placeholder QWidget in the layout). This returns a QWidget that represents the Quick window inside layouts[\[55\]\[56\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=%2F%2F%20Keep%20QWidget%20window%20for,setChartWidget%28chartContainer%29%3B). We then replace the QQuickWidget with this container widget in our UI. For instance, m_gpuChart (previously a QQuickWidget) can become a QWidget\* chartContainer. In MainWindowGPU, instead of new QQuickWidget(this) we do the above engine/component and:

- QWidget \*chartContainer = QWidget::createWindowContainer(chartWindow, this);  
    chartContainer->setFocusPolicy(Qt::StrongFocus); // forward focus  
    ui->chartLayout->addWidget(chartContainer); // or whatever layout  
    m_gpuChartContainer = chartContainer;
- We also might want to keep a pointer to UnifiedGridRenderer: after creation, we can find it via chartWindow->findChild&lt;UnifiedGridRenderer\*&gt;(); or if the QML registers it as an object. Alternatively, our ChartWindow wrapper can expose the renderer (store it when QML is created, e.g. if DepthChartView has an object name or we can connect signals). This allows the main window to connect signals like it did with QQuickWidget's root object (if any).

- **Focus and Event Handling:** One quirk: createWindowContainer handles mouse and touch events seamlessly (Qt sends them to the embedded window). Keyboard focus can be tricky; ensure the container widget gets focus when needed (we set StrongFocus above). If we have shortcuts or key events in QML, the container needs focus. We might have to call chartContainer->setFocus() at appropriate times, or tab order. Also, on macOS, embedding a foreign window might cause some composition differences - but Qt has solved a lot of those. We should test interactions like resizing, fullscreen, etc.
- **Threaded Loop Activation:** By using QQuickWindow, we automatically enable threaded render loop (provided the platform supports it - all desktop platforms do). We can confirm by checking QSG_INFO output: it should now say "threaded" active. Also, our CPU usage on the main thread should drop (since render moves to its own thread).
- **Maintain QML Controls:** If our DepthChartView QML included any Qt Quick Controls (like if the crosshair or something is a QML element or a toolbar in QML), those still work - they are inside the QQuickWindow. We just have to be aware that any **Qt Widgets** (like QPushButton in the main UI) that overlap or are on top of the chart might not overlay correctly because the chart is a separate window. QQuickWidget allowed true stacking (widgets on top of QML). createWindowContainer might have stacking issues: e.g. a tooltip that overlaps the chart area may be hidden behind the chart content, because the chart is a native window. Indeed, **native child windows always appear in front of regular widgets** (unless Qt uses some trick). This is a known limitation: you can't draw on top of a embedded native window from the host. So we should ensure any overlays (like a crosshair overlay implemented as a QWidget) is instead done in QML or in the QQuickWindow. If we have none (likely not), then we're fine. If, for example, we had a QDockWidget that overlaps the chart partially, we might see it under the chart. The solution would be to either avoid overlap or use Qt Quick for those overlays. According to Qt docs: QQuickWidget's advantage was stacking order[\[57\]](https://runebook.dev/en/articles/qt/qwidget/createWindowContainer#:~:text=,This%20is%20the%20biggest%20advantage); with createWindowContainer, that advantage is lost.
- **Testing:** After the swap, run the app. Check that the chart appears and updates correctly. Measure FPS - it should reach 120 FPS if the system can (maybe using a high-speed timer or just observing motion smoothness). Use QSG_INFO again to see frame times. We expect the "render thread" entries now. Also test interactions: mouse wheel zoom, etc., to ensure events go through.

**Expected Outcome:** ~2-4 ms reduction in frame time[\[18\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=%7C,EXCELLENT), threaded rendering enabled, and nearly all existing code reused (we didn't change UnifiedGridRenderer at all, just how it's hosted). **Migration effort**: moderate but manageable (~1 week as estimated). We preserve ~95% of our code (only MainWindow and the creation logic changed, QML and C++ rendering untouched)[\[58\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=%2A%2AMigration%20Effort%2A%2A%3A%20MEDIUM%20%281,UnifiedGridRenderer%20unchanged).

**Pitfalls to watch:** - If we see a blank or black area, possibly the QQuickWindow didn't render - ensure we call chartWindow->show() even if using container (some recommend showing the QQuickWindow in case)[\[59\]](https://runebook.dev/en/articles/qt/qwidget/createWindowContainer#:~:text=%2F%2F%201,to%20show%20the%20QWindow%20explicitly)[\[60\]](https://runebook.dev/en/articles/qt/qwidget/createWindowContainer#:~:text=openGLWindow,to%20show%20the%20QWindow%20explicitly). - On macOS, embedding windows might disable certain optimizations (like possibly not using Metal fully? But according to Qt devs, it should work). - Window resizing: by default, createWindowContainer will resize the embedded QQuickWindow to fill the widget geometry. That should be fine. We should set chartWindow->reportContentOrientationChange() if needed for HiDPI but likely okay. - **Memory:** Each QQuickWindow has its own scenegraph context. We should ensure we destroy the QQuickWidget properly to free the old context. Also, having two graphics contexts (MainWindow's backingstore GL context and QQuickWindow's context) might increase VRAM usage slightly. But that's negligible on modern hardware. - If the rest of the UI uses QOpenGLWidget or something, there could be conflicts (only one GL context type per window allowed)[\[61\]](https://doc.qt.io/qt-6/qquickwidget.html#:~:text=Note%3A%20One%20top,not%20be%20rendering%20as%20expected). But our UI seems mostly widgets and QML only in that one spot, so no conflict.

Once Phase 1 is done, Sentinel should already meet the performance goal on high-end GPU. Phase 2 will further optimize within the scenegraph and possibly consider deeper changes.

### Phase 2: Scenegraph Optimizations and Dynamic LOD

_Goal:_ Fine-tune the rendering of the 50k+ items to maintain 120 FPS under all conditions (including on integrated GPUs or when window is very large), and implement **level-of-detail** scaling for different zoom levels.

**2A. Optimize QSG Node Usage (Micro-optimizations):**  
Review UnifiedGridRenderer and strategy classes to ensure: - They reuse QSGGeometry and materials (no per-frame new/delete). If any new QSGGeometryNode appears in updatePaintNode, refactor it to persist. The StackOverflow guidance earlier should be our template[\[23\]](https://stackoverflow.com/questions/46394155/how-to-use-qsggeometrynode-without-causing-a-memory-leak-and-ensure-correct-clea#:~:text=QSGNode%20,updatePaintNodeData%29)[\[62\]](https://stackoverflow.com/questions/46394155/how-to-use-qsggeometrynode-without-causing-a-memory-leak-and-ensure-correct-clea#:~:text=%2F%2F%20if%20GetMyGeometry%20returns%20every,markDirty%28QSGNode%3A%3ADirtyGeometry%29%20because%20setGeometry%20is%20called). - Possibly pre-allocate vertex buffers to a max size. If we know worst-case 50k cells, allocate that upfront once. If actual use is often smaller, that's okay. - Ensure materials are only created once. If switching color gradients or something, consider using a uniform in a custom shader rather than making multiple materials. - Check if using QSGFlatColorMaterial anywhere for solid items - those can be shared (they are const, so one instance can be set on many nodes if same color - but we likely use per-vertex color everywhere). - Consolidate nodes if there are too many. For example, if currently we create one QSGNode per cell (hopefully not - likely we already batch), that would be bad. We want as few nodes as necessary. Possibly one per layer (heatmap vs trades vs candles). - Implement culling: If our grid extends far beyond the viewport (like user zooms in on 1 minute, but we have data for 1 hour loaded), we can avoid drawing what's off-screen. This might involve splitting the geometry at boundaries and toggling node->setVisible(false) or removing nodes that are off-screen. Or use clipNode to cut, but that still processes vertices. If needed, we could maintain a smaller subset of data for the current view. But since zooming is smooth and continuous, that might be complicated to constantly rebuild. Alternatively, rely on GPU to handle it - drawing 50k quads of which 45k are off-screen is wasted GPU work though. So some culling is beneficial. - Perhaps divide the heatmap into vertical slices (time slices) and only render those whose bounding box intersects the viewport. For each slice, you'd have a QSGNode with all its price levels. If we have 1000 time units and view only shows 100 at a time, then we cut down draws by 10x if implemented. But that's a heavy refactor. - Simpler: just restrict geometry to the view when building. This requires knowing current view's range (we do have GridViewState, so yes we know time and price bounds visible). So when populating vertices, simply skip those outside visible min/max. That way, even the big geometry node has only relevant points. This is easy and effective culling on CPU side. We should absolutely do this: do not generate vertices for cells not in the visible region. This can drastically reduce load when zoomed in. It means at extreme zoom in, we maybe draw only a few hundred cells (very fast). At zoomed out, we draw many but then maybe consider LOD as below.

**2B. Level of Detail (LOD) Implementation:**  
For time-series and price axes: - _Time-axis LOD:_ If zoomed out to show hours of data, we might aggregate multiple points in time to a single rendered point. E.g. 1 pixel could represent 10 original data points aggregated (like max or average). Our LiquidityTimeSeriesEngine might already produce aggregated series for different zoom levels. If so, we can simply choose a different data source depending on zoom. For instance, if each pixel at current zoom represents >1 second, maybe use a pre-aggregated array to draw. This can reduce the number of quads dramatically. Implementation: The DataProcessor or engine can maintain multiple arrays (like 1ms resolution, 10ms, 100ms, 1s, etc.). On zoom change, the renderer picks the appropriate one. This avoids drawing unnecessary fine detail that can't be seen. - _Price-axis LOD:_ Similarly, if the price axis is very large (say 0-100k in order book levels but screen is 1000 px high), some price levels are sub-pixel. We might not need to draw each. But order books often have continuous data - skipping might cause aliasing. A compromise is to draw a thicker line or use a shader to accumulate. But probably the vertical axis doesn't need LOD as much, since we typically always map 1 pixel ~ 1 price level when zoomed to depth. Unless we allow zoom out to see entire market depth (which is unusual).

- _Visual Aggregation technique:_ If we represent heatmap as a texture, turning on mipmapping would inherently give an aggregated look when scaled down. But generating that texture each frame is heavy (though maybe with QRhi compute it could be done). Instead, do CPU aggregation which we already have infra for.
- _Implementing LOD in code:_ We might extend GridViewState to provide a "LOD level" or scale factor. If zoom level corresponds to timeframe (like viewing 1 minute vs 1 hour of data), we know how many data points per pixel. Decide a threshold (e.g. >2 data points per pixel = aggregate). Then in updatePaintNode, instead of plotting each raw point, we bin them. Perhaps our DataProcessor can do the binning in advance, or we do quick on-the-fly binning. The data structures might need to be optimized for this (maybe storing cumulative volumes to compute sums quickly).
- _Example:_ Bookmap likely uses shaders to accumulate the volume in each pixel column (it's essentially a 2D histogram updated in real-time). But since we have CPU power and relatively moderate data, doing it on CPU is fine.
- _LOD for other layers:_ If we have bubble/trade markers, at far zoom out those might be too many to draw individually - perhaps cluster them or only show biggest. If we have candle stick overlay, at far out you might not want to draw wicks for thousands of candles - maybe draw an area chart.

All these are future enhancements; for now, a basic time aggregation would significantly help when user zooms way out. It ensures we don't try to draw 50k+ points _and_ ensures meaningful visuals (too many overlapping points can look like moiré).

**2C. Profiling After Optimizations:**  
After implementing the above, test: - Zoomed in (max detail): does it still hit 120 FPS? Likely yes, fewer points drawn. - Zoomed out (max span): ideally still 60+ FPS on iGPU. If not, see if LOD reduced geometry enough. Maybe need to increase aggregation (sacrifice some detail). - Pan/zoom interactions: ensure there's no hitch when switching LOD levels (maybe interpolate or cross-fade to avoid popping). - Monitor CPU usage on iGPU scenario - make sure the GUI thread is not maxed out when handling lots of data.

**Phase 2 Outcome:** Sentinel's rendering is robust across scenarios: **120 Hz on high-end GPU at all zooms, and >=60 Hz on iGPU by drawing fewer elements when needed.** The scenegraph code is fully optimized (no unnecessary allocations). This phase is essentially "polishing" and could take another 1-2 weeks, mostly in testing and adjusting LOD thresholds. It's lower risk because we're not changing frameworks, just tuning our algorithms.

### Phase 3: When (and If) to Consider a Custom Renderer (ImGui/Vulkan)

_This phase is optional and only considered if Qt Quick still doesn't meet requirements or other strategic reasons (e.g. licensing)._

Given the analysis, moving to a custom rendering stack (like ImGui + raw Vulkan/GL) is **a last resort**. Qt Quick, after Phase 1 and 2, should fulfill our needs: - If QQuickWindow + optimizations achieve 120 FPS on 4070 and good performance on iGPU, there's no performance reason to abandon Qt[\[63\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=%2A%2AReality%20Check%2A%2A%3A%20,copies%2C%20not%20Qt%20Quick%20itself). - Qt Quick provides cross-platform ease that a custom solution would forfeit (we'd have to implement Metal and DirectX backends ourselves or use a library like bgfx or SDL + custom). - We'd lose our entire QML-based UI and scenegraph code investment (basically rewriting ~90% of the UI code)[\[64\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=%7C%20,Manual).

**However,** for completeness, here's how to identify the threshold for going nuclear: - If after using QQuickWindow, we find that the Qt scenegraph overhead is still, say, >4ms such that we cannot hit frame targets, and profiling shows it's not our code but Qt's batching or other overhead. - If Qt has a bug or limitation (for example, perhaps Qt's D3D backend performs poorly with certain drivers, or the scenegraph can't utilize multi-core beyond one render thread). - If we require features Qt doesn't support well, like ultra-low latency input handling, custom input polling, or truly unlocked framerates beyond vsync (though Qt Quick can render without vsync if configured). - If the **licensing or deployment** is a concern: Qt is LGPL (with some Qt Quick Controls style bits GPL). If legal considerations push to remove Qt, that could force a rewrite.

In those cases, a custom solution might be considered: - **ImGui approach:** Use ImGui for all UI (it's immediate mode, skinnable to some extent, but not as pretty or flexible as Qt Widgets/QML). We'd write our own rendering of the chart using e.g. OpenGL or Vulkan directly. ImGui provides things like docking (with the docking branch), menus, etc. But styling them to look like a modern app is not trivial. Also, ImGui excels at debug tools, not necessarily end-user polished look (though it can be used for that). - **Custom Engine without ImGui:** Use something like **SDL or GLFW** for window + events, then pure OpenGL/Vulkan to draw the chart and custom UI. Essentially treat it like a game.

**Work estimate:** At least 2-3 months to get feature parity, as noted[\[65\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=%2A%2ACons%2A%2A%3A%20,months%20rewrite%20for%20feature%20parity). We'd have to reimplement every widget (text inputs, buttons, etc., either using ImGui's versions or custom).

**Performance comparison:** ImGui is very fast for UI, but for our specific use-case (lots of rectangles), Qt Quick can be just as fast. ImGui's rendering of primitives is also done via big vertex buffers and draw calls. There's no reason to believe ImGui would magically be faster than a well-optimized QSG - both end up doing the same work (pushing triangles to GPU). In fact, Qt Quick's batching is quite optimized in C++ and likely not significantly slower than ImGui's. If anything, ImGui might have less overhead because it doesn't have a meta-object or JavaScript layer (but we aren't using those heavily anyway).

**Case study:** Some users on forums ask "Qt Quick vs custom OpenGL - which is faster?" Often, Qt Quick is plenty fast for 2D if used properly[\[66\]](https://www.reddit.com/r/QtFramework/comments/17asox3/performance_difference_between_qt_quick_and_qt/#:~:text=Yes%20QtQuick%20is%20much%20much,Its%20the%20awesome). Only in extreme edge cases (tens of thousands of separate QML items, etc.) does its overhead show. In our scenario, we have one QQuickItem with a lot of geometry - which Qt Quick handles well (one of Qt's devs noted even if every frame is new, it's fine[\[39\]](https://doc.qt.io/qt-6/qtquick-visualcanvas-scenegraph-renderer.html#:~:text=graphics%20chip)). So we'd likely not gain much by ditching Qt, aside from maybe a few ms lower latency (since we could custom tailor threading and avoid any Qt abstraction cost).

**Knowing the threshold:** If after Phase 1 & 2, we _still_ cannot achieve the "must have" criteria (say integrated GPU only gets 30 FPS and that's unacceptable), and we've exhausted Qt tuning, then consider the custom route. At that point, measure how much time Qt overhead is adding. If, hypothetically, Qt overhead is 5ms/frame we can't remove, a custom engine could regain that. But it's rare - most overhead we identified is the QQuickWidget which we are removing.

We should also consider **maintenance cost**: staying with Qt means easier maintenance and leveraging Qt's improvements. A custom solution puts all burden on us for any bug (e.g., GPU driver quirk, etc.). Qt's community and patches handle a lot.

**Hybrid option:** Some suggest using Qt for non-performance-critical UI (menus, dialogs) and embedding a pure GL viewport for the chart (like mixing ImGui or custom GL in a QWidget). This is possible (like how some apps embed a game engine view in a Qt app). We effectively are doing that but using Qt Quick as the GL content. If Qt Quick didn't pan out, we could consider using e.g. QOpenGLWidget with custom rendering or using QWindow::fromWinId hacks to embed an external context. But that's essentially re-implementing what Qt Quick does.

**Conclusion on Phase 3:** At this stage, all evidence suggests **Phase 3 will not be necessary**. QQuickWindow will solve the major issues[\[63\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=%2A%2AReality%20Check%2A%2A%3A%20,copies%2C%20not%20Qt%20Quick%20itself). Qt Quick's scenegraph is quite capable of 240 Hz for simple scenes[\[67\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=%2A%2AReality%20Check%2A%2A%3A%20,copies%2C%20not%20Qt%20Quick%20itself), so 120 Hz with our relatively moderate scene complexity is fine. We include this phase only as a contingency plan if something unforeseen emerges. Otherwise, we stick to Qt.

## When to Abandon Qt Quick (Signs and Considerations)

To directly address deliverable 10: **When might we abandon Qt/Qt Quick for a custom path?**

- If **target FPS > refresh rate** or specialized timing: For example, if we wanted 1000 Hz offscreen rendering or custom frame pacing for VR, Qt Quick might not allow that easily (it syncs to display). For typical trading UI, this is not needed.
- If **latency needs to be absolutely minimal**: Qt Quick introduces maybe one frame of latency due to its threaded pipeline (double-buffering). If we needed "streaming" where every microsecond counts, a custom renderer that locks step with data could shave off some ms. However, in trading, 8ms vs 4ms latency is usually irrelevant compared to network latency. And if truly needed, one would be in a purely server-side environment or specialized hardware.
- If **memory overhead or binary size** of Qt is an issue: Qt Quick does bring some overhead (QtGui, QtQml libs, etc.). If deploying to a platform where that's an issue (embedded device with tight memory), a custom solution could be leaner. But on trading desktops, not an issue.
- If **Qt's future or licensing**: If Qt were to change licensing such that using Qt Quick in a closed-source app is costly (it's LGPL, which is fine as long as we comply), or if we want to avoid LGPL (maybe static linking concerns), then switching to an all-custom (maybe using MIT licensed libraries) could be considered.
- If we find a _specific limitation_ in Qt Quick, like inability to render certain visual effects we need (though Qt Quick is flexible, can always drop to shader code if needed).

In short, we'd abandon Qt only if **performance was insufficient after all optimizations or non-technical reasons forced it.** Right now, neither is the case.

Should that time come, the plan would be: - Evaluate **bgfx** or **SDL + Vulkan** as foundation to avoid writing everything from scratch (bgfx is a library that abstracts rendering on multiple backends, somewhat like QRhi but for games). - Use **ImGui** for all UI or write custom minimal UI (maybe just avoid complex UI, or embed a browser for settings etc.). - The chart rendering itself we have algorithms for - we'd implement them in GL calls: upload vertex buffers, etc. Actually, much of our updatePaintNode logic would port to constructing GPU buffers manually. We could reuse that logic in a new render loop.

But again, this is a path of much greater resistance. The only scenario I see is if we wanted to open-source without Qt (to avoid license) or extremely fine-tune beyond Qt's design.

**Therefore, the recommendation is to stick with Qt Quick, complete Phase 1 and 2, and not pursue a complete rewrite unless evidence overwhelmingly shows Qt Quick cannot hit performance targets (which is unlikely).** In the end, **Qt Quick with QQuickWindow will give us near-native GPU performance with far less effort than building our own engine**[**\[3\]**](https://forum.qt.io/topic/55762/performance-of-qquickwidget#:~:text=,performance%20when%20compared%20to%20QQuickWidget).

## Conclusion (TL;DR Action Plan)

**Issue:** QQuickWidget causes ~2-4 ms extra rendering overhead per frame[\[68\]](https://doc.qt.io/qt-6/qquickwidget.html#:~:text=,animations%2C%20will%20not%20be%20available), blocking 120 FPS performance. It also forces single-threaded rendering[\[2\]](https://doc.qt.io/qt-6/qquickwidget.html#:~:text=especially%20for%20the%20fragment%20processing,animations%2C%20will%20not%20be%20available).

**Solution:** Refactor the UI to use a **QQuickWindow** (or QQuickView) for the chart instead of QQuickWidget, embedding it via QWidget::createWindowContainer. This removes the offscreen FBO step and enables Qt Quick's threaded scenegraph, cutting frame overhead by 2-4 ms and allowing full GPU utilization[\[5\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=For%20120%20Hz%20updates%2C%20this,compositor%29)[\[18\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=%7C,EXCELLENT).

**Steps Summary:**  
\- **Phase 0:** Profile current setup with QSG_INFO and instrumented timing. Confirm that our scene build is efficient (<5 ms) and the extra overhead is in QQuickWidget (which it is)[\[5\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=For%20120%20Hz%20updates%2C%20this,compositor%29).  
\- **Phase 1:** Implement QQuickWindow for the chart QML content and embed in our QWidget app via createWindowContainer[\[55\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=%2F%2F%20Keep%20QWidget%20window%20for,setChartWidget%28chartContainer%29%3B). Keep all Qt Widgets for controls, just swap the chart area. Ensure focus and input work properly. Result: ~50-100% frame rate increase (depending on how much overhead was removed), achieving 120 Hz on capable hardware.  
\- **Phase 2:** Optimize the scenegraph usage: reuse QSGNodes and QSGGeometry (no per-frame allocation)[\[24\]](https://stackoverflow.com/questions/46394155/how-to-use-qsggeometrynode-without-causing-a-memory-leak-and-ensure-correct-clea#:~:text=Second%20question%3A%20Is%20this%20a,good%20way), update vertex data in place and mark dirty[\[62\]](https://stackoverflow.com/questions/46394155/how-to-use-qsggeometrynode-without-causing-a-memory-leak-and-ensure-correct-clea#:~:text=%2F%2F%20if%20GetMyGeometry%20returns%20every,markDirty%28QSGNode%3A%3ADirtyGeometry%29%20because%20setGeometry%20is%20called). Implement basic **LOD**: skip drawing data points that are too fine to see at far zoom (aggregate them instead), and avoid generating geometry outside the visible range. This keeps frame times low even when zoomed way out or on lower-end GPUs.  
\- **Phase 2 (cont'd):** Fine-tune throttling: ensure at most one update is processed per frame. Use lock-free queue or smart signal handling so that bursts of updates coalesce into one rendering. Maintain visual smoothness by updating at ~120 Hz (or display refresh). The GUI thread should never be bogged down by a backlog of update events.  
\- **Test cross-platform:** Verify on Windows (D3D11), macOS (Metal), Linux (OpenGL/Vulkan) that performance is consistent. Use QQuickWindow::setGraphicsApi() if needed to work around any backend-specific issues (e.g. force OpenGL if a bug in Metal, etc.). QRhi abstracts most differences[\[10\]](https://doc.qt.io/qt-6/qquickwidget.html#:~:text=QQuickWidget%20is%20functional%20with%20all,QQuickWidget%20will%20lead%20to%20problems)[\[48\]](https://doc.qt.io/qt-6/qrhi.html#:~:text=The%20Qt%20Rendering%20Hardware%20Interface,ES%2C%20Direct3D%2C%20Metal%2C%20and%20Vulkan), so our code doesn't change per platform.  
\- **Monitor performance metrics:** After changes, our target is <8.3 ms/frame on high-end GPU (ideally ~5-6 ms to have headroom)[\[18\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=%7C,EXCELLENT), and <16.6 ms on iGPU. Use Qt Creator's profiler and GPU vendor tools to ensure we hit these. If not, iterate (e.g. further LOD, shader tuning).  
\- **Maintainability:** Keep 95% of existing code - **do not rewrite** what already works. The refactor is mostly at the "container" level (widget vs window)[\[58\]](file://file_00000000181861f5ae74aa40ba2ef28d#:~:text=%2A%2AMigration%20Effort%2A%2A%3A%20MEDIUM%20%281,UnifiedGridRenderer%20unchanged) and minor tweaks to rendering strategies (no design overhaul). This limits risk.

By following this plan, Sentinel's rendering pipeline will be significantly more efficient and scalable. We leverage Qt Quick's strengths (GPU acceleration, cross-platform via QRhi, easy UI integration) without its previous bottleneck. The end result: **a high-frequency trading terminal that achieves buttery-smooth 120 FPS updates and is future-proof for higher DPI and refresh displays, all while retaining the productivity of Qt's framework.**

**Final TL;DR:** Switch from QQuickWidget to QQuickWindow to remove FBO overhead[\[1\]](https://doc.qt.io/qt-6/qquickwidget.html#:~:text=,animations%2C%20will%20not%20be%20available), reuse scenegraph nodes & use Qt's threaded render loop[\[2\]](https://doc.qt.io/qt-6/qquickwidget.html#:~:text=especially%20for%20the%20fragment%20processing,animations%2C%20will%20not%20be%20available) for parallelism, throttle update frequency to vsync, and apply level-of-detail so we draw only what's needed. This preserves almost all existing code but supercharges performance - hitting 120 Hz on a discrete GPU and 60 Hz on integrated graphics is absolutely attainable with these changes. Qt Quick's rendering is highly optimized when used correctly, so we focus on "using it correctly" by eliminating the one misuse (QQuickWidget in a high-FPS scenario) and optimizing our usage patterns.

With these adjustments, Sentinel will meet its performance goals and provide a smooth, real-time visualization experience comparable to the best in the industry, without resorting to a ground-up custom engine.