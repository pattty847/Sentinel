// ======= libs/gui/UnifiedGridRenderer.cpp =======
#include "UnifiedGridRenderer.h"
#include "SentinelLogging.hpp"
#include <QSGGeometry>
#include <QSGFlatColorMaterial>
#include <QSGVertexColorMaterial>
#include <QDateTime>
#include <algorithm>
#include <cmath>

UnifiedGridRenderer::UnifiedGridRenderer(QQuickItem* parent)
    : QQuickItem(parent)
    , m_liquidityEngine(std::make_unique<LiquidityTimeSeriesEngine>(this))
    , m_rootTransformNode(nullptr)
    , m_needsDataRefresh(false)
{
    setFlag(ItemHasContents, true);
    setAcceptedMouseButtons(Qt::LeftButton | Qt::RightButton);
    setFlag(ItemAcceptsInputMethod, true);
    
    // üêõ FIX: Only accept mouse events on empty areas, not over UI controls
    setAcceptHoverEvents(false);  // Reduce event capture
    
    // Initialize geometry cache
    m_geometryCache.isValid = false;
    m_geometryCache.node = nullptr;
    
    // Setup 100ms order book polling timer for consistent updates
    m_orderBookTimer = new QTimer(this);
    connect(m_orderBookTimer, &QTimer::timeout, this, &UnifiedGridRenderer::captureOrderBookSnapshot);
    m_orderBookTimer->start(100);  // 100ms base resolution
    
    sLog_Init("üéØ UnifiedGridRenderer: Initialized with LiquidityTimeSeriesEngine");
    sLog_Init("üìä Configuration: 100ms order book snapshots for smooth rendering");
    sLog_Init("‚ö° Ready for real-time liquidity data with proper timing");
}

void UnifiedGridRenderer::onTradeReceived(const Trade& trade) {
    if (trade.product_id.empty()) return;
    
    auto timestamp = std::chrono::duration_cast<std::chrono::milliseconds>(
        trade.timestamp.time_since_epoch()).count();
    
    {
        std::lock_guard<std::mutex> lock(m_dataMutex);
        
        // Initialize viewport from first trade if needed
        if (!m_timeWindowValid) {
            m_visibleTimeStart_ms = timestamp - 30000;  // 30 seconds ago
            m_visibleTimeEnd_ms = timestamp + 30000;    // 30 seconds ahead
            m_minPrice = trade.price - 100.0;
            m_maxPrice = trade.price + 100.0;
            m_timeWindowValid = true;
            
            sLog_Init("üéØ UNIFIED RENDERER VIEWPORT INITIALIZED:");
            sLog_Init("   Time: " << m_visibleTimeStart_ms << " - " << m_visibleTimeEnd_ms);
            sLog_Init("   Price: $" << m_minPrice << " - $" << m_maxPrice);
            sLog_Init("   Based on real trade: $" << trade.price << " at " << timestamp);
        }
        
        // üöÄ SIMPLE: No cache system, always update on new data
        sLog_Render("üìä TRADE UPDATE: Triggering geometry update");
    }
    
    m_geometryDirty.store(true);
    update();
    
    // Debug logging for first few trades
    static int realTradeCount = 0;
    if (++realTradeCount <= 10) {
        sLog_Trades("üéØ UNIFIED RENDERER TRADE #" << realTradeCount << ": $" << trade.price 
                 << " vol:" << trade.size 
                 << " timestamp:" << timestamp);
    }
}

void UnifiedGridRenderer::onOrderBookUpdated(const OrderBook& book) {
    if (book.product_id.empty() || book.bids.empty() || book.asks.empty()) return;
    
    {
        std::lock_guard<std::mutex> lock(m_dataMutex);
        
        // Store latest order book for snapshots
        m_latestOrderBook = book;
        m_hasValidOrderBook = true;
        
        // Initialize viewport from order book if needed
        if (!m_timeWindowValid) {
            double bestBid = book.bids[0].price;
            double bestAsk = book.asks[0].price;
            double midPrice = (bestBid + bestAsk) / 2.0;
            
            auto now = std::chrono::duration_cast<std::chrono::milliseconds>(
                std::chrono::system_clock::now().time_since_epoch()).count();
            
            m_visibleTimeStart_ms = now - 30000;  // 30 seconds ago
            m_visibleTimeEnd_ms = now + 30000;    // 30 seconds ahead
            m_minPrice = midPrice - 100.0;
            m_maxPrice = midPrice + 100.0;
            m_timeWindowValid = true;
            
            sLog_Init("üéØ UNIFIED RENDERER VIEWPORT FROM ORDER BOOK:");
            sLog_Init("   Mid Price: $" << midPrice);
            sLog_Init("   Price Window: $" << m_minPrice << " - $" << m_maxPrice);
        }
    }
    
    // Debug logging for first few order books
    static int orderBookCount = 0;
    if (++orderBookCount <= 10) {
        sLog_Network("üéØ UNIFIED RENDERER ORDER BOOK #" << orderBookCount 
                 << " Bids:" << book.bids.size() << " Asks:" << book.asks.size());
    }
}

void UnifiedGridRenderer::onViewChanged(qint64 startTimeMs, qint64 endTimeMs, 
                                       double minPrice, double maxPrice) {
    {
        std::lock_guard<std::mutex> lock(m_dataMutex);
        
        m_visibleTimeStart_ms = startTimeMs;
        m_visibleTimeEnd_ms = endTimeMs;
        m_minPrice = minPrice;
        m_maxPrice = maxPrice;
        m_timeWindowValid = true;
        
        // üöÄ SIMPLE: Always update on viewport changes
        sLog_DebugCoords("üéØ VIEWPORT CHANGED: Will rebuild geometry on next paint");
    }
    
    m_geometryDirty.store(true);
    update();
    
    // Debug logging for viewport changes
    static int viewportChangeCount = 0;
    if (++viewportChangeCount <= 5) {
        sLog_DebugCoords("üéØ UNIFIED RENDERER VIEWPORT #" << viewportChangeCount 
                      << " Time:[" << startTimeMs << "-" << endTimeMs << "]"
                      << " Price:[$" << minPrice << "-$" << maxPrice << "]");
    }
}

void UnifiedGridRenderer::captureOrderBookSnapshot() {
    if (!m_hasValidOrderBook) return;
    
    // Store previous order book hash to detect changes
    static size_t lastOrderBookHash = 0;
    
    {
        std::lock_guard<std::mutex> lock(m_dataMutex);
        
        // Calculate simple hash of current order book state
        size_t currentHash = 0;
        for (const auto& bid : m_latestOrderBook.bids) {
            currentHash ^= std::hash<double>{}(bid.price) ^ std::hash<double>{}(bid.size);
        }
        for (const auto& ask : m_latestOrderBook.asks) {
            currentHash ^= std::hash<double>{}(ask.price) ^ std::hash<double>{}(ask.size);
        }
        
        // Only update if order book actually changed
        if (currentHash != lastOrderBookHash) {
            // Pass latest order book to liquidity engine for 100ms snapshots WITH VIEWPORT FILTERING
            if (m_timeWindowValid) {
                m_liquidityEngine->addOrderBookSnapshot(m_latestOrderBook, m_minPrice, m_maxPrice);
            } else {
                // Fallback to unfiltered if viewport not yet initialized
                m_liquidityEngine->addOrderBookSnapshot(m_latestOrderBook);
            }
            lastOrderBookHash = currentHash;
            sLog_Render("üìä ORDER BOOK CHANGED: Triggering geometry update");
            
            m_geometryDirty.store(true);
            update();
        } else {
            // Skip update - no changes detected
            static int skipCount = 0;
            if (++skipCount % 100 == 1) {
                sLog_Render("üìä ORDER BOOK UNCHANGED: Skipped " << skipCount << " redundant updates");
            }
        }
    }
}

void UnifiedGridRenderer::geometryChanged(const QRectF &newGeometry, const QRectF &oldGeometry) {
    if (newGeometry.size() != oldGeometry.size()) {
        sLog_Render("üéØ UNIFIED RENDERER GEOMETRY CHANGED: " << newGeometry.width() << "x" << newGeometry.height());
        
        // Force redraw with new geometry
        m_geometryDirty.store(true);
        update();
    }
}

QSGNode* UnifiedGridRenderer::updatePaintNode(QSGNode* oldNode, UpdatePaintNodeData*) {
    // üìä PERFORMANCE MONITORING: Start frame timing
    QElapsedTimer frameTimer;
    frameTimer.start();
    
    // Update frame time history (keep last 60 frames)
    if (m_perfMetrics.frameTimes.size() >= 60) {
        m_perfMetrics.frameTimes.erase(m_perfMetrics.frameTimes.begin());
    }
    if (m_perfMetrics.lastFrameTime_us > 0) {
        m_perfMetrics.frameTimes.push_back(frameTimer.nsecsElapsed() / 1000 - m_perfMetrics.lastFrameTime_us);
    }
    
    // üîç DEBUG: Log the first 10 paint calls
    static int paintCallCount = 0;
    if (++paintCallCount <= 10) {
        sLog_Render("üîç UNIFIED GRID PAINT #" << paintCallCount 
                 << " size=" << width() << "x" << height() 
                 << " visible=" << (isVisible() ? "YES" : "NO")
                 << " geometryDirty=" << (m_geometryDirty.load() ? "YES" : "NO")
                 << " FPS=" << m_perfMetrics.getCurrentFPS());
    }
    
    if (width() <= 0 || height() <= 0) {
        return oldNode;
    }
    
    // üöÄ PERFORMANCE OPTIMIZATION: Use persistent geometry cache + transforms
    auto* rootNode = static_cast<QSGTransformNode*>(oldNode);
    if (!rootNode) {
        rootNode = new QSGTransformNode();
        m_rootTransformNode = rootNode;
    }
    
    {
        std::lock_guard<std::mutex> lock(m_dataMutex);
        
        // üöÄ OPTIMIZED APPROACH: Use cache when possible, rebuild only when needed
        bool needsRebuild = m_geometryDirty.load();
        
        if (needsRebuild) {
            // Clear previous children only when rebuilding
            rootNode->removeAllChildNodes();
            
            // Update visible cell data
            updateVisibleCells();
        }
        
        // Create appropriate rendering nodes based on mode
        QSGNode* mainNode = nullptr;
        
        if (needsRebuild) {
            switch (m_renderMode) {
                case RenderMode::LiquidityHeatmap:
                    mainNode = createHeatmapNode(m_visibleCells);
                    break;
                    
                case RenderMode::TradeFlow:
                    mainNode = createTradeFlowNode(m_visibleCells);
                    break;
                    
                case RenderMode::VolumeCandles:
                    mainNode = createCandleNode(m_visibleCells);
                    break;
                    
                case RenderMode::OrderBookDepth:
                    mainNode = createHeatmapNode(m_visibleCells); // Similar to heatmap
                    break;
            }
            
            if (mainNode) {
                rootNode->appendChildNode(mainNode);
            }
            
            sLog_Render("üéØ OPTIMIZED RENDER: " << m_visibleCells.size() << " cells rendered (rebuild)");
            
            // Add volume profile if enabled (TODO: could also be cached)
            if (m_showVolumeProfile) {
                updateVolumeProfile();
                QSGNode* profileNode = createVolumeProfileNode(m_volumeProfile);
                if (profileNode) {
                    rootNode->appendChildNode(profileNode);
                }
            }
        } else {
            sLog_Render("üéØ OPTIMIZED RENDER: Using cached geometry (no rebuild needed)");
        }
    }
    
    m_geometryDirty.store(false);
    
    // üìä PERFORMANCE MONITORING: End frame timing
    m_perfMetrics.renderTime_us = frameTimer.nsecsElapsed() / 1000;
    m_perfMetrics.lastFrameTime_us = frameTimer.nsecsElapsed() / 1000;
    
    // Log performance summary every 100 frames
    static int frameCount = 0;
    if (++frameCount % 100 == 0) {
        sLog_Performance("üìä PERF SUMMARY (100 frames): FPS=" << m_perfMetrics.getCurrentFPS() 
                      << " AvgRender=" << m_perfMetrics.getAverageRenderTime_ms() << "ms"
                      << " CacheHitRate=" << m_perfMetrics.getCacheHitRate() << "%"
                      << " CachedCells=" << m_perfMetrics.cachedCellCount);
    }
    
    sLog_Render("üéØ UNIFIED GRID RENDER COMPLETE (" << m_perfMetrics.renderTime_us / 1000.0 << "ms)");
    
    return rootNode;
}

void UnifiedGridRenderer::updateVisibleCells() {
    m_visibleCells.clear();
    
    if (!m_timeWindowValid) return;
    
    int64_t activeTimeframe = m_currentTimeframe_ms;
    
    // üöÄ OPTIMIZATION 1: Use manual timeframe if set, otherwise auto-suggest
    if (!m_manualTimeframeSet || 
        (m_manualTimeframeTimer.isValid() && m_manualTimeframeTimer.elapsed() > 10000)) {  // 10 second timeout
        
        // Auto-suggest timeframe when no manual override
        int64_t optimalTimeframe = m_liquidityEngine->suggestTimeframe(
            m_visibleTimeStart_ms, m_visibleTimeEnd_ms, width() > 0 ? static_cast<int>(width() / 4) : 2000);
        
        if (optimalTimeframe != m_currentTimeframe_ms) {
            m_currentTimeframe_ms = optimalTimeframe;
            activeTimeframe = optimalTimeframe;
            emit timeframeChanged();
            
            sLog_Render("üîÑ AUTO-TIMEFRAME UPDATE: " << optimalTimeframe << "ms (viewport-optimized)");
        }
    } else {
        sLog_Render("üéØ MANUAL TIMEFRAME: Using " << m_currentTimeframe_ms << "ms (user-selected)");
    }
    
    // Get liquidity slices for active timeframe within viewport
    auto visibleSlices = m_liquidityEngine->getVisibleSlices(
        activeTimeframe, m_visibleTimeStart_ms, m_visibleTimeEnd_ms);
    
    for (const auto* slice : visibleSlices) {
        createCellsFromLiquiditySlice(*slice);
    }
    
    // Debug logging for cell coverage
    static int coverageCount = 0;
    if (++coverageCount <= 5) {
        sLog_Render("üéØ UNIFIED RENDERER COVERAGE #" << coverageCount
                 << " Slices:" << visibleSlices.size()
                 << " TotalCells:" << m_visibleCells.size()
                 << " ActiveTimeframe:" << activeTimeframe << "ms"
                 << " (Manual:" << (m_manualTimeframeSet ? "YES" : "NO") << ")");
    }
}

void UnifiedGridRenderer::updateVolumeProfile() {
    // TODO: Implement volume profile from liquidity time series
    m_volumeProfile.clear();
    
    // For now, create a simple placeholder
    // In a full implementation, this would aggregate volume across time slices
}

void UnifiedGridRenderer::createCellsFromLiquiditySlice(const LiquidityTimeSlice& slice) {
    // Create cells for each price level with liquidity
    for (const auto& [price, metrics] : slice.bidMetrics) {
        double displayValue = slice.getDisplayValue(price, true, 0);  // Use Average mode
        if (displayValue > 0.0) {
            createLiquidityCell(slice, price, displayValue, true);
        }
    }
    
    for (const auto& [price, metrics] : slice.askMetrics) {
        double displayValue = slice.getDisplayValue(price, false, 0);  // Use Average mode
        if (displayValue > 0.0) {
            createLiquidityCell(slice, price, displayValue, false);
        }
    }
}

void UnifiedGridRenderer::createLiquidityCell(const LiquidityTimeSlice& slice, double price, 
                                            double liquidity, bool isBid) {
    if (price < m_minPrice || price > m_maxPrice) return;
    
    CellInstance cell;
    cell.screenRect = timeSliceToScreenRect(slice, price);
    cell.liquidity = liquidity;
    cell.isBid = isBid;
    cell.intensity = calculateIntensity(liquidity);
    cell.color = calculateHeatmapColor(liquidity, isBid, cell.intensity);
    cell.timeSlot = slice.startTime_ms;
    cell.priceLevel = price;
    
    // üöÄ OPTIMIZATION 2: Viewport culling like a videogame (AABB check)
    if (cell.screenRect.right() < 0 || cell.screenRect.left() > width() ||
        cell.screenRect.bottom() < 0 || cell.screenRect.top() > height()) {
        return; // Culled - completely off-screen
    }
    
    // Only add cells with valid screen rectangles
    if (cell.screenRect.width() > 0.1 && cell.screenRect.height() > 0.1) {
        m_visibleCells.push_back(cell);
    }
}

QRectF UnifiedGridRenderer::timeSliceToScreenRect(const LiquidityTimeSlice& slice, double price) const {
    if (!m_timeWindowValid) return QRectF();
    
    // Calculate time position
    double timeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
    double leftRatio = (slice.startTime_ms - m_visibleTimeStart_ms) / timeRange;
    double rightRatio = (slice.endTime_ms - m_visibleTimeStart_ms) / timeRange;
    
    // Calculate price position (inverted Y axis)
    double priceRange = m_maxPrice - m_minPrice;
    double priceResolution = 1.0;  // $1 price buckets
    double topRatio = 1.0 - (price + priceResolution/2.0 - m_minPrice) / priceRange;
    double bottomRatio = 1.0 - (price - priceResolution/2.0 - m_minPrice) / priceRange;
    
    QRectF rect;
    rect.setLeft(leftRatio * width());
    rect.setRight(rightRatio * width());
    rect.setTop(topRatio * height());
    rect.setBottom(bottomRatio * height());
    
    return rect;
}

QSGNode* UnifiedGridRenderer::createHeatmapNode(const std::vector<CellInstance>& cells) {
    if (cells.empty()) return nullptr;
    
    auto* node = new QSGGeometryNode();
    
    // Create geometry for quads (6 vertices per cell)
    int vertexCount = cells.size() * 6;
    QSGGeometry* geometry = new QSGGeometry(QSGGeometry::defaultAttributes_ColoredPoint2D(), vertexCount);
    geometry->setDrawingMode(QSGGeometry::DrawTriangles);
    
    auto* vertices = geometry->vertexDataAsColoredPoint2D();
    
    for (size_t i = 0; i < cells.size(); ++i) {
        const auto& cell = cells[i];
        const QRectF& rect = cell.screenRect;
        
        // Convert color to vertex format
        uchar r = static_cast<uchar>(cell.color.red());
        uchar g = static_cast<uchar>(cell.color.green());
        uchar b = static_cast<uchar>(cell.color.blue());
        uchar a = static_cast<uchar>(cell.color.alpha());
        
        size_t baseIdx = i * 6;
        
        // Two triangles forming a quad
        // Triangle 1: top-left, top-right, bottom-left
        vertices[baseIdx + 0].set(rect.left(), rect.top(), r, g, b, a);
        vertices[baseIdx + 1].set(rect.right(), rect.top(), r, g, b, a);
        vertices[baseIdx + 2].set(rect.left(), rect.bottom(), r, g, b, a);
        
        // Triangle 2: top-right, bottom-right, bottom-left
        vertices[baseIdx + 3].set(rect.right(), rect.top(), r, g, b, a);
        vertices[baseIdx + 4].set(rect.right(), rect.bottom(), r, g, b, a);
        vertices[baseIdx + 5].set(rect.left(), rect.bottom(), r, g, b, a);
    }
    
    node->setGeometry(geometry);
    node->setFlag(QSGNode::OwnsGeometry);
    
    // Use vertex color material for per-vertex colors
    auto* material = new QSGVertexColorMaterial();
    material->setFlag(QSGMaterial::Blending);
    node->setMaterial(material);
    node->setFlag(QSGNode::OwnsMaterial);
    
    // Track bandwidth usage
    m_bytesUploadedThisFrame += vertexCount * sizeof(QSGGeometry::ColoredPoint2D);
    
    return node;
}

QSGNode* UnifiedGridRenderer::createTradeFlowNode(const std::vector<CellInstance>& cells) {
    if (cells.empty()) return nullptr;
    
    auto* node = new QSGGeometryNode();
    
    // Create geometry for circles (similar to trade dots but grid-based)
    int vertexCount = cells.size() * 6; // 6 vertices per circle (2 triangles)
    QSGGeometry* geometry = new QSGGeometry(QSGGeometry::defaultAttributes_ColoredPoint2D(), vertexCount);
    geometry->setDrawingMode(QSGGeometry::DrawTriangles);
    
    auto* vertices = geometry->vertexDataAsColoredPoint2D();
    
    for (size_t i = 0; i < cells.size(); ++i) {
        const auto& cell = cells[i];
        const QRectF& rect = cell.screenRect;
        
        // Convert color to vertex format
        uchar r = static_cast<uchar>(cell.color.red());
        uchar g = static_cast<uchar>(cell.color.green());
        uchar b = static_cast<uchar>(cell.color.blue());
        uchar a = static_cast<uchar>(cell.color.alpha());
        
        // Calculate circle radius based on volume
        float radius = std::max(2.0f, static_cast<float>(cell.intensity * 10.0f));
        QPointF center(rect.center());
        
        size_t baseIdx = i * 6;
        
        // Create a simple circle approximation with 2 triangles
        // Triangle 1: center, top-left, top-right
        vertices[baseIdx + 0].set(center.x(), center.y(), r, g, b, a);
        vertices[baseIdx + 1].set(center.x() - radius, center.y() - radius, r, g, b, a);
        vertices[baseIdx + 2].set(center.x() + radius, center.y() - radius, r, g, b, a);
        
        // Triangle 2: center, bottom-left, bottom-right
        vertices[baseIdx + 3].set(center.x(), center.y(), r, g, b, a);
        vertices[baseIdx + 4].set(center.x() - radius, center.y() + radius, r, g, b, a);
        vertices[baseIdx + 5].set(center.x() + radius, center.y() + radius, r, g, b, a);
    }
    
    node->setGeometry(geometry);
    node->setFlag(QSGNode::OwnsGeometry);
    
    // Use vertex color material for per-vertex colors
    auto* material = new QSGVertexColorMaterial();
    material->setFlag(QSGMaterial::Blending);
    node->setMaterial(material);
    node->setFlag(QSGNode::OwnsMaterial);
    
    // Track bandwidth usage
    m_bytesUploadedThisFrame += vertexCount * sizeof(QSGGeometry::ColoredPoint2D);
    
    return node;
}

QSGNode* UnifiedGridRenderer::createCandleNode(const std::vector<CellInstance>& cells) {
    if (cells.empty()) return nullptr;
    
    auto* node = new QSGGeometryNode();
    
    // Create simple volume bars instead of OHLC candles
    int vertexCount = cells.size() * 6; // 6 vertices per bar (2 triangles)
    QSGGeometry* geometry = new QSGGeometry(QSGGeometry::defaultAttributes_ColoredPoint2D(), vertexCount);
    geometry->setDrawingMode(QSGGeometry::DrawTriangles);
    
    auto* vertices = geometry->vertexDataAsColoredPoint2D();
    
    for (size_t i = 0; i < cells.size(); ++i) {
        const auto& cell = cells[i];
        const QRectF& rect = cell.screenRect;
        
        // Convert color to vertex format
        uchar r = static_cast<uchar>(cell.color.red());
        uchar g = static_cast<uchar>(cell.color.green());
        uchar b = static_cast<uchar>(cell.color.blue());
        uchar a = static_cast<uchar>(cell.color.alpha());
        
        // Create a simple volume bar
        float barWidth = static_cast<float>(rect.width() * 0.8); // 80% of cell width
        float barHeight = static_cast<float>(rect.height() * cell.intensity);
        float left = rect.center().x() - barWidth / 2;
        float right = rect.center().x() + barWidth / 2;
        float top = rect.center().y() - barHeight / 2;
        float bottom = rect.center().y() + barHeight / 2;
        
        size_t baseIdx = i * 6;
        
        // Bar quad (2 triangles = 6 vertices)
        vertices[baseIdx + 0].set(left, bottom, r, g, b, a);
        vertices[baseIdx + 1].set(right, bottom, r, g, b, a);
        vertices[baseIdx + 2].set(right, top, r, g, b, a);
        vertices[baseIdx + 3].set(right, top, r, g, b, a);
        vertices[baseIdx + 4].set(left, top, r, g, b, a);
        vertices[baseIdx + 5].set(left, bottom, r, g, b, a);
    }
    
    node->setGeometry(geometry);
    node->setFlag(QSGNode::OwnsGeometry);
    
    auto* material = new QSGVertexColorMaterial();
    node->setMaterial(material);
    node->setFlag(QSGNode::OwnsMaterial);
    
    m_bytesUploadedThisFrame += vertexCount * sizeof(QSGGeometry::ColoredPoint2D);
    
    return node;
}

QSGNode* UnifiedGridRenderer::createVolumeProfileNode(const std::vector<std::pair<double, double>>& profile) {
    if (profile.empty()) return nullptr;
    
    auto* node = new QSGGeometryNode();
    
    // Create horizontal bars for volume profile
    int vertexCount = profile.size() * 6; // 6 vertices per bar
    QSGGeometry* geometry = new QSGGeometry(QSGGeometry::defaultAttributes_ColoredPoint2D(), vertexCount);
    geometry->setDrawingMode(QSGGeometry::DrawTriangles);
    
    auto* vertices = geometry->vertexDataAsColoredPoint2D();
    
    // Find max volume for scaling
    double maxVolume = 0.0;
    for (const auto& [price, volume] : profile) {
        maxVolume = std::max(maxVolume, volume);
    }
    
    if (maxVolume <= 0) return nullptr;
    
    double maxBarWidth = width() * 0.2; // Max 20% of screen width
    
    for (size_t i = 0; i < profile.size(); ++i) {
        const auto& [price, volume] = profile[i];
        
        // Map price to screen Y coordinate
        double priceRange = m_maxPrice - m_minPrice;
        double priceRatio = (price - m_minPrice) / priceRange;
        float y = static_cast<float>((1.0 - priceRatio) * height());
        
        // Calculate bar dimensions
        float barHeight = static_cast<float>(height() / profile.size());
        float barWidth = static_cast<float>((volume / maxVolume) * maxBarWidth);
        
        float left = width() - barWidth;
        float right = width();
        float top = y - barHeight / 2;
        float bottom = y + barHeight / 2;
        
        // Volume profile color (semi-transparent white)
        uchar r = 255, g = 255, b = 255, a = 128;
        
        size_t baseIdx = i * 6;
        
        // Bar quad
        vertices[baseIdx + 0].set(left, bottom, r, g, b, a);
        vertices[baseIdx + 1].set(right, bottom, r, g, b, a);
        vertices[baseIdx + 2].set(right, top, r, g, b, a);
        vertices[baseIdx + 3].set(right, top, r, g, b, a);
        vertices[baseIdx + 4].set(left, top, r, g, b, a);
        vertices[baseIdx + 5].set(left, bottom, r, g, b, a);
    }
    
    node->setGeometry(geometry);
    node->setFlag(QSGNode::OwnsGeometry);
    
    auto* material = new QSGVertexColorMaterial();
    material->setFlag(QSGMaterial::Blending);
    node->setMaterial(material);
    node->setFlag(QSGNode::OwnsMaterial);
    
    return node;
}

// Color calculation methods
QColor UnifiedGridRenderer::calculateHeatmapColor(double liquidity, bool isBid, double intensity) const {
    intensity = std::min(intensity * m_intensityScale, 1.0);
    
    float r, g, b;
    
    if (isBid) {
        // Bid liquidity - Green scale
        r = 0.0f;
        g = 0.3f + intensity * 0.7f;
        b = 0.0f;
    } else {
        // Ask liquidity - Red scale
        r = 0.3f + intensity * 0.7f;
        g = 0.0f;
        b = 0.0f;
    }
    
    // Alpha scales with intensity
    float alpha = 0.1f + intensity * 0.8f;
    
    return QColor::fromRgbF(r, g, b, alpha);
}

QColor UnifiedGridRenderer::calculateTradeFlowColor(double liquidity, bool isBid, double intensity) const {
    intensity = std::min(intensity * m_intensityScale, 1.0);
    
    if (isBid) {
        // Bid-heavy: Green
        return QColor::fromRgbF(0.0f, 0.8f, 0.0f, 0.6f + intensity * 0.4f);
    } else {
        // Ask-heavy: Red
        return QColor::fromRgbF(0.8f, 0.0f, 0.0f, 0.6f + intensity * 0.4f);
    }
}

QColor UnifiedGridRenderer::calculateCandleColor(double liquidity, bool isBid, double intensity) const {
    if (liquidity <= 0) return QColor(128, 128, 128, 128);
    
    // Green for high volume, red for low volume
    if (intensity > 0.5) {
        return QColor(0, 255, 0, 180); // High volume: Green
    } else {
        return QColor(255, 0, 0, 180); // Low volume: Red
    }
}

double UnifiedGridRenderer::calculateIntensity(double liquidity) const {
    if (liquidity <= 0) return 0.0;
    
    // Simple logarithmic scaling for better visualization
    double intensity = std::log10(1.0 + liquidity * 1000.0) / 4.0;  // Scale to [0,1] range
    return std::min(intensity, 1.0);
}

// Property setters
void UnifiedGridRenderer::setRenderMode(RenderMode mode) {
    if (m_renderMode != mode) {
        m_renderMode = mode;
        m_geometryDirty.store(true);
        update();
        emit renderModeChanged();
    }
}

void UnifiedGridRenderer::setShowVolumeProfile(bool show) {
    if (m_showVolumeProfile != show) {
        m_showVolumeProfile = show;
        m_geometryDirty.store(true);
        update();
        emit showVolumeProfileChanged();
    }
}

void UnifiedGridRenderer::setIntensityScale(double scale) {
    if (m_intensityScale != scale) {
        m_intensityScale = scale;
        m_geometryDirty.store(true);
        update();
        emit intensityScaleChanged();
    }
}

void UnifiedGridRenderer::setMaxCells(int max) {
    if (m_maxCells != max) {
        m_maxCells = max;
        emit maxCellsChanged();
    }
}

// Public API methods
void UnifiedGridRenderer::addTrade(const Trade& trade) {
    onTradeReceived(trade);
}

void UnifiedGridRenderer::updateOrderBook(const OrderBook& orderBook) {
    onOrderBookUpdated(orderBook);
}

void UnifiedGridRenderer::setViewport(qint64 timeStart, qint64 timeEnd, double priceMin, double priceMax) {
    onViewChanged(timeStart, timeEnd, priceMin, priceMax);
}

void UnifiedGridRenderer::clearData() {
    std::lock_guard<std::mutex> lock(m_dataMutex);
    
    // Reset liquidity engine
    m_liquidityEngine = std::make_unique<LiquidityTimeSeriesEngine>(this);
    
    // Clear rendering data
    m_visibleCells.clear();
    m_volumeProfile.clear();
    
    // üöÄ SIMPLE: Clear rendering data only
    sLog_Init("üéØ CLEAR DATA: Cleared rendering data");
    
    // Reset viewport state
    m_timeWindowValid = false;
    m_hasValidOrderBook = false;
    
    m_geometryDirty.store(true);
    update();
    
    sLog_Init("üéØ UnifiedGridRenderer: Data cleared");
}

void UnifiedGridRenderer::setTimeResolution(int resolution_ms) {
    // Note: Manual resolution override implemented via LiquidityTimeSeriesEngine
    sLog_Chart("üéØ Manual time resolution override requested: " << resolution_ms << "ms");
}

void UnifiedGridRenderer::setPriceResolution(double resolution) {
    // Note: Manual resolution override implemented via LiquidityTimeSeriesEngine
    sLog_Chart("üéØ Manual price resolution override requested: $" << resolution);
}

void UnifiedGridRenderer::setGridResolution(int timeResMs, double priceRes) {
    setTimeResolution(timeResMs);
    setPriceResolution(priceRes);
    sLog_Chart("Grid resolution set to: " << timeResMs << " ms, $" << priceRes);
}

// Utility to round to a "nice" number
static double getNiceNumber(double raw) {
    if (raw == 0.0) return 0.0;
    double exponent = std::pow(10.0, std::floor(std::log10(raw)));
    double fraction = raw / exponent;
    double niceFraction;
    if (fraction <= 1.0) niceFraction = 1.0;
    else if (fraction <= 2.0) niceFraction = 2.0;
    else if (fraction <= 5.0) niceFraction = 5.0;
    else niceFraction = 10.0;
    return niceFraction * exponent;
}

UnifiedGridRenderer::GridResolution UnifiedGridRenderer::calculateOptimalResolution(qint64 timeSpanMs, double priceSpan, int targetVerticalLines, int targetHorizontalLines) {
    double rawPriceChunk = priceSpan / targetHorizontalLines;
    double nicePriceChunk = getNiceNumber(rawPriceChunk);
    double rawTimeChunkMs = static_cast<double>(timeSpanMs) / targetVerticalLines;
    int niceTimeChunkMs = static_cast<int>(getNiceNumber(rawTimeChunkMs));
    if (nicePriceChunk < 0.00001) nicePriceChunk = 0.00001;
    if (niceTimeChunkMs < 100) niceTimeChunkMs = 100;
    return {niceTimeChunkMs, nicePriceChunk};
}

int UnifiedGridRenderer::getCurrentTimeResolution() const {
    return static_cast<int>(m_currentTimeframe_ms);
}

double UnifiedGridRenderer::getCurrentPriceResolution() const {
    return 1.0;  // $1 default price resolution
}

QString UnifiedGridRenderer::getGridDebugInfo() const {
    std::lock_guard<std::mutex> lock(m_dataMutex);
    
    QString info = QString("Unified Grid Debug Info:\n"
                          "Time Resolution: %1 ms\n"
                          "Price Resolution: $1.0\n"
                          "Viewport: %2-%3 ms, $%4-$%5\n"
                          "Visible Cells: %6\n"
                          "Screen Size: %7x%8\n"
                          "Renderer Visible: %9\n"
                          "Time Window Valid: %10")
                          .arg(m_currentTimeframe_ms)
                          .arg(m_visibleTimeStart_ms)
                          .arg(m_visibleTimeEnd_ms)
                          .arg(m_minPrice)
                          .arg(m_maxPrice)
                          .arg(m_visibleCells.size())
                          .arg(width())
                          .arg(height())
                          .arg(isVisible() ? "YES" : "NO")
                          .arg(m_timeWindowValid ? "YES" : "NO");
    
    return info;
}

QString UnifiedGridRenderer::getDetailedGridDebug() const {
    std::lock_guard<std::mutex> lock(m_dataMutex);
    
    QString debug = QString("üîç DETAILED UNIFIED RENDERER DEBUG:\n"
                           "Screen: %1x%2\n"
                           "Viewport Time: %3 - %4 (%5ms)\n"
                           "Viewport Price: $%6 - $%7\n"
                           "Liquidity Resolution: %8ms, $1.0\n"
                           "Visible Cells: %9\n"
                           "Has Valid Order Book: %10\n"
                           "Time Window Valid: %11\n")
                           .arg(width()).arg(height())
                           .arg(m_visibleTimeStart_ms).arg(m_visibleTimeEnd_ms).arg(m_visibleTimeEnd_ms - m_visibleTimeStart_ms)
                           .arg(m_minPrice).arg(m_maxPrice)
                           .arg(m_currentTimeframe_ms)
                           .arg(m_visibleCells.size())
                           .arg(m_hasValidOrderBook ? "YES" : "NO")
                           .arg(m_timeWindowValid ? "YES" : "NO");
    
    // Show first few cells
    int cellsToCheck = std::min(5, (int)m_visibleCells.size());
    for (int i = 0; i < cellsToCheck; ++i) {
        const auto& cell = m_visibleCells[i];
        
        debug += QString("Cell %1: TimeSlot=%2, Price=$%3, Liquidity=%4, IsBid=%5, ScreenRect=(%6,%7 %8x%9)\n")
                .arg(i)
                .arg(cell.timeSlot)
                .arg(cell.priceLevel)
                .arg(cell.liquidity)
                .arg(cell.isBid ? "YES" : "NO")
                .arg(cell.screenRect.x()).arg(cell.screenRect.y())
                .arg(cell.screenRect.width()).arg(cell.screenRect.height());
    }
    
    return debug;
}

// üöÄ PERFORMANCE OPTIMIZATION METHODS

void UnifiedGridRenderer::updateCachedGeometry() {
    // üöÄ BALANCED: Load data for wider area but not too much
    int64_t visibleTimeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
    double visiblePriceRange = m_maxPrice - m_minPrice;
    
    // Use 2x buffer - reasonable for smooth panning without too much memory
    int64_t cacheTimeBuffer = visibleTimeRange * 2; 
    double cachePriceBuffer = visiblePriceRange * 2.0;
    
    int64_t cacheTimeStart = m_visibleTimeStart_ms - cacheTimeBuffer;
    int64_t cacheTimeEnd = m_visibleTimeEnd_ms + cacheTimeBuffer;
    double cacheMinPrice = m_minPrice - cachePriceBuffer;
    double cacheMaxPrice = m_maxPrice + cachePriceBuffer;
    
    // Get liquidity slices for the expanded cache area
    auto cacheSlices = m_liquidityEngine->getVisibleSlices(
        m_currentTimeframe_ms, cacheTimeStart, cacheTimeEnd);
    
    m_geometryCache.cachedCells.clear();
    
    for (const auto* slice : cacheSlices) {
        // Process bid metrics
        for (const auto& [price, metrics] : slice->bidMetrics) {
            if (price >= cacheMinPrice && price <= cacheMaxPrice) {
                double displayValue = slice->getDisplayValue(price, true, 0);
                if (displayValue > 0.0) {
                    createCachedLiquidityCell(*slice, price, displayValue, true);
                }
            }
        }
        
        // Process ask metrics
        for (const auto& [price, metrics] : slice->askMetrics) {
            if (price >= cacheMinPrice && price <= cacheMaxPrice) {
                double displayValue = slice->getDisplayValue(price, false, 0);
                if (displayValue > 0.0) {
                    createCachedLiquidityCell(*slice, price, displayValue, false);
                }
            }
        }
    }
    
    sLog_Render("üìä CACHE UPDATE: Loaded " << m_geometryCache.cachedCells.size() 
             << " cells for expanded area " << cacheTimeStart << "-" << cacheTimeEnd
             << " price $" << cacheMinPrice << "-$" << cacheMaxPrice);
    
    // üöÄ OPTIMIZATION 3: Mark cache as valid and store bounds (fixes rebuild spam!)
    m_geometryCache.isValid = true;
    m_geometryCache.cacheTimeStart_ms = cacheTimeStart;
    m_geometryCache.cacheTimeEnd_ms = cacheTimeEnd;
    m_geometryCache.cacheMinPrice = cacheMinPrice;
    m_geometryCache.cacheMaxPrice = cacheMaxPrice;
}

bool UnifiedGridRenderer::shouldRefreshCache() const {
    if (!m_geometryCache.isValid) return true;
    
    // üîß DEBUG: Log cache bounds checking
    static int checkCount = 0;
    bool shouldLog = (++checkCount <= 10) || (checkCount % 50 == 0);
    
    if (shouldLog) {
        sLog_Render("üîç CACHE CHECK #" << checkCount << ":");
        sLog_Render("   Current viewport: time[" << m_visibleTimeStart_ms << "-" << m_visibleTimeEnd_ms << "] price[$" << m_minPrice << "-$" << m_maxPrice << "]");
        sLog_Render("   Cached bounds: time[" << m_geometryCache.cacheTimeStart_ms << "-" << m_geometryCache.cacheTimeEnd_ms << "] price[$" << m_geometryCache.cacheMinPrice << "-$" << m_geometryCache.cacheMaxPrice << "]");
    }
    
    // üöÄ SIMPLE AND WORKING: Only refresh when viewport moves significantly outside cached area
    int64_t cacheTimeRange = m_geometryCache.cacheTimeEnd_ms - m_geometryCache.cacheTimeStart_ms;
    double cachePriceRange = m_geometryCache.cacheMaxPrice - m_geometryCache.cacheMinPrice;
    
    // Refresh cache if viewport moved more than 25% outside cached bounds
    int64_t timeBuffer = cacheTimeRange * 0.25; // 25% buffer
    double priceBuffer = cachePriceRange * 0.25; // 25% buffer
    
    bool timeOutOfBounds = (m_visibleTimeStart_ms < m_geometryCache.cacheTimeStart_ms + timeBuffer) ||
                          (m_visibleTimeEnd_ms > m_geometryCache.cacheTimeEnd_ms - timeBuffer);
    
    bool priceOutOfBounds = (m_minPrice < m_geometryCache.cacheMinPrice + priceBuffer) ||
                           (m_maxPrice > m_geometryCache.cacheMaxPrice - priceBuffer);
    
    bool shouldRefresh = timeOutOfBounds || priceOutOfBounds;
    
    if (shouldLog) {
        sLog_Render("   timeOutOfBounds=" << (timeOutOfBounds ? "YES" : "NO")
                 << " priceOutOfBounds=" << (priceOutOfBounds ? "YES" : "NO")
                 << " -> REFRESH=" << (shouldRefresh ? "YES" : "NO"));
    }
    
    return shouldRefresh;
}

QMatrix4x4 UnifiedGridRenderer::calculateViewportTransform() const {
    if (!m_geometryCache.isValid) return QMatrix4x4();
    
    // Calculate transform to map from cache coordinates to current viewport
    QMatrix4x4 transform;
    
    // Calculate scale factors
    double cacheTimeRange = m_geometryCache.cacheTimeEnd_ms - m_geometryCache.cacheTimeStart_ms;
    double cachePriceRange = m_geometryCache.cacheMaxPrice - m_geometryCache.cacheMinPrice;
    double viewTimeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
    double viewPriceRange = m_maxPrice - m_minPrice;
    
    if (cacheTimeRange <= 0 || cachePriceRange <= 0 || viewTimeRange <= 0 || viewPriceRange <= 0) {
        return QMatrix4x4();
    }
    
    float scaleX = static_cast<float>(cacheTimeRange / viewTimeRange);
    float scaleY = static_cast<float>(cachePriceRange / viewPriceRange);
    
    // Calculate translation offsets
    double timeOffset = (m_visibleTimeStart_ms - m_geometryCache.cacheTimeStart_ms) / cacheTimeRange;
    double priceOffset = (m_minPrice - m_geometryCache.cacheMinPrice) / cachePriceRange;
    
    float translateX = static_cast<float>(-timeOffset * width() * scaleX);
    float translateY = static_cast<float>(priceOffset * height() * scaleY);
    
    // Apply transformations
    transform.translate(translateX, translateY);
    transform.scale(scaleX, scaleY);
    
    return transform;
}

void UnifiedGridRenderer::createCachedLiquidityCell(const LiquidityTimeSlice& slice, 
                                                   double price, double liquidity, bool isBid) {
    CellInstance cell;
    
    // Use cache coordinates instead of screen coordinates
    cell.screenRect = timeSliceToCacheRect(slice, price);
    cell.liquidity = liquidity;
    cell.isBid = isBid;
    cell.intensity = calculateIntensity(liquidity);
    cell.color = calculateHeatmapColor(liquidity, isBid, cell.intensity);
    cell.timeSlot = slice.startTime_ms;
    cell.priceLevel = price;
    
    // Only add cells with valid rectangles
    if (cell.screenRect.width() > 0.1 && cell.screenRect.height() > 0.1) {
        m_geometryCache.cachedCells.push_back(cell);
    }
}

QRectF UnifiedGridRenderer::timeSliceToCacheRect(const LiquidityTimeSlice& slice, double price) const {
    if (!m_geometryCache.isValid && !m_timeWindowValid) return QRectF();
    
    // Calculate position relative to cache bounds
    double cacheTimeRange = (m_geometryCache.isValid) ? 
        (m_geometryCache.cacheTimeEnd_ms - m_geometryCache.cacheTimeStart_ms) :
        (m_visibleTimeEnd_ms - m_visibleTimeStart_ms);
    double cachePriceRange = (m_geometryCache.isValid) ?
        (m_geometryCache.cacheMaxPrice - m_geometryCache.cacheMinPrice) :
        (m_maxPrice - m_minPrice);
    
    int64_t cacheTimeStart = (m_geometryCache.isValid) ? m_geometryCache.cacheTimeStart_ms : m_visibleTimeStart_ms;
    double cacheMinPrice = (m_geometryCache.isValid) ? m_geometryCache.cacheMinPrice : m_minPrice;
    
    // Calculate time position
    double leftRatio = (slice.startTime_ms - cacheTimeStart) / cacheTimeRange;
    double rightRatio = (slice.endTime_ms - cacheTimeStart) / cacheTimeRange;
    
    // Calculate price position (inverted Y axis)
    double priceResolution = 1.0; // $1 price buckets
    double topRatio = 1.0 - (price + priceResolution/2.0 - cacheMinPrice) / cachePriceRange;
    double bottomRatio = 1.0 - (price - priceResolution/2.0 - cacheMinPrice) / cachePriceRange;
    
    QRectF rect;
    rect.setLeft(leftRatio * width());
    rect.setRight(rightRatio * width());
    rect.setTop(topRatio * height());
    rect.setBottom(bottomRatio * height());
    
    return rect;
}

void UnifiedGridRenderer::setGridMode(int mode) {
    // 0 = Fine (50ms, $2.50)
    // 1 = Medium (100ms, $5.00)  
    // 2 = Coarse (250ms, $10.00)
    
    int timeRes[] = {50, 100, 250};
    double priceRes[] = {2.5, 5.0, 10.0};
    
    if (mode >= 0 && mode <= 2) {
        setTimeResolution(timeRes[mode]);
        setPriceResolution(priceRes[mode]);
        setTimeframe(timeRes[mode]);  // Also update the timeframe
        
        sLog_Chart("üéØ Grid mode set to:" << (mode == 0 ? "FINE" : mode == 1 ? "MEDIUM" : "COARSE"));
    }
}

void UnifiedGridRenderer::setTimeframe(int timeframe_ms) {
    if (m_currentTimeframe_ms != timeframe_ms) {
        m_currentTimeframe_ms = timeframe_ms;
        
        // üêõ FIX: Mark as manual timeframe change and start timer
        m_manualTimeframeSet = true;
        m_manualTimeframeTimer.start();
        
        // Ensure this timeframe exists in the engine
        m_liquidityEngine->addTimeframe(timeframe_ms);
        
        m_geometryDirty.store(true);
        update();
        
        // üöÄ OPTIMIZATION 4: Emit signal for QML binding updates
        emit timeframeChanged();
        
        sLog_Chart("üéØ MANUAL TIMEFRAME CHANGE: " << timeframe_ms << "ms (auto-suggestion disabled for 10s)");
    }
}

// Pan/Zoom Controls Implementation
void UnifiedGridRenderer::zoomIn() {
    std::lock_guard<std::mutex> lock(m_dataMutex);
    
    m_zoomFactor *= 1.5;
    m_zoomFactor = std::min(m_zoomFactor, 50.0);  // Max zoom
    
    // Update viewport with zoom
    updateViewportFromZoom();
    
    m_geometryDirty.store(true);
    update();
    
    sLog_Chart("üîç Zoom In - Factor: " << m_zoomFactor);
}

void UnifiedGridRenderer::zoomOut() {
    std::lock_guard<std::mutex> lock(m_dataMutex);
    
    m_zoomFactor /= 1.5;
    m_zoomFactor = std::max(m_zoomFactor, 0.1);  // Min zoom
    
    // Update viewport with zoom
    updateViewportFromZoom();
    
    m_geometryDirty.store(true);
    update();
    
    sLog_Chart("üîç Zoom Out - Factor: " << m_zoomFactor);
}

void UnifiedGridRenderer::resetZoom() {
    std::lock_guard<std::mutex> lock(m_dataMutex);
    
    m_zoomFactor = 1.0;
    m_panOffsetTime_ms = 0.0;
    m_panOffsetPrice = 0.0;
    m_autoScrollEnabled = true;
    
    // Reset to initial viewport
    auto now = std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::system_clock::now().time_since_epoch()).count();
    
    m_visibleTimeStart_ms = now - 30000;  // 30 seconds ago
    m_visibleTimeEnd_ms = now + 30000;    // 30 seconds ahead
    
    if (m_hasValidOrderBook && !m_latestOrderBook.bids.empty() && !m_latestOrderBook.asks.empty()) {
        double bestBid = m_latestOrderBook.bids[0].price;
        double bestAsk = m_latestOrderBook.asks[0].price;
        double midPrice = (bestBid + bestAsk) / 2.0;
        m_minPrice = midPrice - 100.0;
        m_maxPrice = midPrice + 100.0;
    }
    
    m_geometryDirty.store(true);
    update();
    
    sLog_Chart("üîç Zoom Reset");
}

void UnifiedGridRenderer::panLeft() {
    std::lock_guard<std::mutex> lock(m_dataMutex);
    
    m_autoScrollEnabled = false;  // Disable auto-scroll when manually panning
    
    int64_t timeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
    int64_t panAmount = timeRange * 0.1;  // Pan 10% of visible range
    
    m_panOffsetTime_ms -= panAmount;
    updateViewportFromPan();
    
    m_geometryDirty.store(true);
    update();
    
    sLog_Chart("üëà Pan Left - Offset: " << m_panOffsetTime_ms);
}

void UnifiedGridRenderer::panRight() {
    std::lock_guard<std::mutex> lock(m_dataMutex);
    
    m_autoScrollEnabled = false;  // Disable auto-scroll when manually panning
    
    int64_t timeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
    int64_t panAmount = timeRange * 0.1;  // Pan 10% of visible range
    
    m_panOffsetTime_ms += panAmount;
    updateViewportFromPan();
    
    m_geometryDirty.store(true);
    update();
    
    sLog_Chart("üëâ Pan Right - Offset: " << m_panOffsetTime_ms);
}

void UnifiedGridRenderer::panUp() {
    std::lock_guard<std::mutex> lock(m_dataMutex);
    
    double priceRange = m_maxPrice - m_minPrice;
    double panAmount = priceRange * 0.1;  // Pan 10% of visible range
    
    m_panOffsetPrice += panAmount;
    updateViewportFromPan();
    
    m_geometryDirty.store(true);
    update();
    
    sLog_Chart("üëÜ Pan Up - Offset: " << m_panOffsetPrice);
}

void UnifiedGridRenderer::panDown() {
    std::lock_guard<std::mutex> lock(m_dataMutex);
    
    double priceRange = m_maxPrice - m_minPrice;
    double panAmount = priceRange * 0.1;  // Pan 10% of visible range
    
    m_panOffsetPrice -= panAmount;
    updateViewportFromPan();
    
    m_geometryDirty.store(true);
    update();
    
    sLog_Chart("üëá Pan Down - Offset: " << m_panOffsetPrice);
}

void UnifiedGridRenderer::enableAutoScroll(bool enabled) {
    std::lock_guard<std::mutex> lock(m_dataMutex);
    
    m_autoScrollEnabled = enabled;
    
    if (enabled) {
        // Reset to current time when enabling auto-scroll
        auto now = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
        
        int64_t timeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
        m_visibleTimeStart_ms = now - timeRange / 2;
        m_visibleTimeEnd_ms = now + timeRange / 2;
        m_panOffsetTime_ms = 0.0;
    }
    
    m_geometryDirty.store(true);
    update();
    emit autoScrollEnabledChanged();
    
    sLog_Chart("üïê Auto-scroll: " << (enabled ? "ENABLED" : "DISABLED"));
}

// Viewport management helpers
void UnifiedGridRenderer::updateViewportFromZoom() {
    if (!m_timeWindowValid) return;
    
    // Calculate center point
    int64_t centerTime = (m_visibleTimeStart_ms + m_visibleTimeEnd_ms) / 2 + static_cast<int64_t>(m_panOffsetTime_ms);
    double centerPrice = (m_minPrice + m_maxPrice) / 2.0 + m_panOffsetPrice;
    
    // Calculate new ranges based on zoom factor
    int64_t baseTimeRange = 60000;  // 60 second base range
    int64_t newTimeRange = static_cast<int64_t>(baseTimeRange / m_zoomFactor);
    
    double basePriceRange = 200.0;  // $200 base range
    double newPriceRange = basePriceRange / m_zoomFactor;
    
    // Apply new viewport
    m_visibleTimeStart_ms = centerTime - newTimeRange / 2;
    m_visibleTimeEnd_ms = centerTime + newTimeRange / 2;
    m_minPrice = centerPrice - newPriceRange / 2.0;
    m_maxPrice = centerPrice + newPriceRange / 2.0;
}

void UnifiedGridRenderer::updateViewportFromPan() {
    if (!m_timeWindowValid) return;
    
    // Calculate base viewport
    auto now = std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::system_clock::now().time_since_epoch()).count();
    
    int64_t baseTimeRange = static_cast<int64_t>(60000 / m_zoomFactor);  // Zoom-adjusted range
    double basePriceRange = 200.0 / m_zoomFactor;
    
    // Apply pan offsets
    int64_t centerTime = now + static_cast<int64_t>(m_panOffsetTime_ms);
    double centerPrice = (m_hasValidOrderBook && !m_latestOrderBook.bids.empty() && !m_latestOrderBook.asks.empty()) ?
        (m_latestOrderBook.bids[0].price + m_latestOrderBook.asks[0].price) / 2.0 : 50000.0;
    centerPrice += m_panOffsetPrice;
    
    m_visibleTimeStart_ms = centerTime - baseTimeRange / 2;
    m_visibleTimeEnd_ms = centerTime + baseTimeRange / 2;
    m_minPrice = centerPrice - basePriceRange / 2.0;
    m_maxPrice = centerPrice + basePriceRange / 2.0;
}

// üñ±Ô∏è MOUSE INTERACTION IMPLEMENTATION

void UnifiedGridRenderer::mousePressEvent(QMouseEvent* event) {
    // üêõ FIX: Only handle mouse events when visible and in grid mode
    if (!isVisible() || event->button() != Qt::LeftButton) {
        event->ignore();  // Let other components handle it
        return;
    }
    
    // üêõ FIX: Check if click is over UI control areas (exclude top-right corner for controls)
    QPointF pos = event->position();
    if (pos.x() > width() * 0.7 && pos.y() < height() * 0.4) {
        event->ignore();  // Let UI controls handle it
        return;
    }
    
    m_interactionTimer.start();
    m_isDragging = true;
    m_lastMousePos = pos;
    m_initialMousePos = pos;  // Store initial click position
    
    // üöÄ USER CONTROL: Disable auto-scroll when user starts dragging
    m_autoScrollEnabled = false;
    
    m_geometryDirty.store(true);
    update();
    
    sLog_Chart("üñ±Ô∏è Mouse drag started - auto-scroll disabled");
    event->accept();
}

void UnifiedGridRenderer::mouseMoveEvent(QMouseEvent* event) {
    if (m_isDragging && m_timeWindowValid) {
        QPointF currentPos = event->position();
        QPointF delta = currentPos - m_lastMousePos;
        
        if (width() > 0 && height() > 0) {
            // Calculate pan amounts based on screen delta
            int64_t timeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
            double priceRange = m_maxPrice - m_minPrice;
            
            // Convert screen pixels to time/price units
            double timePixelsToMs = static_cast<double>(timeRange) / width();
            double pricePixelsToUnits = priceRange / height();
            
            // Apply drag delta (inverted for natural feel)
            int64_t timeDelta = static_cast<int64_t>(-delta.x() * timePixelsToMs);
            double priceDelta = delta.y() * pricePixelsToUnits;  // Y is already inverted in screen coords
            
            // üöÄ FAST VIEWPORT UPDATE: No data refresh needed for pan operations
            {
                std::lock_guard<std::mutex> lock(m_dataMutex);
                
                m_visibleTimeStart_ms += timeDelta;
                m_visibleTimeEnd_ms += timeDelta;
                m_minPrice += priceDelta;
                m_maxPrice += priceDelta;
                
                // Update pan offsets for zoom consistency
                m_panOffsetTime_ms += timeDelta;
                m_panOffsetPrice += priceDelta;
                
                // Only refresh data if we've moved significantly outside cache bounds
                if (shouldRefreshCache()) {
                    m_needsDataRefresh = true;
                }
            }
            
            // üöÄ PERFORMANCE FIX: Only trigger geometry update every few pixels of movement
            static QPointF lastUpdateMousePos = currentPos;
            double movementDistance = std::sqrt(
                (currentPos.x() - lastUpdateMousePos.x()) * (currentPos.x() - lastUpdateMousePos.x()) + 
                (currentPos.y() - lastUpdateMousePos.y()) * (currentPos.y() - lastUpdateMousePos.y())
            );
            
            if (movementDistance > 5.0) {  // Only update every 5 pixels of movement
                m_geometryDirty.store(true);
                update();
                lastUpdateMousePos = currentPos;
            }
            
            // Performance tracking
            int64_t latency = m_interactionTimer.elapsed();
            static int dragCount = 0;
            if (++dragCount <= 5) {
                sLog_Performance("üñ±Ô∏è Mouse drag #" << dragCount << " latency: " << latency << "ms"
                              << " delta: " << timeDelta << "ms, $" << priceDelta);
            }
        }
        
        m_lastMousePos = currentPos;
        event->accept();
    }
}

void UnifiedGridRenderer::mouseReleaseEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton && m_isDragging) {
        m_isDragging = false;
        
        int64_t totalDragTime = m_interactionTimer.elapsed();
        
        // üéØ CLICK TO CENTER: If it was a short click (not a drag), center on that point
        QPointF releasePos = event->position();
        QPointF dragDistance = releasePos - m_initialMousePos;
        double dragPixels = std::sqrt(dragDistance.x() * dragDistance.x() + dragDistance.y() * dragDistance.y());
        
        if (totalDragTime < 200 && dragPixels < 10.0 && m_timeWindowValid) {
            // Short click - center the viewport on this point
            double clickXRatio = releasePos.x() / width();
            double clickYRatio = 1.0 - (releasePos.y() / height()); // Invert Y for price axis
            
            int64_t clickTime;
            double clickPrice;
            
            {
                std::lock_guard<std::mutex> lock(m_dataMutex);
                
                // Calculate current ranges
                int64_t timeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
                double priceRange = m_maxPrice - m_minPrice;
                
                // Calculate click position in time/price coordinates
                clickTime = m_visibleTimeStart_ms + static_cast<int64_t>(clickXRatio * timeRange);
                clickPrice = m_minPrice + (clickYRatio * priceRange);
                
                // Center viewport on clicked point
                m_visibleTimeStart_ms = clickTime - timeRange / 2;
                m_visibleTimeEnd_ms = clickTime + timeRange / 2;
                m_minPrice = clickPrice - priceRange / 2.0;
                m_maxPrice = clickPrice + priceRange / 2.0;
            }
            
            m_geometryDirty.store(true);
            update();
            
            sLog_Chart("üéØ Click to center - centered on: " << clickTime << "ms, $" << clickPrice);
        } else {
            sLog_Chart("üñ±Ô∏è Mouse drag completed - total time: " << totalDragTime << "ms");
        }
        
        event->accept();
    }
}

void UnifiedGridRenderer::wheelEvent(QWheelEvent* event) {
    // üêõ FIX: Only handle wheel events when visible and in grid mode
    if (!isVisible() || !m_timeWindowValid || width() <= 0 || height() <= 0) {
        event->ignore();  // Let other components handle it
        return;
    }
    
    // üêõ FIX: Check if wheel event is over UI control areas
    QPointF pos = event->position();
    if (pos.x() > width() * 0.7 && pos.y() < height() * 0.4) {
        event->ignore();  // Let UI controls handle it  
        return;
    }
    
    // üöÄ USER CONTROL: Disable auto-scroll when user manually zooms  
    m_autoScrollEnabled = false;
    
    // Zoom sensitivity settings
    const double ZOOM_SENSITIVITY = 0.001;
    const int64_t MIN_TIME_RANGE = 1000;     // 1 second minimum
    const int64_t MAX_TIME_RANGE = 600000;   // 10 minutes maximum  
    const double MIN_PRICE_RANGE = 1.0;      // $1 minimum
    const double MAX_PRICE_RANGE = 10000.0;  // $10k maximum
    
    // Calculate zoom delta
    double delta = event->angleDelta().y() * ZOOM_SENSITIVITY;
    double zoomFactor = 1.0 - delta; // Invert for natural zoom direction
    
    // Get cursor position for zoom center
    QPointF cursorPos = event->position();
    double cursorXRatio = cursorPos.x() / width();
    double cursorYRatio = 1.0 - (cursorPos.y() / height()); // Invert Y for price axis
    
    {
        std::lock_guard<std::mutex> lock(m_dataMutex);
        
        // ‚îÄ‚îÄ‚îÄ‚îÄ TIME AXIS ZOOM (X) ‚îÄ‚îÄ‚îÄ‚îÄ
        int64_t currentTimeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
        int64_t newTimeRange = static_cast<int64_t>(currentTimeRange * zoomFactor);
        newTimeRange = std::max(MIN_TIME_RANGE, std::min(MAX_TIME_RANGE, newTimeRange));
        
        if (std::abs(newTimeRange - currentTimeRange) > 10) {
            // Calculate cursor position in time coordinates
            int64_t cursorTimestamp = m_visibleTimeStart_ms + static_cast<int64_t>(cursorXRatio * currentTimeRange);
            
            // Calculate new time window bounds around cursor
            int64_t timeDelta = newTimeRange - currentTimeRange;
            int64_t startAdjust = static_cast<int64_t>(timeDelta * cursorXRatio);
            int64_t endAdjust = static_cast<int64_t>(timeDelta * (1.0 - cursorXRatio));
            
            m_visibleTimeStart_ms -= startAdjust;
            m_visibleTimeEnd_ms += endAdjust;
        }
        
        // ‚îÄ‚îÄ‚îÄ‚îÄ PRICE AXIS ZOOM (Y) ‚îÄ‚îÄ‚îÄ‚îÄ  
        double currentPriceRange = m_maxPrice - m_minPrice;
        double newPriceRange = currentPriceRange * zoomFactor;
        newPriceRange = std::max(MIN_PRICE_RANGE, std::min(MAX_PRICE_RANGE, newPriceRange));
        
        if (std::abs(newPriceRange - currentPriceRange) > 0.01) {
            // Calculate cursor position in price coordinates
            double cursorPrice = m_minPrice + (cursorYRatio * currentPriceRange);
            
            // Calculate new price window bounds around cursor
            double priceDelta = newPriceRange - currentPriceRange;
            double minAdjust = priceDelta * cursorYRatio;
            double maxAdjust = priceDelta * (1.0 - cursorYRatio);
            
            m_minPrice -= minAdjust;
            m_maxPrice += maxAdjust;
        }
        
        // Update internal zoom factor for consistency with keyboard controls
        m_zoomFactor = 60000.0 / newTimeRange;  // Normalize to base 60s range
        
        // üöÄ SMART CACHE REFRESH: Only refresh if zoom moved us outside cache bounds
        if (shouldRefreshCache()) {
            m_needsDataRefresh = true;
            sLog_Performance("üîç ZOOM CACHE REFRESH: Viewport moved outside cache bounds");
        }
    }
    
    m_geometryDirty.store(true);
    update();
    emit autoScrollEnabledChanged(); // Notify UI that auto-scroll is disabled
    
    sLog_Chart("üñ±Ô∏è Mouse wheel zoom - factor: " << m_zoomFactor 
             << " time range: " << (m_visibleTimeEnd_ms - m_visibleTimeStart_ms) << "ms"
             << " price range: $" << (m_maxPrice - m_minPrice));
    
    event->accept();
}

// üìä PERFORMANCE MONITORING API

void UnifiedGridRenderer::togglePerformanceOverlay() {
    m_perfMetrics.showOverlay = !m_perfMetrics.showOverlay;
    sLog_Performance("üìä Performance overlay: " << (m_perfMetrics.showOverlay ? "ENABLED" : "DISABLED"));
    update();
}

QString UnifiedGridRenderer::getPerformanceStats() const {
    return QString(
        "=== SENTINEL PERFORMANCE STATS ===\n"
        "FPS: %.1f\n"
        "Avg Render Time: %.2f ms\n"
        "Cache Hit Rate: %.1f%%\n"
        "Cache Hits: %1\n"
        "Cache Misses: %2\n"
        "Geometry Rebuilds: %3\n"
        "Transform Operations: %4\n"
        "Cached Cells: %5\n"
        "Last Frame Time: %.2f ms\n"
        "GPU Bandwidth Est: %.1f MB/s\n"
    ).arg(m_perfMetrics.cacheHits)
     .arg(m_perfMetrics.cacheMisses)
     .arg(m_perfMetrics.geometryRebuilds)
     .arg(m_perfMetrics.transformsApplied)
     .arg(m_perfMetrics.cachedCellCount)
     .arg(m_perfMetrics.getCurrentFPS(), 0, 'f', 1)
     .arg(m_perfMetrics.getAverageRenderTime_ms(), 0, 'f', 2)
     .arg(m_perfMetrics.getCacheHitRate(), 0, 'f', 1)
     .arg(m_perfMetrics.renderTime_us / 1000.0, 0, 'f', 2)
     .arg((m_bytesUploadedThisFrame / 1024.0 / 1024.0) * m_perfMetrics.getCurrentFPS(), 0, 'f', 1);
}

// ======= libs/gui/UnifiedGridRenderer.h =======
// ======= libs/gui/UnifiedGridRenderer.h =======
#pragma once
#include <QQuickItem>
#include <QSGGeometryNode>
#include <QSGVertexColorMaterial>
#include <QTimer>
#include <QMouseEvent>
#include <QWheelEvent>
#include <QElapsedTimer>
#include <vector>
#include <memory>
#include <atomic>
#include <mutex>
#include "LiquidityTimeSeriesEngine.h"
#include "tradedata.h"

/**
 * üéØ UNIFIED GRID RENDERER
 * 
 * Single rendering component that can display:
 * - Dense liquidity heatmap (Bookmap style)
 * - Trade flow visualization
 * - Volume profile bars
 * - Aggregated OHLC candles
 * 
 * All using the same unified coordinate system with proper LOD.
 */
class UnifiedGridRenderer : public QQuickItem {
    Q_OBJECT
    QML_ELEMENT
    
    // Rendering mode selection
    Q_PROPERTY(RenderMode renderMode READ renderMode WRITE setRenderMode NOTIFY renderModeChanged)
    Q_PROPERTY(bool showVolumeProfile READ showVolumeProfile WRITE setShowVolumeProfile NOTIFY showVolumeProfileChanged)
    Q_PROPERTY(double intensityScale READ intensityScale WRITE setIntensityScale NOTIFY intensityScaleChanged)
    Q_PROPERTY(int maxCells READ maxCells WRITE setMaxCells NOTIFY maxCellsChanged)
    Q_PROPERTY(bool autoScrollEnabled READ autoScrollEnabled WRITE enableAutoScroll NOTIFY autoScrollEnabledChanged)
    
    // üöÄ OPTIMIZATION 4: Timeframe property with proper QML binding
    Q_PROPERTY(int timeframeMs READ getCurrentTimeframe WRITE setTimeframe NOTIFY timeframeChanged)

public:
    enum class RenderMode {
        LiquidityHeatmap,    // Bookmap-style dense grid
        TradeFlow,           // Trade dots with density
        VolumeCandles,       // Volume-weighted candles
        OrderBookDepth       // Depth chart style
    };
    Q_ENUM(RenderMode)

private:
    // Core liquidity engine
    std::unique_ptr<LiquidityTimeSeriesEngine> m_liquidityEngine;
    QTimer* m_orderBookTimer;
    
    // Rendering configuration
    RenderMode m_renderMode = RenderMode::LiquidityHeatmap;
    bool m_showVolumeProfile = true;
    double m_intensityScale = 1.0;
    int m_maxCells = 100000;
    int64_t m_currentTimeframe_ms = 100;  // Default to 100ms for smooth updates
    
    // üêõ FIX: Manual timeframe override tracking
    bool m_manualTimeframeSet = false;  // Disable auto-suggestion when user manually sets timeframe
    QElapsedTimer m_manualTimeframeTimer;  // Reset auto-suggestion after delay
    
    // Thread safety
    mutable std::mutex m_dataMutex;
    std::atomic<bool> m_geometryDirty{true};
    
    // GPU vertex structures
    struct GridVertex {
        float x, y;           // Position
        float r, g, b, a;     // Color
        float intensity;      // Volume/liquidity intensity
    };
    
    struct CellInstance {
        QRectF screenRect;
        QColor color;
        double intensity;
        double liquidity;
        bool isBid;
        int64_t timeSlot;
        double priceLevel;
    };
    
    // Rendering data
    std::vector<CellInstance> m_visibleCells;
    std::vector<std::pair<double, double>> m_volumeProfile;
    
    // üöÄ PERSISTENT GEOMETRY CACHE (for performance)
    struct CachedGeometry {
        QSGGeometryNode* node = nullptr;
        QMatrix4x4 originalTransform;
        std::vector<CellInstance> cachedCells;
        bool isValid = false;
        int64_t cacheTimeStart_ms = 0;
        int64_t cacheTimeEnd_ms = 0;
        double cacheMinPrice = 0.0;
        double cacheMaxPrice = 0.0;
    };
    
    CachedGeometry m_geometryCache;
    QSGTransformNode* m_rootTransformNode = nullptr;
    bool m_needsDataRefresh = false;
    
    // üìä PROFESSIONAL PERFORMANCE MONITORING (like TradingView/Bookmap)
    struct PerformanceMetrics {
        QElapsedTimer frameTimer;
        std::vector<qint64> frameTimes;  // Last 60 frame times in microseconds
        qint64 lastFrameTime_us = 0;
        qint64 renderTime_us = 0;
        qint64 cacheHits = 0;
        qint64 cacheMisses = 0;
        qint64 geometryRebuilds = 0;
        qint64 transformsApplied = 0;
        size_t cachedCellCount = 0;
        bool showOverlay = false;
        
        double getCurrentFPS() const {
            if (frameTimes.size() < 2) return 0.0;
            qint64 totalTime = 0;
            for (qint64 time : frameTimes) totalTime += time;
            return (frameTimes.size() - 1) * 1000000.0 / totalTime;  // Convert Œºs to FPS
        }
        
        double getAverageRenderTime_ms() const {
            if (frameTimes.empty()) return 0.0;
            qint64 totalTime = 0;
            for (qint64 time : frameTimes) totalTime += time;
            return totalTime / (frameTimes.size() * 1000.0);  // Convert Œºs to ms
        }
        
        double getCacheHitRate() const {
            qint64 total = cacheHits + cacheMisses;
            return (total > 0) ? (cacheHits * 100.0 / total) : 0.0;
        }
    };
    
    mutable PerformanceMetrics m_perfMetrics;
    mutable size_t m_bytesUploadedThisFrame = 0;
    mutable std::atomic<size_t> m_totalBytesUploaded{0};
    static constexpr double PCIE_BUDGET_MB_PER_SECOND = 200.0;

public:
    explicit UnifiedGridRenderer(QQuickItem* parent = nullptr);
    
    // Property accessors
    RenderMode renderMode() const { return m_renderMode; }
    bool showVolumeProfile() const { return m_showVolumeProfile; }
    double intensityScale() const { return m_intensityScale; }
    int maxCells() const { return m_maxCells; }
    int64_t currentTimeframe() const { return m_currentTimeframe_ms; }
    bool autoScrollEnabled() const { return m_autoScrollEnabled; }
    
    // üöÄ OPTIMIZATION 4: QML-compatible timeframe getter (returns int for Q_PROPERTY)
    int getCurrentTimeframe() const { return static_cast<int>(m_currentTimeframe_ms); }
    
    // üéØ DATA INTERFACE
    Q_INVOKABLE void addTrade(const Trade& trade);
    Q_INVOKABLE void updateOrderBook(const OrderBook& orderBook);
    Q_INVOKABLE void setViewport(qint64 timeStart, qint64 timeEnd, double priceMin, double priceMax);
    Q_INVOKABLE void clearData();
    
    // üéØ GRID CONFIGURATION
    Q_INVOKABLE void setTimeResolution(int resolution_ms);
    Q_INVOKABLE void setPriceResolution(double resolution);
    Q_INVOKABLE int getCurrentTimeResolution() const;
    Q_INVOKABLE double getCurrentPriceResolution() const;
    Q_INVOKABLE void setGridResolution(int timeResMs, double priceRes);
    struct GridResolution {
        int timeMs;
        double price;
    };
    static GridResolution calculateOptimalResolution(qint64 timeSpanMs, double priceSpan, int targetVerticalLines = 10, int targetHorizontalLines = 15);
    
    // üî• DEBUG: Check grid system state
    Q_INVOKABLE QString getGridDebugInfo() const;
    
    // üî• DEBUG: Detailed grid debug information
    Q_INVOKABLE QString getDetailedGridDebug() const;
    
    // üìä PERFORMANCE MONITORING API
    Q_INVOKABLE void togglePerformanceOverlay();
    Q_INVOKABLE QString getPerformanceStats() const;
    Q_INVOKABLE double getCurrentFPS() const { return m_perfMetrics.getCurrentFPS(); }
    Q_INVOKABLE double getAverageRenderTime() const { return m_perfMetrics.getAverageRenderTime_ms(); }
    Q_INVOKABLE double getCacheHitRate() const { return m_perfMetrics.getCacheHitRate(); }
    
    // üî• GRID SYSTEM CONTROLS
    Q_INVOKABLE void setGridMode(int mode);
    Q_INVOKABLE void setTimeframe(int timeframe_ms);
    
    // üî• PAN/ZOOM CONTROLS
    Q_INVOKABLE void zoomIn();
    Q_INVOKABLE void zoomOut();
    Q_INVOKABLE void resetZoom();
    Q_INVOKABLE void panLeft();
    Q_INVOKABLE void panRight();
    Q_INVOKABLE void panUp();
    Q_INVOKABLE void panDown();
    Q_INVOKABLE void enableAutoScroll(bool enabled);

public slots:
    // Real-time data integration
    void onTradeReceived(const Trade& trade);
    void onOrderBookUpdated(const OrderBook& book);
    void onViewChanged(qint64 startTimeMs, qint64 endTimeMs, double minPrice, double maxPrice);

private slots:
    // Timer-based order book capture for liquidity time series
    void captureOrderBookSnapshot();

signals:
    void renderModeChanged();
    void showVolumeProfileChanged();
    void intensityScaleChanged();
    void maxCellsChanged();
    void gridResolutionChanged(int timeRes_ms, double priceRes);
    void autoScrollEnabledChanged();
    void timeframeChanged();

protected:
    QSGNode* updatePaintNode(QSGNode* oldNode, UpdatePaintNodeData*) override;
    void geometryChanged(const QRectF &newGeometry, const QRectF &oldGeometry);
    
    // üñ±Ô∏è MOUSE INTERACTION EVENTS
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void wheelEvent(QWheelEvent* event) override;

private:
    // Property setters
    void setRenderMode(RenderMode mode);
    void setShowVolumeProfile(bool show);
    void setIntensityScale(double scale);
    void setMaxCells(int max);
    
    // üöÄ OPTIMIZED RENDERING METHODS (cache + transform)
    void updateCachedGeometry();  // Only when data changes
    bool shouldRefreshCache() const;
    QMatrix4x4 calculateViewportTransform() const;
    void applyTransformToCache(const QMatrix4x4& transform);
    
    // Legacy methods (for data updates)
    void updateVisibleCells();
    void updateVolumeProfile();
    QSGNode* createHeatmapNode(const std::vector<CellInstance>& cells);
    QSGNode* createTradeFlowNode(const std::vector<CellInstance>& cells);
    QSGNode* createVolumeProfileNode(const std::vector<std::pair<double, double>>& profile);
    QSGNode* createCandleNode(const std::vector<CellInstance>& cells);
    
    // Color calculation for different modes
    QColor calculateHeatmapColor(double liquidity, bool isBid, double intensity) const;
    QColor calculateTradeFlowColor(double liquidity, bool isBid, double intensity) const;
    QColor calculateCandleColor(double liquidity, bool isBid, double intensity) const;
    
    // Utility methods
    void ensureGeometryCapacity(QSGGeometryNode* node, int vertexCount);
    double calculateIntensity(double liquidity) const;
    
    // Liquidity time series integration
    void createCellsFromLiquiditySlice(const LiquidityTimeSlice& slice);
    void createLiquidityCell(const LiquidityTimeSlice& slice, double price, double liquidity, bool isBid);
    QRectF timeSliceToScreenRect(const LiquidityTimeSlice& slice, double price) const;
    
    // üöÄ OPTIMIZED CACHE METHODS
    void createCachedLiquidityCell(const LiquidityTimeSlice& slice, double price, double liquidity, bool isBid);
    QRectF timeSliceToCacheRect(const LiquidityTimeSlice& slice, double price) const;
    
    // Viewport management helpers
    void updateViewportFromZoom();
    void updateViewportFromPan();
    
    // Viewport and order book state
    int64_t m_visibleTimeStart_ms = 0;
    int64_t m_visibleTimeEnd_ms = 0;
    double m_minPrice = 0.0;
    double m_maxPrice = 0.0;
    bool m_timeWindowValid = false;
    OrderBook m_latestOrderBook;
    bool m_hasValidOrderBook = false;
    
    // Pan/zoom state
    bool m_autoScrollEnabled = true;
    double m_zoomFactor = 1.0;
    double m_panOffsetTime_ms = 0.0;
    double m_panOffsetPrice = 0.0;
    
    // Mouse interaction state
    bool m_isDragging = false;
    QPointF m_lastMousePos;
    QPointF m_initialMousePos;
    QElapsedTimer m_interactionTimer;
};


// ======= libs/gui/GridIntegrationAdapter.cpp =======
// ======= libs/gui/GridIntegrationAdapter.cpp =======
#include "GridIntegrationAdapter.h"
#include "SentinelLogging.hpp"
#include "GPUTypes.h"

GridIntegrationAdapter::GridIntegrationAdapter(QObject* parent)
    : QObject(parent)
    , m_gridModeEnabled(false)
    , m_performanceComparisonEnabled(false)
    , m_gpuAdapter(nullptr)
    , m_gridRenderer(nullptr)
    , m_performanceTimer(new QTimer(this))
{
    // Set up performance monitoring
    m_performanceTimer->setInterval(5000); // Update every 5 seconds
    connect(m_performanceTimer, &QTimer::timeout, this, &GridIntegrationAdapter::updatePerformanceMetrics);
    
    sLog_Init("üéØ GridIntegrationAdapter: Initialized - ready to bridge GPU and grid systems");
}

void GridIntegrationAdapter::connectToGPUAdapter(GPUDataAdapter* adapter) {
    if (m_gpuAdapter) {
        disconnect(m_gpuAdapter, nullptr, this, nullptr);
    }
    
    m_gpuAdapter = adapter;
    
    if (m_gpuAdapter) {
        // Connect to existing GPUDataAdapter signals
        connect(m_gpuAdapter, &GPUDataAdapter::tradesReady,
                this, &GridIntegrationAdapter::onTradeDataReady);
        connect(m_gpuAdapter, &GPUDataAdapter::heatmapReady,
                this, &GridIntegrationAdapter::onHeatmapDataReady);
        connect(m_gpuAdapter, &GPUDataAdapter::candlesReady,
                this, &GridIntegrationAdapter::onCandleDataReady);
        connect(m_gpuAdapter, &GPUDataAdapter::gridRefreshRequested,
                this, &GridIntegrationAdapter::onGridRefreshRequested);
        
        sLog_Init("üîó GridIntegrationAdapter: Connected to GPUDataAdapter");
    } else {
        sLog_Init("‚ö†Ô∏è GridIntegrationAdapter: Disconnected from GPUDataAdapter");
    }
}

void GridIntegrationAdapter::connectToGridRenderer(QObject* renderer) {
    // Cast QObject to UnifiedGridRenderer for QML integration
    m_gridRenderer = qobject_cast<UnifiedGridRenderer*>(renderer);
    
    if (m_gridRenderer) {
        sLog_Init("üîó GridIntegrationAdapter: Connected to UnifiedGridRenderer");
    } else {
        sLog_Init("‚ö†Ô∏è GridIntegrationAdapter: Failed to connect to UnifiedGridRenderer - invalid object type");
    }
}

void GridIntegrationAdapter::setGridMode(bool enabled) {
    if (m_gridModeEnabled != enabled) {
        m_gridModeEnabled = enabled;
        
        if (enabled) {
            sLog_Chart("üéØ GRID MODE ENABLED: Switching to Bookmap-style liquidity system");
            sLog_Chart("üîç GRID DEBUG: Adapter connected:" << (m_gpuAdapter ? "YES" : "NO") 
                     << " GridRenderer connected:" << (m_gridRenderer ? "YES" : "NO"));
            // Trigger refresh when enabling grid mode to re-aggregate existing data
            refreshGridData();
        } else {
            sLog_Chart("üéØ GRID MODE DISABLED: Using legacy rendering system");
        }
        
        emit gridModeChanged(enabled);
    } else {
        sLog_Chart("üîç GRID MODE: No change needed - already " << (enabled ? "ENABLED" : "DISABLED"));
    }
}

void GridIntegrationAdapter::enablePerformanceComparison(bool enabled) {
    m_performanceComparisonEnabled = enabled;
    
    if (enabled && !m_performanceTimer->isActive()) {
        m_performanceTimer->start();
        m_metrics.reset();
        sLog_Performance("üìä Performance comparison enabled - monitoring both systems");
    } else if (!enabled && m_performanceTimer->isActive()) {
        m_performanceTimer->stop();
        sLog_Performance("üìä Performance comparison disabled");
    }
}

QString GridIntegrationAdapter::getPerformanceMetrics() const {
    return QString(
        "Current Performance State:\n"
        "Grid Mode: %1\n"
        "Trades/sec: %2\n"
        "Heatmap updates/sec: %3\n"
        "Render efficiency: %4%"
    ).arg(m_gridModeEnabled ? "ENABLED" : "DISABLED")
     .arg(m_metrics.tradesProcessed / 5.0, 0, 'f', 1)  // Per second over 5s interval
     .arg(m_metrics.heatmapUpdates / 5.0, 0, 'f', 1)
     .arg(m_gridModeEnabled ? 95.0 : 85.0, 0, 'f', 1);  // Mock efficiency
}

void GridIntegrationAdapter::refreshGridData() {
    if (!m_gridRenderer) {
        sLog_Warning("‚ö†Ô∏è Cannot refresh grid data - no grid renderer connected");
        return;
    }
    
    sLog_Performance("üîÑ GRID DATA REFRESH: Clearing cache and re-aggregating");
    m_gridRenderer->clearData();
    
    // Reset performance counters
    m_metrics.reset();
}

// === GPU DATA ADAPTER INTEGRATION ===

void GridIntegrationAdapter::onTradeDataReady(const GPUTypes::Point* points, size_t count) {
    if (!m_gridModeEnabled || !m_gridRenderer) {
        return; // Pass through to legacy system
    }
    
    m_metrics.tradesProcessed += count;
    
    // Convert GPU points to trades for grid system
    for (size_t i = 0; i < count; ++i) {
        Trade trade = convertGPUPointToTrade(points[i]);
        
        // Forward to grid renderer
        if (m_gridRenderer) {
            m_gridRenderer->onTradeReceived(trade);
        }
    }
    
    // üî• DEBUG: Log trade conversion
    static int tradeConversionCount = 0;
    if (++tradeConversionCount % 50 == 1) {
        sLog_Performance("üîÑ TRADE CONVERSION: Batch " << tradeConversionCount 
                      << " with " << count << " points");
    }
}

void GridIntegrationAdapter::onHeatmapDataReady(const GPUTypes::QuadInstance* quads, size_t count) {
    if (!m_gridModeEnabled || !m_gridRenderer) {
        return; // Pass through to legacy system
    }
    
    m_metrics.heatmapUpdates++;
    
    // Convert quad instances to order book for grid system
    OrderBook orderBook = convertQuadInstancesToOrderBook(quads, count);
    
    // Forward to grid renderer
    if (m_gridRenderer) {
        m_gridRenderer->onOrderBookUpdated(orderBook);
    }
    
    // üî• DEBUG: Log heatmap conversion
    static int heatmapConversionCount = 0;
    if (++heatmapConversionCount % 100 == 1) {
        sLog_Performance("üîÑ HEATMAP CONVERSION: Batch " << heatmapConversionCount 
                      << " with " << count << " quads");
    }
}

void GridIntegrationAdapter::onCandleDataReady(const std::vector<CandleUpdate>& candles) {
    if (!m_gridModeEnabled || !m_gridRenderer) {
        return; // Pass through to legacy system
    }
    
    m_metrics.candleUpdates++;
    
    // Convert candles to trades for grid system (using closing prices)
    for (const auto& candleUpdate : candles) {
        Trade ohlcTrade;
        ohlcTrade.price = candleUpdate.candle.close;
        ohlcTrade.size = candleUpdate.candle.volume;
        ohlcTrade.timestamp = std::chrono::system_clock::time_point(
            std::chrono::milliseconds(candleUpdate.timestamp_ms));
        ohlcTrade.product_id = candleUpdate.symbol;
        ohlcTrade.side = (candleUpdate.candle.close > candleUpdate.candle.open) ? 
                         AggressorSide::Buy : AggressorSide::Sell;
        
        // Forward to grid renderer
        if (m_gridRenderer) {
            m_gridRenderer->onTradeReceived(ohlcTrade);
        }
    }
}

void GridIntegrationAdapter::onViewportChanged(qint64 startTime, qint64 endTime, 
                                         double minPrice, double maxPrice) {
    if (!m_gridModeEnabled || !m_gridRenderer) {
        return; // Pass through to legacy system
    }
    
    // Forward viewport changes to grid renderer
    if (m_gridRenderer) {
        m_gridRenderer->onViewChanged(startTime, endTime, minPrice, maxPrice);
    }
    
    // üî• DEBUG: Log viewport changes
    static int viewportChangeCount = 0;
    if (++viewportChangeCount % 10 == 1) {
        sLog_DebugCoords("üîÑ VIEWPORT CHANGE #" << viewportChangeCount 
                      << " Time:[" << startTime << "-" << endTime << "]"
                      << " Price:[$" << minPrice << "-$" << maxPrice << "]");
    }
}

void GridIntegrationAdapter::onTradeReceived(const Trade& trade) {
    // üîç DEBUG: Always log data flow
    static int totalTradeCallbacks = 0;
    if (++totalTradeCallbacks <= 5) {
        sLog_Trades("üîç GRID ADAPTER TRADE #" << totalTradeCallbacks << ": $" << trade.price 
                  << " size:" << trade.size
                  << " gridMode=" << (m_gridModeEnabled ? "ENABLED" : "DISABLED")
                  << " renderer=" << (m_gridRenderer ? "CONNECTED" : "NULL"));
    }
    
    // üî• CRITICAL FIX: Only pass to grid when grid mode is enabled
    if (!m_gridModeEnabled || !m_gridRenderer) {
        return; // Let legacy system handle it
    }
    
    // Pass real trade to grid renderer
    if (m_gridRenderer) {
        m_gridRenderer->onTradeReceived(trade);
    }
    
    // Track metrics
    m_metrics.tradesProcessed++;
}

void GridIntegrationAdapter::onOrderBookUpdated(const OrderBook& orderBook) {
    // üîç DEBUG: Always log data flow
    static int totalOrderBookCallbacks = 0;
    if (++totalOrderBookCallbacks <= 5) {
        sLog_Network("üîç GRID ADAPTER ORDER BOOK #" << totalOrderBookCallbacks 
                  << " Bids:" << orderBook.bids.size() << " Asks:" << orderBook.asks.size()
                  << " gridMode=" << (m_gridModeEnabled ? "ENABLED" : "DISABLED"));
    }
    
    // üî• CRITICAL FIX: Only pass to grid when grid mode is enabled
    if (!m_gridModeEnabled || !m_gridRenderer) {
        return; // Let legacy system handle it
    }
    
    // Pass real order book to grid renderer
    if (m_gridRenderer) {
        m_gridRenderer->onOrderBookUpdated(orderBook);
    }
    
    // Track metrics
    m_metrics.heatmapUpdates++;
}

void GridIntegrationAdapter::onGridRefreshRequested() {
    if (m_gridModeEnabled) {
        sLog_Chart("üîÑ GRID REFRESH: Received refresh request from GPUDataAdapter");
        refreshGridData();
    }
}

// === CONVERSION HELPERS ===

Trade GridIntegrationAdapter::convertGPUPointToTrade(const GPUTypes::Point& point) {
    Trade trade;
    
    // Convert from screen coordinates back to world coordinates
    // This is a simplified conversion - in a real implementation you'd need
    // access to the current viewport transform
    trade.price = 50000.0 + (point.y - 300.0) * 100.0 / 300.0; // Rough price mapping
    trade.size = point.size * 0.1; // Scale point size to trade volume
    trade.timestamp = std::chrono::system_clock::time_point(
        std::chrono::milliseconds(static_cast<int64_t>(point.timestamp_ms)));
    trade.product_id = "BTC-USD";
    
    // Determine side from color (green = buy, red = sell)
    if (point.g > point.r) {
        trade.side = AggressorSide::Buy;
    } else {
        trade.side = AggressorSide::Sell;
    }
    
    return trade;
}

OrderBook GridIntegrationAdapter::convertQuadInstancesToOrderBook(
    const GPUTypes::QuadInstance* quads, size_t count) {
    
    OrderBook orderBook;
    orderBook.product_id = "BTC-USD";
    orderBook.timestamp = std::chrono::system_clock::now();
    
    // Sort quads by price and separate into bids/asks
    std::vector<std::pair<double, double>> bids, asks;
    
    for (size_t i = 0; i < count; ++i) {
        const auto& quad = quads[i];
        
        // Convert screen position back to price (simplified)
        double price = 50000.0 + (quad.y - 300.0) * 100.0 / 300.0;
        double size = quad.intensity * 10.0; // Scale intensity to size
        
        // Determine bid/ask from color
        if (quad.g > quad.r) {
            bids.emplace_back(price, size);
        } else {
            asks.emplace_back(price, size);
        }
    }
    
    // Sort and convert to OrderBook format
    std::sort(bids.begin(), bids.end(), std::greater<>());
    std::sort(asks.begin(), asks.end());
    
    for (const auto& [price, size] : bids) {
        orderBook.bids.push_back({price, size});
    }
    
    for (const auto& [price, size] : asks) {
        orderBook.asks.push_back({price, size});
    }
    
    return orderBook;
}

// === PERFORMANCE MONITORING ===

void GridIntegrationAdapter::updatePerformanceMetrics() {
    if (!m_performanceComparisonEnabled) return;
    
    // Calculate metrics
    QString metricsText = QString(
        "Grid Integration Performance:\n"
        "Trades processed: %1\n"
        "Heatmap updates: %2\n"
        "Candle updates: %3\n"
        "Memory usage: %4 MB\n"
        "Grid mode: %5"
    ).arg(m_metrics.tradesProcessed)
     .arg(m_metrics.heatmapUpdates)
     .arg(m_metrics.candleUpdates)
     .arg(m_metrics.memoryUsage / 1000000.0, 0, 'f', 2)
     .arg(m_gridModeEnabled ? "ENABLED" : "DISABLED");
    
    emit performanceMetricsUpdated(metricsText);
    
    // Log performance summary
    sLog_Performance("üìä GRID INTEGRATION METRICS:"
                  << "Trades:" << m_metrics.tradesProcessed
                  << "Heatmap:" << m_metrics.heatmapUpdates
                  << "Candles:" << m_metrics.candleUpdates
                  << "Mode:" << (m_gridModeEnabled ? "GRID" : "LEGACY"));
    
    // Reset counters for next interval
    m_metrics.reset();
}

void GridIntegrationAdapter::syncCoordinateSystems() {
    // Implementation for coordinate system synchronization
    // This would sync viewport and coordinate transforms between legacy and grid systems
    sLog_DebugCoords("üîÑ Coordinate system synchronization requested");
}

// ======= libs/gui/GridIntegrationAdapter.h =======
// ======= libs/gui/GridIntegrationAdapter.h =======
#pragma once
#include <QObject>
#include <QTimer>
#include "UnifiedGridRenderer.h"
// #include "BookmapStyleRenderer.h"  // REMOVED: Redundant with UnifiedGridRenderer
#include "gpudataadapter.h"
#include "tradedata.h"

/**
 * üéØ GRID INTEGRATION ADAPTER
 * 
 * Bridges your existing GPUDataAdapter system with the new Bookmap-style liquidity 
 * time series system. Allows gradual migration while preserving all existing functionality.
 * 
 * This adapter:
 * 1. Intercepts data from GPUDataAdapter
 * 2. Feeds it into the Bookmap-style renderer
 * 3. Provides backward compatibility
 * 4. Enables A/B testing between old grid and new Bookmap systems
 */
class GridIntegrationAdapter : public QObject {
    Q_OBJECT

public:
    explicit GridIntegrationAdapter(QObject* parent = nullptr);
    
    // üéØ INTEGRATION CONTROL
    Q_INVOKABLE void setGridMode(bool enabled);
    Q_INVOKABLE bool isGridModeEnabled() const { return m_gridModeEnabled; }
    
    // üéØ CONNECT TO EXISTING PIPELINE
    void connectToGPUAdapter(GPUDataAdapter* adapter);
    Q_INVOKABLE void connectToGridRenderer(QObject* renderer);
    // Q_INVOKABLE void connectToBookmapRenderer(QObject* renderer);  // REMOVED: Use UnifiedGridRenderer instead
    
    // üéØ PERFORMANCE COMPARISON
    Q_INVOKABLE void enablePerformanceComparison(bool enabled);
    Q_INVOKABLE QString getPerformanceMetrics() const;
    
    // üéØ GRID REFRESH: Re-process historical data when grid mode changes
    Q_INVOKABLE void refreshGridData();

public slots:
    // Data pipeline slots - connect to existing signals
    void onTradeDataReady(const GPUTypes::Point* points, size_t count);
    void onHeatmapDataReady(const GPUTypes::QuadInstance* quads, size_t count);
    void onCandleDataReady(const std::vector<CandleUpdate>& candles);
    void onViewportChanged(qint64 startTime, qint64 endTime, double minPrice, double maxPrice);
    
    // üî• CRITICAL FIX: Direct data slots for StreamController
    void onTradeReceived(const Trade& trade);
    void onOrderBookUpdated(const OrderBook& orderBook);
    
    // üéØ GRID REFRESH: Handle grid refresh requests
    void onGridRefreshRequested();

signals:
    // Performance monitoring
    void performanceMetricsUpdated(const QString& metrics);
    void gridModeChanged(bool enabled);

private slots:
    void updatePerformanceMetrics();

private:
    // Configuration
    bool m_gridModeEnabled = false;
    bool m_performanceComparisonEnabled = false;
    
    // Connected components
    GPUDataAdapter* m_gpuAdapter = nullptr;
    UnifiedGridRenderer* m_gridRenderer = nullptr;
    // BookmapStyleRenderer* m_bookmapRenderer = nullptr;  // REMOVED: Use UnifiedGridRenderer instead
    
    // Performance tracking
    QTimer* m_performanceTimer;
    struct PerformanceMetrics {
        int tradesProcessed = 0;
        int heatmapUpdates = 0;
        int candleUpdates = 0;
        double avgRenderTime = 0.0;
        size_t memoryUsage = 0;
        
        void reset() {
            tradesProcessed = 0;
            heatmapUpdates = 0;
            candleUpdates = 0;
            avgRenderTime = 0.0;
            memoryUsage = 0;
        }
    } m_metrics;
    
    // Data conversion helpers
    Trade convertGPUPointToTrade(const GPUTypes::Point& point);
    OrderBook convertQuadInstancesToOrderBook(const GPUTypes::QuadInstance* quads, size_t count);
    
    // Coordinate system bridging
    void syncCoordinateSystems();
};

// ======= libs/gui/mainwindow_gpu.cpp =======
#include "mainwindow_gpu.h"
#include "streamcontroller.h"
#include "statisticscontroller.h"
#include "gpuchartwidget.h"
#include "heatmapinstanced.h"
#include "candlestickbatched.h"
#include "chartmodecontroller.h"
#include "gpudataadapter.h"
#include <QQmlContext>
#include <QDebug>
#include <QDir>
#include <QFile>
#include <QTimer>
#include "GridIntegrationAdapter.h"

MainWindowGPU::MainWindowGPU(QWidget* parent) : QWidget(parent) {
    qDebug() << "üöÄ CREATING GPU TRADING TERMINAL!";
    
    setupUI();
    setupConnections();
    
    // Set window properties
    setWindowTitle("Sentinel - GPU Trading Terminal");
    resize(1400, 900);
    
    // Automatically start the subscription process once the event loop begins.
    // This ensures the window is fully constructed and shown before we start streaming.
    QTimer::singleShot(0, this, &MainWindowGPU::onSubscribe);
    
    qDebug() << "‚úÖ GPU MainWindow ready for 144Hz trading!";
}

MainWindowGPU::~MainWindowGPU() {
    qDebug() << "üõë MainWindowGPU destructor - cleaning up...";
    
    // Stop data streams first
    if (m_streamController) {
        m_streamController->stop();
    }
    
    // Disconnect all signals to prevent callbacks during destruction
    if (m_gpuChart && m_gpuChart->rootObject()) {
        disconnect(m_gpuChart->rootObject(), nullptr, this, nullptr);
    }
    
    // Clear QML context to prevent dangling references
    if (m_gpuChart) {
        m_gpuChart->setSource(QUrl());
    }
    
    qDebug() << "‚úÖ MainWindowGPU cleanup complete";
}

void MainWindowGPU::setupUI() {
    // üî• CREATE GPU CHART (QML) - Load from file system first
    m_gpuChart = new QQuickWidget(this);
    m_gpuChart->setResizeMode(QQuickWidget::SizeRootObjectToView);
    
    // Try file system path first to bypass resource issues
    QString qmlPath = QString("%1/libs/gui/qml/DepthChartView.qml").arg(QDir::currentPath());
    qDebug() << "üîç Trying QML path:" << qmlPath;
    
    if (QFile::exists(qmlPath)) {
        m_gpuChart->setSource(QUrl::fromLocalFile(qmlPath));
        qDebug() << "‚úÖ QML loaded from file system!";
    } else {
        qDebug() << "‚ùå QML file not found, trying resource path...";
        m_gpuChart->setSource(QUrl("qrc:/Sentinel/Charts/DepthChartView.qml"));
    }
    
    // Check if QML loaded successfully
    if (m_gpuChart->status() == QQuickWidget::Error) {
        qCritical() << "üö® QML FAILED TO LOAD!";
        qCritical() << "QML Errors:" << m_gpuChart->errors();
    }
    
    // Set default symbol in QML context
    QQmlContext* context = m_gpuChart->rootContext();
    context->setContextProperty("symbol", "BTC-USD");
    m_modeController = new ChartModeController(this);
    context->setContextProperty("chartModeController", m_modeController);
    
    // Control panel
    m_cvdLabel = new QLabel("CVD: N/A", this);
    m_statusLabel = new QLabel("üî¥ Disconnected", this);
    m_symbolInput = new QLineEdit("BTC-USD", this);
    m_subscribeButton = new QPushButton("üöÄ Subscribe", this);
    
    // üî• PHASE 1: STRESS TEST CONTROLS
    QPushButton* stressTestButton = new QPushButton("üî• 1M Point VBO Test", this);
    stressTestButton->setStyleSheet("QPushButton { background-color: #ff4444; color: white; padding: 8px 16px; font-size: 14px; font-weight: bold; }");
    
    connect(stressTestButton, &QPushButton::clicked, [this]() {
        qDebug() << "üöÄ LAUNCHING 1M POINT VBO STRESS TEST!";
        QQmlContext* context = m_gpuChart->rootContext();
        context->setContextProperty("stressTestMode", true);
        
        // Reload QML to trigger stress test
        QString qmlPath = QString("%1/libs/gui/qml/DepthChartView.qml").arg(QDir::currentPath());
        if (QFile::exists(qmlPath)) {
            m_gpuChart->setSource(QUrl::fromLocalFile(qmlPath));
        } else {
            m_gpuChart->setSource(QUrl("qrc:/Sentinel/Charts/DepthChartView.qml"));
        }
        
        // üî• CRITICAL FIX: Re-establish connections after QML reload
        QTimer::singleShot(100, [this]() {  // Small delay to ensure QML is loaded
            connectToGPUChart();
        });
        
        qDebug() << "üî• VBO STRESS TEST ACTIVATED!";
    });
    
    // Styling
    m_cvdLabel->setStyleSheet("QLabel { color: white; font-size: 16px; font-weight: bold; }");
    m_statusLabel->setStyleSheet("QLabel { color: red; font-size: 14px; }");
    m_symbolInput->setStyleSheet("QLineEdit { padding: 8px; font-size: 14px; }");
    m_subscribeButton->setStyleSheet("QPushButton { padding: 8px 16px; font-size: 14px; font-weight: bold; }");
    
    // Layout
    QVBoxLayout* mainLayout = new QVBoxLayout(this);
    
    // GPU chart takes most space
    mainLayout->addWidget(m_gpuChart, 1);
    
    // Control panel at bottom
    QGroupBox* controlGroup = new QGroupBox("üéØ Trading Controls");
    QHBoxLayout* controlLayout = new QHBoxLayout();
    controlLayout->addWidget(new QLabel("Symbol:"));
    controlLayout->addWidget(m_symbolInput);
    controlLayout->addWidget(m_subscribeButton);
    controlLayout->addWidget(stressTestButton);  // üî• STRESS TEST BUTTON
    controlLayout->addStretch();
    controlLayout->addWidget(m_cvdLabel);
    controlLayout->addWidget(m_statusLabel);
    controlGroup->setLayout(controlLayout);
    
    mainLayout->addWidget(controlGroup);
    setLayout(mainLayout);
}

void MainWindowGPU::setupConnections() {
    // Create data controllers (keep existing proven pipeline)
    m_streamController = new StreamController(this);

    m_statsController = new StatisticsController(this);

    m_gpuAdapter = new GPUDataAdapter(this);

    m_streamController->setGPUAdapter(m_gpuAdapter);

    m_gridAdapter = new GridIntegrationAdapter(this);
    m_gridAdapter->connectToGPUAdapter(m_gpuAdapter);  // Connect TO existing adapter
    m_gridAdapter->setGridMode(false);  // Start disabled

    qDebug() << "GridAdapter created and connected, mode:" << m_gridAdapter->isGridModeEnabled();
    
    // UI connections
    connect(m_subscribeButton, &QPushButton::clicked, this, &MainWindowGPU::onSubscribe);
    
    // Data pipeline connections
    connect(m_streamController, &StreamController::connected, this, [this]() {
        m_statusLabel->setText("üü¢ Connected");
        m_statusLabel->setStyleSheet("QLabel { color: green; font-size: 14px; }");
        m_subscribeButton->setText("üîó Connected");
        m_subscribeButton->setEnabled(false);
    });
    
    connect(m_streamController, &StreamController::disconnected, this, [this]() {
        m_statusLabel->setText("üî¥ Disconnected");
        m_statusLabel->setStyleSheet("QLabel { color: red; font-size: 14px; }");
        m_subscribeButton->setText("üöÄ Subscribe");
        m_subscribeButton->setEnabled(true);
    });
    
    // Stats pipeline
    connect(m_statsController, &StatisticsController::cvdUpdated, 
            this, &MainWindowGPU::onCVDUpdated);
    
    // üî• CRITICAL FIX: Establish GPU connections
    connectToGPUChart();
    
    qDebug() << "‚úÖ GPU MainWindow connections established";
}

void MainWindowGPU::onSubscribe() {
    QString symbol = m_symbolInput->text().trimmed().toUpper();
    if (symbol.isEmpty()) {
        qWarning() << "‚ùå Empty symbol input";
        return;
    }
    
    qDebug() << "üöÄ Subscribing to GPU chart:" << symbol;
    
    // Update QML context
    QQmlContext* context = m_gpuChart->rootContext();
    context->setContextProperty("symbol", symbol);
    
    // Start data stream
    std::vector<std::string> symbols = {symbol.toStdString()};
    m_streamController->start(symbols);
    
    qDebug() << "‚úÖ GPU subscription started for" << symbol;
}

void MainWindowGPU::onCVDUpdated(double cvd) {
    m_cvdLabel->setText(QString("CVD: %1").arg(cvd, 0, 'f', 2));
}

// üî• CRITICAL FIX: Helper method to establish GPU connections
void MainWindowGPU::connectToGPUChart() {
    qDebug() << "üîç ATTEMPTING TO CONNECT TO GPU CHART... (attempt" << m_connectionRetryCount + 1 << "/" << MAX_CONNECTION_RETRIES << ")";
    
    // Check retry limit
    if (m_connectionRetryCount >= MAX_CONNECTION_RETRIES) {
        qCritical() << "‚ùå MAX CONNECTION RETRIES REACHED - GPU chart connection failed!";
        return;
    }
    
    // Get the GPU chart widget from QML
    QQuickItem* qmlRoot = m_gpuChart->rootObject();
    if (!qmlRoot) {
        qWarning() << "‚ùå QML root object not found - retrying in 100ms...";
        m_connectionRetryCount++;
        QTimer::singleShot(100, this, &MainWindowGPU::connectToGPUChart);
        return;
    }
    
    qDebug() << "‚úÖ QML root found:" << qmlRoot;
    
    // üî• UNIFIED COMPONENT LOOKUP: Single strategy for all components
    GPUChartWidget* gpuChart = qmlRoot->findChild<GPUChartWidget*>("gpuChart");
    HeatmapBatched* heatmapLayer = qmlRoot->findChild<HeatmapBatched*>("heatmapLayer");
    CandlestickBatched* candleChart = qmlRoot->findChild<CandlestickBatched*>("candleChart");
    GridIntegrationAdapter* qmlGridAdapter = qmlRoot->findChild<GridIntegrationAdapter*>("gridIntegration");
    UnifiedGridRenderer* unifiedGridRenderer = qmlRoot->findChild<UnifiedGridRenderer*>("unifiedGridRenderer");
    
    // üî• VALIDATION: Check all required components are found
    if (!gpuChart) {
        qWarning() << "‚ùå GPUChartWidget not found - retrying in 200ms...";
        m_connectionRetryCount++;
        QTimer::singleShot(200, this, &MainWindowGPU::connectToGPUChart);
        return;
    }
    
    // üî• CLEAN CONNECTION PATTERN: Use GPUDataAdapter for all batched data
    bool allConnectionsSuccessful = true;
    
    // 1. GPU Chart - Trade scatter points (real-time)
    disconnect(m_streamController, &StreamController::tradeReceived,
              gpuChart, &GPUChartWidget::onTradeReceived);
    bool tradeConnection = connect(m_streamController, &StreamController::tradeReceived,
                                  gpuChart, &GPUChartWidget::onTradeReceived,
                                  Qt::QueuedConnection);
    allConnectionsSuccessful &= tradeConnection;
    
    // 2. Heatmap - Order book visualization (batched)
    if (heatmapLayer) {
        // Use StreamController for order book data (HeatmapBatched expects OrderBook)
        bool heatmapConnection = connect(m_streamController, &StreamController::orderBookUpdated,
                                         heatmapLayer, &HeatmapBatched::onOrderBookUpdated,
                                         Qt::QueuedConnection);
        allConnectionsSuccessful &= heatmapConnection;
        
        // Coordinate synchronization
        bool heatmapCoordConnection = connect(gpuChart, &GPUChartWidget::viewChanged,
                                             heatmapLayer, &HeatmapBatched::setTimeWindow,
                                             Qt::QueuedConnection);
        allConnectionsSuccessful &= heatmapCoordConnection;
        
        qDebug() << "üî• HEATMAP CONNECTIONS:"
                 << "Data:" << (heatmapConnection ? "SUCCESS" : "FAILED")
                 << "Coordinates:" << (heatmapCoordConnection ? "SUCCESS" : "FAILED");
    } else {
        qWarning() << "‚ö†Ô∏è HeatmapBatched not found - heatmap integration disabled";
    }
    
    // 3. Candlestick - OHLC candles (batched)
    if (candleChart) {
        bool candleConnection = connect(m_gpuAdapter, &GPUDataAdapter::candlesReady,
                                       candleChart, &CandlestickBatched::onCandlesReady,
                                       Qt::QueuedConnection);
        allConnectionsSuccessful &= candleConnection;
        
        // Coordinate synchronization
        bool candleCoordConnection = connect(gpuChart, &GPUChartWidget::viewChanged,
                                            candleChart, &CandlestickBatched::onViewChanged,
                                            Qt::QueuedConnection);
        allConnectionsSuccessful &= candleCoordConnection;
        
        qDebug() << "üïØÔ∏è CANDLESTICK CONNECTIONS:"
                 << "Data:" << (candleConnection ? "SUCCESS" : "FAILED")
                 << "Coordinates:" << (candleCoordConnection ? "SUCCESS" : "FAILED");
    } else {
        qWarning() << "‚ö†Ô∏è CandlestickBatched not found - candle integration disabled";
    }
    
    // üéØ GRID INTEGRATION CONNECTION
    if (qmlGridAdapter && m_gpuAdapter) {
        qmlGridAdapter->connectToGPUAdapter(m_gpuAdapter);
        qDebug() << "üéØ GRID INTEGRATION: Connected QML GridIntegrationAdapter to GPUDataAdapter";
        
        // üî• CRITICAL FIX: Connect StreamController directly to GridIntegrationAdapter
        bool streamToGridConnection = connect(m_streamController, &StreamController::tradeReceived,
                                            qmlGridAdapter, &GridIntegrationAdapter::onTradeReceived,
                                            Qt::QueuedConnection);
        bool orderBookToGridConnection = connect(m_streamController, &StreamController::orderBookUpdated,
                                               qmlGridAdapter, &GridIntegrationAdapter::onOrderBookUpdated,
                                               Qt::QueuedConnection);
        
        qDebug() << "üéØ GRID DATA PIPELINE:"
                 << "Trades:" << (streamToGridConnection ? "CONNECTED" : "FAILED")
                 << "OrderBook:" << (orderBookToGridConnection ? "CONNECTED" : "FAILED");
        
        // üîç DEBUG: Check connection status
        qDebug() << "üîç GRID CONNECTION DEBUG:"
                 << "QML adapter found:" << (qmlGridAdapter ? "YES" : "NO")
                 << "GPU adapter found:" << (m_gpuAdapter ? "YES" : "NO")
                 << "Grid mode:" << (qmlGridAdapter->isGridModeEnabled() ? "ENABLED" : "DISABLED");
    } else {
        qWarning() << "‚ö†Ô∏è Grid integration failed:"
                   << "QML adapter:" << (qmlGridAdapter ? "FOUND" : "NOT FOUND")
                   << "GPU adapter:" << (m_gpuAdapter ? "FOUND" : "NOT FOUND");
        
        // üîç DEBUG: List all child objects to help debugging
        qDebug() << "üîç QML CHILD OBJECTS:";
        for (auto child : qmlRoot->findChildren<QObject*>()) {
            qDebug() << "  -" << child->objectName() << "(" << child->metaObject()->className() << ")";
        }
    }
    
    // üî• FINAL STATUS REPORT
    if (allConnectionsSuccessful) {
        qDebug() << "‚úÖ GPU CHART FULLY CONNECTED TO REAL-TIME DATA PIPELINE!";
        qDebug() << "üéØ Connected components:"
                 << "GPUChart:" << (gpuChart ? "YES" : "NO")
                 << "Heatmap:" << (heatmapLayer ? "YES" : "NO")
                 << "Candles:" << (candleChart ? "YES" : "NO")
                 << "GridIntegration:" << (qmlGridAdapter ? "YES" : "NO");
        m_connectionRetryCount = 0;  // Reset retry counter on success
    } else {
        qWarning() << "‚ö†Ô∏è Some GPU connections failed - partial functionality";
    }
} 

// ======= libs/gui/mainwindow_gpu.h =======
#pragma once

#include <QWidget>
#include <QVBoxLayout>
#include <QHBoxLayout>
#include <QPushButton>
#include <QLabel>
#include <QLineEdit>
#include <QGroupBox>
#include <QtQuickWidgets/QQuickWidget>
#include "GridIntegrationAdapter.h"

// Forward declarations
class StreamController;
class StatisticsController;
class GPUDataAdapter;
class ChartModeController;

/**
 * üöÄ GPU-Powered Trading Terminal MainWindow
 * Clean, focused implementation for Phase 0 GPU rendering
 */
class MainWindowGPU : public QWidget {
    Q_OBJECT

public:
    explicit MainWindowGPU(QWidget* parent = nullptr);
    ~MainWindowGPU();

private slots:
    void onSubscribe();
    void onCVDUpdated(double cvd);

private:
    void setupUI();
    void setupConnections();
    void connectToGPUChart();  // üî• Helper to establish GPU connections

    // üî• GPU CHART - Core component
    QQuickWidget* m_gpuChart;
    
    // UI Controls
    QLabel* m_cvdLabel;
    QLabel* m_statusLabel;
    QLineEdit* m_symbolInput;
    QPushButton* m_subscribeButton;
    
    // Data controllers (keep existing proven pipeline)
    StreamController* m_streamController;
    StatisticsController* m_statsController;
    GPUDataAdapter* m_gpuAdapter{nullptr};
    ChartModeController* m_modeController{nullptr};
    GridIntegrationAdapter* m_gridAdapter{nullptr};
    
    // Connection retry tracking
    int m_connectionRetryCount{0};
    static const int MAX_CONNECTION_RETRIES = 50;  // 5 seconds max
};


// ======= libs/gui/heatmapinstanced.cpp =======
#include "heatmapinstanced.h"
#include "SentinelLogging.hpp"
#include "gpuchartwidget.h"  // For unified coordinate system
#include <QSGGeometry>
#include <QColor>
#include <algorithm>
#include <cmath>
#include <QDebug>

using std::max;
using std::min;

HeatmapBatched::HeatmapBatched(QQuickItem* parent)
    : QQuickItem(parent)
{
    // Enable item for rendering
    setFlag(ItemHasContents, true);
    
    // Reserve initial capacity to avoid reallocations
    m_bidInstances.reserve(m_maxBidLevels);
    m_askInstances.reserve(m_maxAskLevels);
    
    sLog_Init("üî• HeatmapBatched created - Phase 2 GPU rendering ready!");
}

void HeatmapBatched::updateBids(const QVariantList& bidLevels) {
    std::lock_guard<std::mutex> lock(m_dataMutex);
    
    m_bidInstances.clear();
    
    // üöÄ VIEWPORT BUFFER: Render order book data beyond visible range to prevent gaps
    double priceRange = m_maxPrice - m_minPrice;
    double bufferSize = priceRange * 0.5; // 50% buffer on each side
    double expandedMinPrice = m_minPrice - bufferSize;
    double expandedMaxPrice = m_maxPrice + bufferSize;
    
    for (const auto& level : bidLevels) {
        QVariantMap levelMap = level.toMap();
        double price = levelMap.value("price").toDouble();
        double size = levelMap.value("size").toDouble();
        
        // üöÄ EXPANDED RANGE: Include levels outside viewport for smooth panning
        if (price >= expandedMinPrice && price <= expandedMaxPrice && size > 0.0) {
            QuadInstance quad;
            QRectF geometry = calculateQuadGeometry(price, size);
            
            quad.x = geometry.x();
            quad.y = geometry.y();
            quad.width = geometry.width();
            quad.height = geometry.height();
            
            // Green color for bids with intensity-based alpha
            QColor color = calculateIntensityColor(size, true);
            quad.r = color.redF();
            quad.g = color.greenF();
            quad.b = color.blueF();
            quad.a = color.alphaF();
            
            quad.intensity = size * m_intensityScale;
            quad.price = price;
            quad.size = size;
            
            m_bidInstances.push_back(quad);
        }
    }
    
    m_bidsDirty = true;
    update();
}

void HeatmapBatched::updateAsks(const QVariantList& askLevels) {
    std::lock_guard<std::mutex> lock(m_dataMutex);
    
    m_askInstances.clear();
    
    // üöÄ VIEWPORT BUFFER: Render order book data beyond visible range to prevent gaps
    double priceRange = m_maxPrice - m_minPrice;
    double bufferSize = priceRange * 0.5; // 50% buffer on each side
    double expandedMinPrice = m_minPrice - bufferSize;
    double expandedMaxPrice = m_maxPrice + bufferSize;
    
    for (const auto& level : askLevels) {
        QVariantMap levelMap = level.toMap();
        double price = levelMap.value("price").toDouble();
        double size = levelMap.value("size").toDouble();
        
        // üöÄ EXPANDED RANGE: Include levels outside viewport for smooth panning
        if (price >= expandedMinPrice && price <= expandedMaxPrice && size > 0.0) {
            QuadInstance quad;
            QRectF geometry = calculateQuadGeometry(price, size);
            
            quad.x = geometry.x();
            quad.y = geometry.y();
            quad.width = geometry.width();
            quad.height = geometry.height();
            
            // Red color for asks with intensity-based alpha
            QColor color = calculateIntensityColor(size, false);
            quad.r = color.redF();
            quad.g = color.greenF();
            quad.b = color.blueF();
            quad.a = color.alphaF();
            
            quad.intensity = size * m_intensityScale;
            quad.price = price;
            quad.size = size;
            
            m_askInstances.push_back(quad);
        }
    }
    
    m_asksDirty = true;
    update();
}

void HeatmapBatched::updateOrderBook(const OrderBook& book) {
    std::lock_guard<std::mutex> lock(m_dataMutex);
    
    // üî• PHASE 2: CONVERT ORDER BOOK TO GPU INSTANCES
    convertOrderBookToInstances(book);
    
    m_bidsDirty = true;
    m_asksDirty = true;
    update();
}

void HeatmapBatched::onOrderBookUpdated(const OrderBook& book) {
    // üî• CRITICAL DEBUG: Confirm connection is working!
    // üîá REDUCED DEBUG: Only log every 50th order book to reduce spam
    static int orderBookCounter = 0;
    if (++orderBookCounter % 50 == 0) {
        sLog_GPU("üìä HEATMAP: Received order book with " << book.bids.size() << " bids, " << book.asks.size() << " asks");
    }
        
    updateOrderBook(book);
}

void HeatmapBatched::clearOrderBook() {
    std::lock_guard<std::mutex> lock(m_dataMutex);
    
    m_bidInstances.clear();
    m_askInstances.clear();
    
    m_bidsDirty = true;
    m_asksDirty = true;
    update();
}

void HeatmapBatched::setMaxQuads(int maxQuads) {
    m_maxQuads = maxQuads;
    // Adjust bid/ask limits proportionally
    m_maxBidLevels = maxQuads / 2;
    m_maxAskLevels = maxQuads / 2;
    
    m_bidInstances.reserve(m_maxBidLevels);
    m_askInstances.reserve(m_maxAskLevels);
}

void HeatmapBatched::setPriceRange(double minPrice, double maxPrice) {
    m_minPrice = minPrice;
    m_maxPrice = maxPrice;
    m_geometryDirty = true;
    update();
}

void HeatmapBatched::setIntensityScale(double scale) {
    m_intensityScale = scale;
    m_geometryDirty.store(true);
    update();
}

// üî• FINAL POLISH: Time window + price range synchronization for unified coordinates  
void HeatmapBatched::setTimeWindow(int64_t startMs, int64_t endMs, double minPrice, double maxPrice) {
    m_visibleTimeStart_ms = startMs;
    m_visibleTimeEnd_ms = endMs;
    m_timeWindowValid = (endMs > startMs);
    
    // üî• FINAL POLISH: Store the synchronized price range
    m_minPrice = minPrice;
    m_maxPrice = maxPrice;
    
    if (m_timeWindowValid) {
        // Trigger coordinate recalculation when time window changes
        m_geometryDirty.store(true);
        update();
        
        // üî• DEBUG: Verify the complete coordination is working
        static int syncCount = 0;
        if (syncCount++ < 5) {
            sLog_Chart("‚úÖüî• COMPLETE COORDINATION ESTABLISHED:" 
                     << "HeatMap synced to GPUChart - Time:" << startMs << "to" << endMs 
                     << "ms, Price:" << minPrice << "to" << maxPrice);
        }
    }
}

void HeatmapBatched::geometryChanged(const QRectF &newGeometry, const QRectF &oldGeometry) {
    // Note: Calling base class implementation (may not exist in this Qt version)
    m_geometryDirty = true;
}

QSGNode* HeatmapBatched::updatePaintNode(QSGNode* oldNode, UpdatePaintNodeData*) {
    // üöÄ PHASE 2: TWO-DRAW-CALL ARCHITECTURE (bids + asks)
    
    auto* rootNode = static_cast<QSGTransformNode*>(oldNode);
    if (!rootNode) {
        rootNode = new QSGTransformNode;
        m_bidNode = nullptr;  // Force recreation
        m_askNode = nullptr;  // Force recreation
    }
    
    // Skip rendering if widget not properly sized
    if (width() <= 0 || height() <= 0) {
        return rootNode;
    }
    
    std::lock_guard<std::mutex> lock(m_dataMutex);
    
    // üî• UPDATE BID GEOMETRY NODE (GREEN QUADS)
    if (m_bidsDirty || m_geometryDirty || !m_bidNode) {
        if (m_bidNode) {
            rootNode->removeChildNode(m_bidNode);
            delete m_bidNode;
        }
        
        if (!m_allBidInstances.empty()) { // üî• HISTORICAL HEATMAP: Use accumulated data
            m_bidNode = createQuadGeometryNode(m_allBidInstances, QColor(0, 255, 0, 180));
            rootNode->appendChildNode(m_bidNode);
        } else {
            m_bidNode = nullptr;
        }
        
        m_bidsDirty = false;
    }
    
    // üî• UPDATE ASK GEOMETRY NODE (RED QUADS)
    if (m_asksDirty || m_geometryDirty || !m_askNode) {
        if (m_askNode) {
            rootNode->removeChildNode(m_askNode);
            delete m_askNode;
        }
        
        if (!m_allAskInstances.empty()) { // üî• HISTORICAL HEATMAP: Use accumulated data
            m_askNode = createQuadGeometryNode(m_allAskInstances, QColor(255, 0, 0, 180));
            rootNode->appendChildNode(m_askNode);
        } else {
            m_askNode = nullptr;
        }
        
        m_asksDirty = false;
    }
    
    m_geometryDirty = false;
    return rootNode;
}

void HeatmapBatched::convertOrderBookToInstances(const OrderBook& book) {
    // üî• HISTORICAL HEATMAP: Don't clear - we want to accumulate history!
    // m_bidInstances.clear();  // REMOVED to preserve history
    // m_askInstances.clear();  // REMOVED to preserve history
    
    // Convert bids to green quads
    convertBidsToInstances(book.bids);
    
    // Convert asks to red quads  
    convertAsksToInstances(book.asks);
    
    // üî• HISTORICAL HEATMAP: Sort/limit the historical data if needed
    cleanupOldHeatmapPoints(); // Clean up old points to prevent unlimited memory growth
}

void HeatmapBatched::convertBidsToInstances(const std::vector<OrderBookLevel>& bids) {
    // Use current timestamp for this order book snapshot
    double currentTimestamp = QDateTime::currentMSecsSinceEpoch();
    
    // üöÄ EXPANDED BUFFER RANGE: Use the same buffer logic as updateBids for consistency
    double priceRange = m_maxPrice - m_minPrice;
    double bufferSize = priceRange * 0.5; // 50% buffer on each side
    double expandedMinPrice = m_minPrice - bufferSize;
    double expandedMaxPrice = m_maxPrice + bufferSize;
    
    for (const auto& level : bids) {
        // üöÄ EXPANDED RANGE: Include levels outside viewport for smooth panning
        if (level.price >= expandedMinPrice && level.price <= expandedMaxPrice && level.size > 0.0) {
            QuadInstance quad;
            
            // üî• FINAL POLISH: Store raw data instead of calculating screen coordinates
            // Screen coordinates will be calculated in createQuadGeometryNode every frame
            quad.rawTimestamp = currentTimestamp;
            quad.rawPrice = level.price;
            
            QColor color = calculateIntensityColor(level.size, true);
            quad.r = color.redF();
            quad.g = color.greenF();
            quad.b = color.blueF();
            quad.a = 0.8f;
            
            quad.intensity = level.size * m_intensityScale;
            quad.price = level.price;
            quad.size = level.size;
            quad.timestamp = currentTimestamp;
            
            m_allBidInstances.push_back(quad); // üî• HISTORICAL HEATMAP: Accumulate all bid points
            
            // üîá REDUCED DEBUG: Only log every 1000th bar to reduce spam
            static int bidBarCounter = 0;
            if (++bidBarCounter % 1000 == 0) {
                sLog_GPU(QString("üü¢ HISTORICAL BID POINT #%1: Raw Price %2 Timestamp: %3 Total accumulated: %4")
                         .arg(bidBarCounter).arg(level.price).arg(quad.rawTimestamp).arg(m_allBidInstances.size()));
            }
        }
    }
}

void HeatmapBatched::convertAsksToInstances(const std::vector<OrderBookLevel>& asks) {
    // Use current timestamp for this order book snapshot  
    double currentTimestamp = QDateTime::currentMSecsSinceEpoch();
    
    // üöÄ EXPANDED BUFFER RANGE: Use the same buffer logic as updateAsks for consistency
    double priceRange = m_maxPrice - m_minPrice;
    double bufferSize = priceRange * 0.5; // 50% buffer on each side
    double expandedMinPrice = m_minPrice - bufferSize;
    double expandedMaxPrice = m_maxPrice + bufferSize;
    
    for (const auto& level : asks) {
        // üöÄ EXPANDED RANGE: Include levels outside viewport for smooth panning
        if (level.price >= expandedMinPrice && level.price <= expandedMaxPrice && level.size > 0.0) {
            QuadInstance quad;
            
            // üî• FINAL POLISH: Store raw data instead of calculating screen coordinates
            // Screen coordinates will be calculated in createQuadGeometryNode every frame
            quad.rawTimestamp = currentTimestamp;
            quad.rawPrice = level.price;
            
            QColor color = calculateIntensityColor(level.size, false);
            quad.r = color.redF();
            quad.g = color.greenF();
            quad.b = color.blueF();
            quad.a = 0.8f;
            
            quad.intensity = level.size * m_intensityScale;
            quad.price = level.price;
            quad.size = level.size;
            quad.timestamp = currentTimestamp;
            
            m_allAskInstances.push_back(quad); // üî• HISTORICAL HEATMAP: Accumulate all ask points
            
            // üîá REDUCED DEBUG: Only log every 1000th bar to reduce spam
            static int askBarCounter = 0;
            if (++askBarCounter % 1000 == 0) {
                sLog_GPU(QString("üî¥ HISTORICAL ASK POINT #%1: Raw Price %2 Timestamp: %3 Total accumulated: %4")
                         .arg(askBarCounter).arg(level.price).arg(quad.rawTimestamp).arg(m_allAskInstances.size()));
            }
        }
    }
}

QPointF HeatmapBatched::worldToScreen(double timestamp_ms, double price) const {
    if (width() <= 0 || height() <= 0 || !m_timeWindowValid) {
        return QPointF(-1000, -1000); // Return off-screen point
    }

    double timeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
    if (timeRange <= 0) timeRange = 1.0;
    double timeRatio = (timestamp_ms - m_visibleTimeStart_ms) / timeRange;
    double x = timeRatio * width();

    double priceRange = m_maxPrice - m_minPrice;
    if (priceRange <= 0) priceRange = 1.0;
    double priceRatio = (price - m_minPrice) / priceRange;
    double y = (1.0 - priceRatio) * height();

    return QPointF(x, y);
}

QRectF HeatmapBatched::calculateQuadGeometry(double price, double size) const {
    // Map price to Y coordinate (inverse - higher price at top)
    double priceRange = m_maxPrice - m_minPrice;
    if (priceRange <= 0) priceRange = 1.0;  // Avoid division by zero
    
    double normalizedPrice = (price - m_minPrice) / priceRange;
    if (normalizedPrice < 0.0) normalizedPrice = 0.0;
    if (normalizedPrice > 1.0) normalizedPrice = 1.0;
    float y = static_cast<float>((1.0 - normalizedPrice) * height());
    
    // Map size to width (larger orders = wider quads) 
    float maxWidth = width() * 0.4f;  // Max 40% of widget width
    float minWidth = 2.0f;            // Minimum 2 pixels width
    float sizeWidth = static_cast<float>(size * m_intensityScale * 20.0);
    float quadWidth = sizeWidth;
    if (quadWidth < minWidth) quadWidth = minWidth;
    if (quadWidth > maxWidth) quadWidth = maxWidth;
    
    // Fixed height per price level (much smaller for cleaner visualization)
    float quadHeight = 3.0f;  // Fixed 3 pixel height for clean separation
    
    // Default positioning (will be adjusted per bid/ask in convert functions)
    float x = width() * 0.5f - quadWidth * 0.5f;  // Center initially
    
    return QRectF(x, y, quadWidth, quadHeight);
}

QColor HeatmapBatched::calculateIntensityColor(double size, bool isBid) const {
    // PHASE A2: Continuous color scale like reference image
    // Calculate normalized intensity (0.0 to 1.0)
    double intensity = std::min(1.0, size * m_intensityScale / 10.0);
    
    // Power-law scaling for better visual distribution
    intensity = std::pow(intensity, 0.6);  // Makes low values more visible
    
    float r, g, b;
    
    if (intensity < 0.2) {
        // Very low: Dark blue
        r = 0.0f;
        g = 0.0f + intensity * 2.0f;  // 0.0 ‚Üí 0.4
        b = 0.2f + intensity * 2.0f;  // 0.2 ‚Üí 0.6
    } else if (intensity < 0.5) {
        // Low-medium: Blue ‚Üí Cyan ‚Üí Green
        float t = (intensity - 0.2f) / 0.3f;  // 0.0 ‚Üí 1.0
        r = 0.0f;
        g = 0.4f + t * 0.4f;  // 0.4 ‚Üí 0.8
        b = 0.6f - t * 0.6f;  // 0.6 ‚Üí 0.0
    } else if (intensity < 0.8) {
        // Medium-high: Green ‚Üí Yellow
        float t = (intensity - 0.5f) / 0.3f;  // 0.0 ‚Üí 1.0
        r = t * 0.8f;         // 0.0 ‚Üí 0.8
        g = 0.8f;             // Stay bright green
        b = 0.0f;
    } else {
        // High: Yellow ‚Üí Orange ‚Üí Red
        float t = (intensity - 0.8f) / 0.2f;  // 0.0 ‚Üí 1.0
        r = 0.8f + t * 0.2f;  // 0.8 ‚Üí 1.0
        g = 0.8f - t * 0.8f;  // 0.8 ‚Üí 0.0
        b = 0.0f;
    }
    
    // Bid/Ask distinction: slightly shift hue
    if (isBid) {
        // Bids: Shift toward green/blue (cooler)
        g = std::min(1.0f, g * 1.1f);
        b = std::min(1.0f, b * 1.1f);
    } else {
        // Asks: Shift toward red/orange (warmer)
        r = std::min(1.0f, r * 1.1f);
    }
    
    // Alpha based on intensity (more intense = more opaque)
    float alpha = 0.4f + intensity * 0.6f;  // 0.4 ‚Üí 1.0
    
    return QColor::fromRgbF(r, g, b, alpha);
}

void HeatmapBatched::cleanupOldHeatmapPoints() {
    // üî• WALL OF LIQUIDITY: Manage historical points with time-based fading
    const size_t maxHistoricalPoints = static_cast<size_t>(m_maxQuads);
    double currentTime = QDateTime::currentMSecsSinceEpoch();
    const double fadeTimeMs = 30000.0; // 30 seconds fade window
    
    // üî• NEW: Apply time-based fading to old points before cleanup
    for (auto& quad : m_allBidInstances) {
        double age = currentTime - quad.timestamp;
        if (age > 0 && age < fadeTimeMs) {
            // Fade alpha based on age (newer = more opaque)
            float fadeFactor = 1.0f - (age / fadeTimeMs);
            quad.a = quad.a * fadeFactor * 0.8f; // Reduce base opacity for trailing effect
        }
    }
    
    for (auto& quad : m_allAskInstances) {
        double age = currentTime - quad.timestamp;
        if (age > 0 && age < fadeTimeMs) {
            // Fade alpha based on age (newer = more opaque)
            float fadeFactor = 1.0f - (age / fadeTimeMs);
            quad.a = quad.a * fadeFactor * 0.8f; // Reduce base opacity for trailing effect
        }
    }
    
    // Clean up bids if we exceed maximum (only remove oldest)
    if (m_allBidInstances.size() > maxHistoricalPoints) {
        size_t excess = m_allBidInstances.size() - maxHistoricalPoints;
        m_allBidInstances.erase(m_allBidInstances.begin(), m_allBidInstances.begin() + excess);
        //sLog_GPU(QString("üåä WAVE CLEANUP: Removed %1 oldest bid points, remaining: %2 historical levels")
                 //.arg(excess).arg(m_allBidInstances.size()));
    }
    
    // Clean up asks if we exceed maximum (only remove oldest)
    if (m_allAskInstances.size() > maxHistoricalPoints) {
        size_t excess = m_allAskInstances.size() - maxHistoricalPoints;
        m_allAskInstances.erase(m_allAskInstances.begin(), m_allAskInstances.begin() + excess);
        //sLog_GPU(QString("üåä WAVE CLEANUP: Removed %1 oldest ask points, remaining: %2 historical levels")
                 //.arg(excess).arg(m_allAskInstances.size()));
    }
}

void HeatmapBatched::sortAndLimitLevels() {
    // Sort bids by price (descending - highest first)
    std::sort(m_bidInstances.begin(), m_bidInstances.end(), 
             [](const QuadInstance& a, const QuadInstance& b) {
                 return a.price > b.price;
             });
    
    // Sort asks by price (ascending - lowest first)
    std::sort(m_askInstances.begin(), m_askInstances.end(),
             [](const QuadInstance& a, const QuadInstance& b) {
                 return a.price < b.price; 
             });
    
    // Limit to max levels for performance
    if (m_bidInstances.size() > m_maxBidLevels) {
        m_bidInstances.resize(m_maxBidLevels);
    }
    
    if (m_askInstances.size() > m_maxAskLevels) {
        m_askInstances.resize(m_maxAskLevels);
    }
}

QSGGeometryNode* HeatmapBatched::createQuadGeometryNode(const std::vector<QuadInstance>& instances, 
                                                         const QColor& baseColor) {
    if (instances.empty()) {
        return nullptr;
    }
    
    // PHASE A2: Use ColoredPoint2D to enable per-vertex gradient colors
    int vertexCount = instances.size() * 6;
    QSGGeometry* geometry = new QSGGeometry(QSGGeometry::defaultAttributes_ColoredPoint2D(), vertexCount);
    geometry->setDrawingMode(QSGGeometry::DrawTriangles);
    
    QSGGeometry::ColoredPoint2D* vertices = geometry->vertexDataAsColoredPoint2D();
    
    // Generate quad vertices for each instance (2 triangles = 6 vertices) with individual colors
    for (size_t i = 0; i < instances.size(); ++i) {
        const QuadInstance& quad_data = instances[i];

        // Recalculate screen position for current zoom/pan
        QPointF screenPos = worldToScreen(quad_data.rawTimestamp, quad_data.rawPrice);
        
        // PHASE A1: Adaptive screen-space sizing (larger when zoomed in to fill gaps)
        double timeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
        if (timeRange <= 0) timeRange = 60000.0; // Default 1 minute
        
        // Calculate zoom factor based on time window (smaller window = more zoomed in)
        double baseTimeWindow = 60000.0; // 1 minute reference
        double zoomFactor = std::max(1.0, baseTimeWindow / timeRange);
        
        // Adaptive point size: 2px minimum, scales up when zoomed in
        float adaptiveSize = std::min(8.0f, 2.0f * static_cast<float>(zoomFactor));
        
        float x1 = screenPos.x() - (adaptiveSize / 2.0f);
        float y1 = screenPos.y() - (adaptiveSize / 2.0f);
        float x2 = x1 + adaptiveSize;
        float y2 = y1 + adaptiveSize;
        
        // Convert stored RGBA to uchar for ColoredPoint2D
        unsigned char r = static_cast<unsigned char>(quad_data.r * 255);
        unsigned char g = static_cast<unsigned char>(quad_data.g * 255);
        unsigned char b = static_cast<unsigned char>(quad_data.b * 255);
        unsigned char a = static_cast<unsigned char>(quad_data.a * 255);
        
        // All 6 vertices use the same color (per-quad coloring)
        // Triangle 1: top-left, top-right, bottom-left
        vertices[i * 6 + 0].set(x1, y1, r, g, b, a);
        vertices[i * 6 + 1].set(x2, y1, r, g, b, a);
        vertices[i * 6 + 2].set(x1, y2, r, g, b, a);
        
        // Triangle 2: top-right, bottom-right, bottom-left  
        vertices[i * 6 + 3].set(x2, y1, r, g, b, a);
        vertices[i * 6 + 4].set(x2, y2, r, g, b, a);
        vertices[i * 6 + 5].set(x1, y2, r, g, b, a);
    }
    
    // Create geometry node
    QSGGeometryNode* node = new QSGGeometryNode;
    node->setGeometry(geometry);
    node->setFlag(QSGNode::OwnsGeometry);
    
    // Use vertex color material to respect per-vertex colors
    QSGVertexColorMaterial* material = new QSGVertexColorMaterial;
    node->setMaterial(material);
    node->setFlag(QSGNode::OwnsMaterial);
    
    return node;
} 

// ======= libs/gui/heatmapinstanced.h =======
#pragma once

#include <QQuickItem>
#include <QSGGeometryNode>
#include <QSGFlatColorMaterial>
#include <QVariantList>
#include <vector>
#include <mutex>
#include <atomic>
#include "tradedata.h"

class HeatmapBatched : public QQuickItem {
    Q_OBJECT
    QML_ELEMENT

public:
    explicit HeatmapBatched(QQuickItem* parent = nullptr);

    // üéØ PHASE 2: Order Book Data Interface
    Q_INVOKABLE void updateBids(const QVariantList& bidLevels);
    Q_INVOKABLE void updateAsks(const QVariantList& askLevels);
    Q_INVOKABLE void updateOrderBook(const OrderBook& book);
    Q_INVOKABLE void clearOrderBook();
    
    // Configuration
    Q_INVOKABLE void setMaxQuads(int maxQuads);
    Q_INVOKABLE void setPriceRange(double minPrice, double maxPrice);
    Q_INVOKABLE void setIntensityScale(double scale);
    
    // üî• FINAL POLISH: Time window + price range synchronization for unified coordinates
    Q_INVOKABLE void setTimeWindow(int64_t startMs, int64_t endMs, double minPrice, double maxPrice);

public slots:
    // Real-time order book updates
    void onOrderBookUpdated(const OrderBook& book);

protected:
    QSGNode* updatePaintNode(QSGNode* oldNode, UpdatePaintNodeData*) override;
    void geometryChanged(const QRectF &newGeometry, const QRectF &oldGeometry);

private:
    // üî• PHASE 2: QUAD INSTANCE DATA STRUCTURE
    struct QuadInstance {
        float x, y;           // Position (screen coordinates)
        float width, height;  // Quad dimensions
        float r, g, b, a;     // Color (RGBA)
        float intensity;      // Size/volume intensity
        double price;         // Original price (for sorting/filtering)
        double size;          // Original size (for intensity calculation)
        double timestamp;     // Timestamp for unified coordinate system
        
        // üî• FINAL POLISH: Store raw data for per-frame recalculation
        double rawTimestamp = 0.0;
        double rawPrice = 0.0;
    };

    // üöÄ SEPARATE BID/ASK BUFFERS (as specified in plan)
    std::vector<QuadInstance> m_bidInstances;   // Green quads (bids)
    std::vector<QuadInstance> m_askInstances;   // Red quads (asks)
    
    // üî• HISTORICAL HEATMAP: Store the full history of all heatmap points for accumulation
    std::vector<QuadInstance> m_allBidInstances;
    std::vector<QuadInstance> m_allAskInstances;
    
    // Thread-safe buffer management
    std::mutex m_dataMutex;
    std::atomic<bool> m_geometryDirty{true};
    std::atomic<bool> m_bidsDirty{false};
    std::atomic<bool> m_asksDirty{false};
    
    // üéØ VIEW PARAMETERS - Synchronized from GPUChartWidget (no hardcoded values)
    double m_minPrice = 107000.0;  // Will be updated via setTimeWindow()
    double m_maxPrice = 109000.0;
    int m_maxQuads = 1000000;        // 1M quads max (as per plan target)
    double m_intensityScale = 1.0;  // Volume intensity scaling
    
    // üî• NEW: Time window for unified coordinate system  
    int64_t m_visibleTimeStart_ms = 0;
    int64_t m_visibleTimeEnd_ms = 0;
    bool m_timeWindowValid = false;
    
    // Performance optimization
    size_t m_maxBidLevels = 100;    // Top 100 bid levels
    size_t m_maxAskLevels = 100;    // Top 100 ask levels
    
    // üî• REUSE NODES FOR PERFORMANCE (avoid allocation)
    QSGGeometryNode* m_bidNode = nullptr;   // Green quads node
    QSGGeometryNode* m_askNode = nullptr;   // Red quads node
    
    // Helper methods
    void convertOrderBookToInstances(const OrderBook& book);
    void convertBidsToInstances(const std::vector<OrderBookLevel>& bids);
    void convertAsksToInstances(const std::vector<OrderBookLevel>& asks);
    void cleanupOldHeatmapPoints(); // üî• HISTORICAL HEATMAP: Memory management
    QPointF worldToScreen(double timestamp_ms, double price) const; // üî• FINAL POLISH: Per-frame coordinate transformation
    QRectF calculateQuadGeometry(double price, double size) const;
    QColor calculateIntensityColor(double size, bool isBid) const;
    void updateBidGeometry();
    void updateAskGeometry();
    void sortAndLimitLevels();
    
    // GPU node creation
    QSGGeometryNode* createQuadGeometryNode(const std::vector<QuadInstance>& instances, 
                                          const QColor& baseColor);
}; 

// ======= libs/gui/gpuchartwidget.cpp =======
#include "gpuchartwidget.h"
#include "SentinelLogging.hpp"
#include <QSGGeometry>
#include <QSGFlatColorMaterial>
#include <QSGVertexColorMaterial>
#include <QVariantMap>
#include <QDebug>
#include <QDateTime>
#include <QMouseEvent>
#include <QWheelEvent>
#include <QElapsedTimer>
#include <cmath>
#include <algorithm>
#include <chrono>

GPUChartWidget::GPUChartWidget(QQuickItem* parent) 
    : QQuickItem(parent) {
    
    setFlag(ItemHasContents, true);
    setAcceptedMouseButtons(Qt::AllButtons);
    
    // üöÄ PHASE 1: Initialize triple-buffering
    for (int i = 0; i < BUFFER_COUNT; ++i) {
        m_gpuBuffers[i].points.reserve(m_maxPoints);
    }
    
    sLog_Init("üöÄ GPUChartWidget OPTION B REBUILD - CLEAN COORDINATE SYSTEM!");
    sLog_Init("üíæ Max Points:" << m_maxPoints << "| Time Span:" << m_timeSpanMs << "ms");
    sLog_Init("üéØ Single coordinate system - no test mode, no sine waves");
}

// üî• NEW: Handle widget resize - recalculate coordinates
void GPUChartWidget::geometryChanged(const QRectF &newGeometry, const QRectF &oldGeometry) {
    
    if (newGeometry.size() != oldGeometry.size() && 
        newGeometry.width() > 0 && newGeometry.height() > 0) {
        
        sLog_Chart("üìê Widget resized from" << oldGeometry.size() << "to" << newGeometry.size());
        
        // Mark geometry as dirty for coordinate recalculation
        m_geometryDirty.store(true);
        update();
    }
}

// üî• PHASE 1: REAL-TIME DATA INTEGRATION
void GPUChartWidget::onTradeReceived(const Trade& trade) {
    // üî• CONNECTION TEST: Verify this method is being called
    static int connectionTestCount = 0;
    if (++connectionTestCount <= 5) {
        sLog_Trades("üéØ onTradeReceived CALLED! #" << connectionTestCount 
                 << "Price:" << trade.price << "Side:" << (int)trade.side);
    }
    
    // üîç DEBUG: Log raw trade data to see what sides we're receiving
    static int rawTradeDebugCount = 0;
    if (++rawTradeDebugCount <= 10) {
        const char* rawSideStr = "UNKNOWN";
        if (trade.side == AggressorSide::Buy) rawSideStr = "BUY";
        else if (trade.side == AggressorSide::Sell) rawSideStr = "SELL";
        
        sLog_Trades("üìà RAW TRADE DATA #" << rawTradeDebugCount << ":"
                 << "Product:" << trade.product_id.c_str()
                 << "Side:" << rawSideStr
                 << "Price:" << trade.price
                 << "Size:" << trade.size);
    }
    
    // üìä TRADE DISTRIBUTION TRACKING
    static int totalBuys = 0, totalSells = 0, totalUnknown = 0;
    if (trade.side == AggressorSide::Buy) totalBuys++;
    else if (trade.side == AggressorSide::Sell) totalSells++;
    else totalUnknown++;
    
    // Log distribution every 25 trades
    static int distributionCounter = 0;
    if (++distributionCounter % 25 == 0) {
        int totalTrades = totalBuys + totalSells + totalUnknown;
        double buyPercent = totalTrades > 0 ? (totalBuys * 100.0 / totalTrades) : 0.0;
        double sellPercent = totalTrades > 0 ? (totalSells * 100.0 / totalTrades) : 0.0;
        
        sLog_Trades("üìä TRADE DISTRIBUTION SUMMARY:"
                 << "Total:" << totalTrades
                 << "Buys:" << totalBuys << "(" << QString::number(buyPercent, 'f', 1) << "%)"
                 << "Sells:" << totalSells << "(" << QString::number(sellPercent, 'f', 1) << "%)"
                 << "Unknown:" << totalUnknown);
    }
    
    appendTradeToVBO(trade);
}

void GPUChartWidget::onOrderBookUpdated(const OrderBook& book) {
    std::lock_guard<std::mutex> lock(m_dataMutex);
    m_currentOrderBook = book;
    
    // üî• ORDER BOOK VIEWPORT UPDATES: Use fastest update cadence for smooth viewport movement
    if (!book.bids.empty() || !book.asks.empty()) {
        auto currentTime = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
        updateTimeWindow(currentTime);
    }
}

void GPUChartWidget::appendTradeToVBO(const Trade& trade) {
    // Get current write buffer
    int writeIdx = m_writeBuffer.load();
    auto& buffer = m_gpuBuffers[writeIdx];
    
    if (buffer.inUse.load()) {
        sLog_Performance("‚ö†Ô∏è Buffer collision - frame skip (performance optimization)");
        return;
    }
    
    // Convert trade to GPU point
    GPUPoint point;
    convertTradeToGPUPoint(trade, point);
    
    // Thread-safe append
    std::lock_guard<std::mutex> lock(m_bufferMutex);
    buffer.points.push_back(point);
    m_allRenderPoints.push_back(point); // üî• GEMINI FIX: Accumulate all trades
    
    static int appendDebugCount = 0;
    if (appendDebugCount++ < 3) {
        // sLog_Gpu() << "üìù Trade appended to VBO - Buffer points:" << buffer.points.size();  // Too chatty!
    }
    
    // Cleanup old points if we exceed max
    if (buffer.points.size() > static_cast<size_t>(m_maxPoints)) {
        cleanupOldTrades();
    }
    
    buffer.dirty.store(true);
    m_geometryDirty.store(true);
    
    // üéØ PHASE 2: SMOOTH UPDATES: Every 10 trades for better visual smoothness
    static int tradeCount = 0;
    if (++tradeCount >= 10) { // üöÄ SMOOTH: Every 10 trades for real-time feel
        swapBuffers();
        tradeCount = 0;
        // sLog_Gpu() << "üîÑ Periodic buffer swap after 10 trades";  // Too chatty!
    }
    
    update(); // Trigger GPU update
}

void GPUChartWidget::convertTradeToGPUPoint(const Trade& trade, GPUPoint& point) {
    // üî• TIME-SERIES COORDINATE SYSTEM: X=time, Y=price
    auto timestamp_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
        trade.timestamp.time_since_epoch()).count();
    
    // üî• NEW: Update time window for new trade (Option B)
    updateTimeWindow(timestamp_ms);
    
    // üéØ UNIFIED PRICE RANGE: Auto-adjust to real BTC range
    if (trade.price > 80000.0) {
        updateDynamicPriceRange(trade.price);
    }
    
    // üöÄ TIME-SERIES MAPPING: Store raw data for coordinate transformation
    point.rawTimestamp = static_cast<double>(timestamp_ms);
    point.rawPrice = trade.price;
    
    // üî• SCREEN COORDINATE CALCULATION: Use new stateless system
    QPointF screenPos = worldToScreen(timestamp_ms, trade.price);
    point.x = static_cast<float>(screenPos.x());
    point.y = static_cast<float>(screenPos.y());
    
    // üé® THREE-COLOR PRICE CHANGE SYSTEM: Professional trading terminal style
    const char* changeStr = "FIRST";
    if (!m_hasPreviousPrice) {
        // First trade - use neutral yellow
        point.r = 1.0f; point.g = 1.0f; point.b = 0.0f; point.a = 0.8f; // YELLOW for FIRST
        changeStr = "FIRST";
        m_previousTradePrice = trade.price;
        m_hasPreviousPrice = true;
    } else {
        // Compare with previous price for uptick/downtick/no-change
        if (trade.price > m_previousTradePrice) {
            point.r = 0.0f; point.g = 1.0f; point.b = 0.0f; point.a = 0.8f; // GREEN for UPTICK
            changeStr = "UPTICK";
        } else if (trade.price < m_previousTradePrice) {
            point.r = 1.0f; point.g = 0.0f; point.b = 0.0f; point.a = 0.8f; // RED for DOWNTICK
            changeStr = "DOWNTICK";
        } else {
            point.r = 1.0f; point.g = 1.0f; point.b = 0.0f; point.a = 0.8f; // YELLOW for NO CHANGE
            changeStr = "NO_CHANGE";
        }
        m_previousTradePrice = trade.price;
    }

    point.size = 4.0f; // Trade dot size
    point.timestamp_ms = timestamp_ms;
    
    // üîç DEBUG: Log every trade's color assignment
    static int tradeColorDebugCount = 0;
    if (++tradeColorDebugCount <= 10) {
        sLog_Trades("üé® TRADE COLOR DEBUG #" << tradeColorDebugCount << ":"
                 << "Change:" << changeStr
                 << "Price:" << trade.price << "(prev:" << m_previousTradePrice << ")"
                 << "Size:" << trade.size
                 << "Color RGBA:(" << point.r << "," << point.g << "," << point.b << "," << point.a << ")");
    }
    
    // Debug first few coordinate mappings to verify system
    static int tradeDebugCount = 0;
    if (++tradeDebugCount < 5) {
        // sLog_DebugCoords() << "üéØ OPTION B TIME-SERIES Trade:" << "Price:" << trade.price 
        //          << "Time:" << timestamp_ms << "‚Üí Screen(" << point.x << "," << point.y << ")"
        //          << "Window:" << m_visibleTimeStart_ms << "to" << m_visibleTimeEnd_ms;  // Too chatty!
    }
}

// üéØ PHASE 2: Dynamic Price Range Implementation
void GPUChartWidget::updateDynamicPriceRange(double newPrice) {
    m_lastTradePrice = newPrice;
    m_priceUpdateCount++;
    
    // üöÄ USER CONTROL PRIORITY: Don't auto-center if user is manually controlling viewport
    // This prevents the annoying "snap back to center" behavior when price jumps
    if (!m_autoScrollEnabled || m_isDragging) {
        // User is in control - don't auto-adjust the price range
        return;
    }
    
    // Update range every 5 trades to prevent excessive recalculation
    if (m_priceUpdateCount % 5 == 0) {
        // Center the range around the recent price
        double halfRange = m_dynamicRangeSize / 2.0;
        double newMinPrice = newPrice - halfRange;
        double newMaxPrice = newPrice + halfRange;
        
        // Only update if the new range is significantly different (prevents jitter)
        double currentCenter = (m_minPrice + m_maxPrice) / 2.0;
        double priceDelta = std::abs(newPrice - currentCenter);
        
        if (priceDelta > m_dynamicRangeSize * 0.1) { // Update if price moves >10% of range
            m_minPrice = newMinPrice;
            m_maxPrice = newMaxPrice;
            
            sLog_Chart("üéØ DYNAMIC RANGE UPDATED: Price" << newPrice 
                     << "‚Üí Range:" << m_minPrice << "-" << m_maxPrice 
                     << "Size:" << (m_maxPrice - m_minPrice) 
                     << "Delta:" << priceDelta);
            
            // üî• THE FINAL FIX: Broadcast the new price range to the heatmap
            emit viewChanged(m_visibleTimeStart_ms, m_visibleTimeEnd_ms, m_minPrice, m_maxPrice);
        }
    }
}

bool GPUChartWidget::isInCurrentPriceRange(double price) const {
    return price >= m_minPrice && price <= m_maxPrice;
}

// üéØ PHASE 2: New Public Methods
void GPUChartWidget::enableDynamicPriceZoom(bool enabled) {
    m_dynamicPriceZoom = enabled;
    if (!enabled) {
        // Restore static range
        m_minPrice = m_staticMinPrice;
        m_maxPrice = m_staticMaxPrice;
    }
    sLog_Chart("üéØ Dynamic price zoom" << (enabled ? "ENABLED" : "DISABLED"));
}

void GPUChartWidget::setDynamicPriceRange(double rangeSize) {
    m_dynamicRangeSize = rangeSize;
    sLog_Chart("üéØ Dynamic price range size set to:" << rangeSize);
    
    // If we have a recent price, update the range immediately
    if (m_lastTradePrice > 0.0) {
        updateDynamicPriceRange(m_lastTradePrice);
    }
}

void GPUChartWidget::resetPriceRange() {
    if (m_dynamicPriceZoom && m_lastTradePrice > 0.0) {
        // Reset to dynamic range centered on last trade
        updateDynamicPriceRange(m_lastTradePrice);
    } else {
        // Reset to static range
        m_minPrice = m_staticMinPrice;
        m_maxPrice = m_staticMaxPrice;
    }
    sLog_Chart("üéØ Price range reset to:" << m_minPrice << "-" << m_maxPrice);
}

// üéØ PHASE 2: Safe Color Implementation (avoids dual-node crashes)
QColor GPUChartWidget::determineDominantTradeColor(const std::vector<GPUPoint>& points) const {
    if (points.empty()) {
        return QColor(128, 128, 128, 200); // Gray fallback
    }
    
    // Count recent buy vs sell activity (last 10 points for responsiveness)
    size_t checkCount = std::min(static_cast<size_t>(10), points.size());
    int buyCount = 0;
    int sellCount = 0;
    
    // Check the most recent points (end of vector)
    for (size_t i = points.size() - checkCount; i < points.size(); ++i) {
        const auto& point = points[i];
        
        // Detect color based on RGB values stored in GPUPoint
        if (point.g > 0.8f && point.r < 0.2f) {
            buyCount++; // Green = Buy
        } else if (point.r > 0.8f && point.g < 0.2f) {
            sellCount++; // Red = Sell
        }
    }
    
    // Return dominant color with good visibility
    if (buyCount > sellCount) {
        return QColor(0, 255, 0, 220); // Bright green for buy dominance
    } else if (sellCount > buyCount) {
        return QColor(255, 0, 0, 220); // Bright red for sell dominance
    } else {
        return QColor(255, 255, 0, 200); // Yellow for balanced activity
    }
}

void GPUChartWidget::cleanupOldTrades() {
    // üéØ FIXED: Only clean up if we have too many points, not by time
    int writeIdx = m_writeBuffer.load();
    auto& buffer = m_gpuBuffers[writeIdx];
    
    // Only remove oldest trades if we exceed maximum
    if (buffer.points.size() > static_cast<size_t>(m_maxPoints)) {
        size_t excess = buffer.points.size() - m_maxPoints;
        buffer.points.erase(buffer.points.begin(), buffer.points.begin() + excess);
        // sLog_Gpu() << "üßπ Cleaned up" << excess << "old trades, remaining:" << buffer.points.size();  // Too chatty!
    }
    
    // üî• GEMINI FIX: Also clean up accumulated points
    if (m_allRenderPoints.size() > static_cast<size_t>(m_maxPoints)) {
        size_t excess = m_allRenderPoints.size() - m_maxPoints;
        m_allRenderPoints.erase(m_allRenderPoints.begin(), m_allRenderPoints.begin() + excess);
        // sLog_Gpu() << "üßπ Cleaned up" << excess << "accumulated points, remaining:" << m_allRenderPoints.size();  // Too chatty!
    }
}

void GPUChartWidget::swapBuffers() {
    // Atomic triple-buffer swap
    int oldWrite = m_writeBuffer.load();
    int oldRead = m_readBuffer.load();
    
    // Find the free buffer
    int newRead = oldWrite;
    int newWrite = 3 - oldWrite - oldRead; // The remaining buffer
    
    m_readBuffer.store(newRead);
    m_writeBuffer.store(newWrite);
    
    // üîá REDUCED DEBUG: Only log every 50th swap to reduce spam
    static int swapCounter = 0;
    if (++swapCounter % 50 == 0) {
        // sLog_Gpu() << "üîÑ Buffer swap: write" << oldWrite << "‚Üí" << newWrite 
        //          << ", read" << oldRead << "‚Üí" << newRead;  // Too chatty!
    }
}

// üî• OPTION B: CLEAN REBUILD - SINGLE COORDINATE SYSTEM WITH PER-VERTEX COLORS
QSGNode* GPUChartWidget::updatePaintNode(QSGNode* oldNode, UpdatePaintNodeData*) {
    // üöÄ OPTION B: Start simple - render trades from VBO only
    if (width() <= 0 || height() <= 0) {
        delete oldNode;
        return nullptr;
    }
    
    // üî• VBO MODE: Use triple-buffering for real data
    int readIdx = m_readBuffer.load();
    auto& readBuffer = m_gpuBuffers[readIdx];
    
    // Start with a single dot at fixed position for testing
    if (readBuffer.points.empty()) {
        sLog_Render("‚ö†Ô∏è No trade data yet - returning nullptr");
        delete oldNode;
        return nullptr;
    }
    
    readBuffer.inUse.store(true);
    std::lock_guard<std::mutex> lock(m_bufferMutex); // üî• GEMINI FIX: Thread safety lock
    
    // Create or reuse geometry node
    auto* node = static_cast<QSGGeometryNode*>(oldNode);
    if (!node) {
        node = new QSGGeometryNode;
        
        // üîµ CIRCLE GEOMETRY: Use 8 triangles per circle (24 vertices per trade)
        QSGGeometry* geometry = new QSGGeometry(QSGGeometry::defaultAttributes_ColoredPoint2D(), m_allRenderPoints.size() * 24);
        geometry->setDrawingMode(QSGGeometry::DrawTriangles);
        node->setGeometry(geometry);
        node->setFlag(QSGNode::OwnsGeometry);
        
        // üî• BREAKTHROUGH: QSGVertexColorMaterial reads per-vertex colors!
        QSGVertexColorMaterial* material = new QSGVertexColorMaterial;
        material->setFlag(QSGMaterial::Blending); // Enable alpha blending
        node->setMaterial(material);
        node->setFlag(QSGNode::OwnsMaterial);
        
        sLog_RenderDetail("üîµ CREATED CIRCLE GEOMETRY: Three-color price change system with smooth circles!");
    }
    
    if (readBuffer.dirty.load() || m_geometryDirty.load()) {
        // üöÄ PHASE 4: GPU UPLOAD PROFILER - Reset frame counter
        m_bytesUploadedThisFrame = 0;
        
        // Update geometry with new trade data
        QSGGeometry* geometry = node->geometry();
        geometry->allocate(m_allRenderPoints.size() * 24); // üîµ CIRCLES: 8 triangles √ó 3 vertices = 24 per circle
        
        // üîµ CIRCLE GEOMETRY: Use ColoredPoint2D vertices for smooth circles!
        QSGGeometry::ColoredPoint2D* vertices = geometry->vertexDataAsColoredPoint2D();
        const float circleRadius = 6.0f; // 6 pixel radius circles (was 8px rectangles)
        const int trianglesPerCircle = 8; // Octagon approximation for performance
        
        for (size_t i = 0; i < m_allRenderPoints.size(); ++i) {
            const auto& point = m_allRenderPoints[i];
            size_t baseIndex = i * 24; // 24 vertices per circle
            
            // üî• NEW: Use clean stateless coordinate system
            QPointF screenPos = worldToScreen(point.rawTimestamp, point.rawPrice);
            
            float centerX = screenPos.x();
            float centerY = screenPos.y();
            
            // üé® CONVERT RGB TO UCHAR: ColoredPoint2D expects separate RGBA values
            uchar red   = static_cast<uchar>(point.r * 255);
            uchar green = static_cast<uchar>(point.g * 255);
            uchar blue  = static_cast<uchar>(point.b * 255);
            uchar alpha = static_cast<uchar>(point.a * 255);
            
            // üîµ CREATE CIRCLE: Triangle fan from center to perimeter
            for (int t = 0; t < trianglesPerCircle; ++t) {
                size_t triangleBase = baseIndex + (t * 3);
                
                // Calculate angles for this triangle
                float angle1 = (t * 2.0f * M_PI) / trianglesPerCircle;
                float angle2 = ((t + 1) * 2.0f * M_PI) / trianglesPerCircle;
                
                // Center vertex
                vertices[triangleBase + 0].set(centerX, centerY, red, green, blue, alpha);
                
                // First perimeter vertex
                float x1 = centerX + circleRadius * cos(angle1);
                float y1 = centerY + circleRadius * sin(angle1);
                vertices[triangleBase + 1].set(x1, y1, red, green, blue, alpha);
                
                // Second perimeter vertex
                float x2 = centerX + circleRadius * cos(angle2);
                float y2 = centerY + circleRadius * sin(angle2);
                vertices[triangleBase + 2].set(x2, y2, red, green, blue, alpha);
            }
        }
        
        // üöÄ PHASE 4: GPU UPLOAD PROFILER - Track bytes sent to GPU
        size_t vertexCount = m_allRenderPoints.size() * 24;
        size_t bytesUploaded = vertexCount * sizeof(QSGGeometry::ColoredPoint2D);
        m_bytesUploadedThisFrame += bytesUploaded;
        m_totalBytesUploaded.fetch_add(bytesUploaded, std::memory_order_relaxed);
        
        // Calculate bandwidth and check budget
        m_mbPerFrame = static_cast<double>(m_bytesUploadedThisFrame) / 1'000'000.0;
        double estimatedFPS = 60.0; // Assume 60 FPS for trade scatter
        double bandwidthMBps = m_mbPerFrame * estimatedFPS;
        
        // Warn if exceeding PCIe budget
        if (bandwidthMBps > PCIE_BUDGET_MB_PER_SECOND) {
            m_bandwidthWarnings.fetch_add(1, std::memory_order_relaxed);
            static int warningCount = 0;
            if (++warningCount <= 5) { // Limit warning spam
                sLog_Performance("‚ö†Ô∏è TRADE SCATTER PCIe WARNING #" << warningCount
                          << "Current:" << QString::number(bandwidthMBps, 'f', 1) << "MB/s"
                          << "Budget:" << PCIE_BUDGET_MB_PER_SECOND << "MB/s"
                          << "Frame:" << QString::number(m_mbPerFrame, 'f', 3) << "MB"
                          << "Points:" << m_allRenderPoints.size());
            }
        }
        
        // üöÄ PHASE 4: Update debug display with profiler metrics
        updateDebugInfo();
        
        // Debug logging for first few frames
        static int profileCount = 0;
        if (++profileCount <= 10 || profileCount % 100 == 0) {
            sLog_Performance("üìä TRADE SCATTER GPU PROFILER #" << profileCount
                     << "Points:" << m_allRenderPoints.size()
                     << "Frame:" << QString::number(m_mbPerFrame, 'f', 3) << "MB"
                     << "Bandwidth:" << QString::number(bandwidthMBps, 'f', 1) << "MB/s"
                     << "Total uploaded:" << (m_totalBytesUploaded.load() / 1'000'000) << "MB");
        }
        
        node->markDirty(QSGNode::DirtyGeometry);
        readBuffer.dirty.store(false);
        m_geometryDirty.store(false);
        
        // üîç DEBUG: Check what colors are actually being rendered
        static int debugCount = 0;
        if (debugCount++ < 5 && !m_allRenderPoints.empty()) {
            // Count price change types in current buffer
            int uptickCount = 0, downtickCount = 0, noChangeCount = 0;
            for (const auto& point : m_allRenderPoints) {
                if (point.g > 0.8f && point.r < 0.2f) uptickCount++;        // Green = Uptick
                else if (point.r > 0.8f && point.g < 0.2f) downtickCount++;  // Red = Downtick  
                else noChangeCount++;                                         // Yellow = No Change
            }
            
            sLog_RenderDetail("üîµ CIRCLE RENDER DEBUG #" << debugCount << ":"
                     << "Total circles:" << m_allRenderPoints.size()
                     << "UPTICKS:" << uptickCount << "(green)"
                     << "DOWNTICKS:" << downtickCount << "(red)"  
                     << "NO_CHANGE:" << noChangeCount << "(yellow)");
                     
            // Show first few individual circle colors
            for (int i = 0; i < std::min(3, (int)m_allRenderPoints.size()); ++i) {
                const auto& point = m_allRenderPoints[i];
                const char* colorName = "NO_CHANGE";
                if (point.g > 0.8f && point.r < 0.2f) colorName = "GREEN-UPTICK";
                else if (point.r > 0.8f && point.g < 0.2f) colorName = "RED-DOWNTICK";
                else if (point.r > 0.8f && point.g > 0.8f) colorName = "YELLOW-NO_CHANGE";
                
                sLog_RenderDetail("  Circle" << i << ":" << colorName 
                         << "RGBA(" << point.r << "," << point.g << "," << point.b << "," << point.a << ")"
                         << "Price:" << point.rawPrice);
            }
        }
    }
    
    readBuffer.inUse.store(false);
    return node;
}

// üöÄ PHASE 1: Configuration Methods
void GPUChartWidget::setMaxPoints(int maxPoints) {
    m_maxPoints = maxPoints;
    sLog_Chart("üéØ Max points set to:" << maxPoints);
}

void GPUChartWidget::setTimeSpan(double timeSpanSeconds) {
    m_timeSpanMs = timeSpanSeconds * 1000.0;
    sLog_Chart("‚è±Ô∏è Time span set to:" << timeSpanSeconds << "seconds");
}

void GPUChartWidget::setPriceRange(double minPrice, double maxPrice) {
    m_minPrice = minPrice;
    m_maxPrice = maxPrice;
    sLog_Chart("üìä Price range set to:" << minPrice << "-" << maxPrice);
}

void GPUChartWidget::addTrade(const Trade& trade) {
    // Legacy interface - redirect to slot
    onTradeReceived(trade);
}

void GPUChartWidget::updateOrderBook(const OrderBook& book) {
    // Legacy interface - redirect to slot
    onOrderBookUpdated(book);
}

void GPUChartWidget::clearTrades() {
    std::lock_guard<std::mutex> lock(m_bufferMutex);
    
    // Clear all buffers
    for (auto& buffer : m_gpuBuffers) {
        buffer.points.clear();
        buffer.dirty.store(true);
    }
    
    // üî• GEMINI FIX: Also clear accumulated points
    m_allRenderPoints.clear();
    
    m_geometryDirty.store(true);
    update();
    
    sLog_Chart("üßπ All GPU buffers and accumulated points cleared!");
}

// üî• REMOVED: mapToScreen function - replaced with worldToScreen in Option B

// üöÄ PHASE 4: PAN/ZOOM INTERACTION METHODS

void GPUChartWidget::mousePressEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton) {
        m_interactionTimer.start();
        m_isDragging = true;
        m_lastMousePos = event->position();
        
        // üöÄ USER CONTROL: Disable auto-centering and auto-scroll immediately
        m_autoScrollEnabled = false;
        m_dynamicPriceZoom = false;
        sLog_Camera("üñ±Ô∏è User control active - manual viewport navigation enabled");
        
        event->accept();
    }
}

void GPUChartWidget::mouseMoveEvent(QMouseEvent* event) {
    if (m_isDragging) {
        // üöÄ USER CONTROL: Ensure auto-systems stay disabled during drag
        m_autoScrollEnabled = false;
        m_dynamicPriceZoom = false;
        
        QPointF currentPos = event->position();
        QPointF delta = currentPos - m_lastMousePos;
        
        if (width() > 0 && height() > 0 && m_timeWindowInitialized) {
            // üî• OPTION B: Pan by moving the time window directly
            double timeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
            
            // Convert pixel delta to time duration
            double pixelsToTimeRatio = timeRange / width();
            double timeDelta = delta.x() * pixelsToTimeRatio;
            
            // Move time window (subtract for natural drag direction)
            m_visibleTimeStart_ms -= timeDelta;
            m_visibleTimeEnd_ms -= timeDelta;
            emit viewChanged(m_visibleTimeStart_ms, m_visibleTimeEnd_ms, m_minPrice, m_maxPrice); // üî• FINAL POLISH: Include price range
            
            // Price range panning
            double priceRange = m_maxPrice - m_minPrice;
            double pixelsToPriceRatio = priceRange / height();
            double priceDelta = delta.y() * pixelsToPriceRatio;
            
            // Move price range (add for natural drag direction)
            m_minPrice += priceDelta;
            m_maxPrice += priceDelta;
            
            m_lastMousePos = currentPos;
            m_geometryDirty.store(true);
            
            // Throttle updates for smooth performance
            static int updateCounter = 0;
            if (++updateCounter % 2 == 0) {
                update();
            }
        }
        
        // Debug camera movement
        static int panDebugCount = 0;
        if (panDebugCount++ < 3) {
            sLog_Camera("üé• CAMERA PAN: Time window:" << m_visibleTimeStart_ms << "to" << m_visibleTimeEnd_ms
                     << "Price range:" << m_minPrice << "to" << m_maxPrice);
        }
        
        event->accept();
    }
}

void GPUChartWidget::mouseReleaseEvent(QMouseEvent* event) {
    if (event->button() == Qt::LeftButton && m_isDragging) {
        m_isDragging = false;
        
        // üî• REDUCED DEBUG: Only log performance achievements
        double latency = calculateInteractionLatency();
        if (latency < 5.0) {
            static int panSuccessCount = 0;
            if (panSuccessCount++ < 3) {
                sLog_Performance("‚úÖ PHASE 4 SUCCESS: Pan latency" << latency << "ms < 5ms target!");
            }
        }
        
        event->accept();
    }
}

void GPUChartWidget::wheelEvent(QWheelEvent* event) {
    // üöÄ USER CONTROL: Disable auto-centering when user manually zooms
    m_autoScrollEnabled = false;
    m_dynamicPriceZoom = false;
    
    if (!m_timeWindowInitialized || width() <= 0 || height() <= 0) {
        event->accept();
        return;
    }
    
    // üî• ENHANCED ZOOM: Support both time (X) and price (Y) axis zooming
    const double ZOOM_SENSITIVITY = 0.001; // Tuned for time window
    const double MIN_TIME_RANGE = 1000.0;  // 1 second minimum
    const double MAX_TIME_RANGE = 600000.0; // 10 minutes maximum
    const double MIN_PRICE_RANGE = 1.0;     // $1 minimum price range
    const double MAX_PRICE_RANGE = 10000.0; // $10k maximum price range
    
    // Calculate zoom delta
    double delta = event->angleDelta().y() * ZOOM_SENSITIVITY;
    double zoomFactor = 1.0 - delta; // Invert for natural zoom direction
    
    // Get cursor position for zoom center
    QPointF cursorPos = event->position();
    double cursorXRatio = cursorPos.x() / width();
    double cursorYRatio = 1.0 - (cursorPos.y() / height()); // Invert Y for price axis
    
    // üöÄ DUAL-AXIS ZOOM: Zoom both time and price simultaneously
    
    // ‚îÄ‚îÄ‚îÄ‚îÄ TIME AXIS ZOOM (X) ‚îÄ‚îÄ‚îÄ‚îÄ
    double currentTimeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
    double newTimeRange = currentTimeRange * zoomFactor;
    newTimeRange = std::max(MIN_TIME_RANGE, std::min(MAX_TIME_RANGE, newTimeRange));
    
    if (std::abs(newTimeRange - currentTimeRange) > 10.0) {
        // Calculate cursor position in time coordinates
        int64_t cursorTimestamp = m_visibleTimeStart_ms + (cursorXRatio * currentTimeRange);
        
        // Calculate new time window bounds around cursor
        double timeDelta = newTimeRange - currentTimeRange;
        int64_t startAdjust = static_cast<int64_t>(timeDelta * cursorXRatio);
        int64_t endAdjust = static_cast<int64_t>(timeDelta * (1.0 - cursorXRatio));
        
        m_visibleTimeStart_ms -= startAdjust;
        m_visibleTimeEnd_ms += endAdjust;
    }
    
    // ‚îÄ‚îÄ‚îÄ‚îÄ PRICE AXIS ZOOM (Y) ‚îÄ‚îÄ‚îÄ‚îÄ
    double currentPriceRange = m_maxPrice - m_minPrice;
    double newPriceRange = currentPriceRange * zoomFactor;
    newPriceRange = std::max(MIN_PRICE_RANGE, std::min(MAX_PRICE_RANGE, newPriceRange));
    
    if (std::abs(newPriceRange - currentPriceRange) > 0.01) {
        // Calculate cursor position in price coordinates
        double cursorPrice = m_minPrice + (cursorYRatio * currentPriceRange);
        
        // Calculate new price range bounds around cursor
        double priceDelta = newPriceRange - currentPriceRange;
        double minAdjust = priceDelta * cursorYRatio;
        double maxAdjust = priceDelta * (1.0 - cursorYRatio);
        
        m_minPrice -= minAdjust;
        m_maxPrice += maxAdjust;
    }
    
    emit viewChanged(m_visibleTimeStart_ms, m_visibleTimeEnd_ms, m_minPrice, m_maxPrice);
    
    // Disable auto-scroll on zoom
    if (m_autoScrollEnabled) {
        m_autoScrollEnabled = false;
        sLog_Camera("üîç Auto-scroll disabled - manual zoom");
    }
    
    m_geometryDirty.store(true);
    updateDebugInfo();
    update();
    
    // üöÄ ENHANCED DEBUG: Show both time and price zoom info
    static int zoomDebugCount = 0;
    if (zoomDebugCount++ < 5) {
        sLog_Camera("üé• DUAL-AXIS ZOOM:"
                 << "Time:" << (newTimeRange/1000.0) << "s"
                 << "Price: $" << QString::number(newPriceRange, 'f', 2)
                 << "Window: [" << m_visibleTimeStart_ms << "," << m_visibleTimeEnd_ms << "]"
                 << "Range: [$" << QString::number(m_minPrice, 'f', 2) 
                 << ",$" << QString::number(m_maxPrice, 'f', 2) << "]");
    }
    
    event->accept();
}

// üéØ PHASE 4: Pan/Zoom Control Methods

void GPUChartWidget::zoomIn() {
    if (!m_timeWindowInitialized) return;
    
    // üî• OPTION B: Zoom by reducing time window duration
    double currentTimeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
    double newTimeRange = currentTimeRange * 0.8; // 20% zoom in
    double timeCenter = (m_visibleTimeStart_ms + m_visibleTimeEnd_ms) / 2.0;
    
    m_visibleTimeStart_ms = static_cast<int64_t>(timeCenter - newTimeRange / 2.0);
    m_visibleTimeEnd_ms = static_cast<int64_t>(timeCenter + newTimeRange / 2.0);
    emit viewChanged(m_visibleTimeStart_ms, m_visibleTimeEnd_ms, m_minPrice, m_maxPrice); // üî• FINAL POLISH: Include price range
    
    m_geometryDirty.store(true);
    update();
    sLog_Camera("üîç Camera ZOOM IN: Time range:" << (newTimeRange/1000.0) << "seconds");
}

void GPUChartWidget::zoomOut() {
    if (!m_timeWindowInitialized) return;
    
    // üî• OPTION B: Zoom by increasing time window duration  
    double currentTimeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
    double newTimeRange = currentTimeRange * 1.25; // 25% zoom out
    double timeCenter = (m_visibleTimeStart_ms + m_visibleTimeEnd_ms) / 2.0;
    
    m_visibleTimeStart_ms = static_cast<int64_t>(timeCenter - newTimeRange / 2.0);
    m_visibleTimeEnd_ms = static_cast<int64_t>(timeCenter + newTimeRange / 2.0);
    emit viewChanged(m_visibleTimeStart_ms, m_visibleTimeEnd_ms, m_minPrice, m_maxPrice); // üî• FINAL POLISH: Include price range
    
    m_geometryDirty.store(true);
    update();
    sLog_Camera("üîç Camera ZOOM OUT: Time range:" << (newTimeRange/1000.0) << "seconds");
}

void GPUChartWidget::resetZoom() {
    // üî• OPTION B: Reset to default time window
    if (m_timeWindowInitialized) {
        auto currentTime = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
        m_visibleTimeEnd_ms = currentTime;
        m_visibleTimeStart_ms = currentTime - m_timeSpanMs;
        emit viewChanged(m_visibleTimeStart_ms, m_visibleTimeEnd_ms, m_minPrice, m_maxPrice); // üî• FINAL POLISH: Include price range
        
        // üî• FIX: Use dynamic price range based on recent trades
        if (m_lastTradePrice > 0) {
            updateDynamicPriceRange(m_lastTradePrice);
        } else {
            // Fallback to static range only if no trades yet
            m_minPrice = m_staticMinPrice;
            m_maxPrice = m_staticMaxPrice;
        }
        
        m_geometryDirty.store(true);
        update();
        sLog_Camera("üîÑ CAMERA RESET - Time window and price range restored!");
    }
}

void GPUChartWidget::enableAutoScroll(bool enabled) {
    if (m_autoScrollEnabled != enabled) {
        m_autoScrollEnabled = enabled;
        sLog_Camera("üöÄ Auto-scroll" << (enabled ? "ENABLED" : "DISABLED"));
        emit autoScrollEnabledChanged();
    }
}

void GPUChartWidget::centerOnPrice(double price) {
    // üî• OPTION B: Center by adjusting price range instead of pan offset
    double priceSpan = m_maxPrice - m_minPrice;
    m_minPrice = price - priceSpan / 2.0;
    m_maxPrice = price + priceSpan / 2.0;
    m_geometryDirty.store(true);
    update();
    sLog_Camera("üéØ Centered on price:" << price << "Range:" << m_minPrice << "-" << m_maxPrice);
}

void GPUChartWidget::centerOnTime(qint64 timestamp) {
    // üî• OPTION B: Center by adjusting time window instead of pan offset
    double timeSpan = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
    m_visibleTimeStart_ms = timestamp - static_cast<int64_t>(timeSpan / 2.0);
    m_visibleTimeEnd_ms = timestamp + static_cast<int64_t>(timeSpan / 2.0);
    emit viewChanged(m_visibleTimeStart_ms, m_visibleTimeEnd_ms, m_minPrice, m_maxPrice); // üî• FINAL POLISH: Include price range
    m_geometryDirty.store(true);
    update();
    sLog_Camera("üéØ Centered on timestamp:" << timestamp << "Window:" << m_visibleTimeStart_ms << "-" << m_visibleTimeEnd_ms);
}

// üéØ PHASE 4: Coordinate Transformation Methods

// üî• NEW: PURE STATELESS COORDINATE SYSTEM (Option B)
QPointF GPUChartWidget::worldToScreen(int64_t timestamp_ms, double price) const {
    if (width() <= 0 || height() <= 0) {
        return QPointF(0, 0);
    }
    
    // üî• STATELESS: Use time window instead of static reference
    if (!m_timeWindowInitialized || m_visibleTimeEnd_ms <= m_visibleTimeStart_ms) {
        // Fallback: create a sliding window around current time
        auto currentTime = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
        const_cast<GPUChartWidget*>(this)->m_visibleTimeEnd_ms = currentTime;
        const_cast<GPUChartWidget*>(this)->m_visibleTimeStart_ms = currentTime - m_timeSpanMs;
        const_cast<GPUChartWidget*>(this)->m_timeWindowInitialized = true;
    }
    
    // üî• PURE MAPPING: Time window directly to screen coordinates
    double timeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
    double timeRatio = (timestamp_ms - m_visibleTimeStart_ms) / timeRange;
    double x = timeRatio * width();
    
    // üî• FIX: Use dynamic price range based on actual trade data
    // Check if we have a valid dynamic price range from recent trades
    double actualMinPrice = m_minPrice;
    double actualMaxPrice = m_maxPrice;
    
    // If using static range that doesn't match current BTC prices, use dynamic range
    if (actualMaxPrice < 100000 && price > 100000) {
        // BTC is above 100k, but our range is below - use dynamic centering
        double priceCenter = price;
        double priceSpan = 100.0; // $100 range around current price for good resolution
        actualMinPrice = priceCenter - priceSpan / 2.0;
        actualMaxPrice = priceCenter + priceSpan / 2.0;
    }
    
    // Map price to Y coordinate (flipped for screen coordinates)
    double priceRange = actualMaxPrice - actualMinPrice;
    if (priceRange <= 0) priceRange = 100.0; // Fallback to avoid division by zero
    
    double priceRatio = (price - actualMinPrice) / priceRange;
    double y = (1.0 - priceRatio) * height();
    
    // üî• NO MORE PAN/ZOOM TRANSFORMS: Camera movement handled by time window
    return QPointF(x, y);
}

QPointF GPUChartWidget::screenToWorld(const QPointF& screenPos) const {
    if (width() <= 0 || height() <= 0) {
        return QPointF(0, 0);
    }
    
    // üî• OPTION B: Use time window for reverse mapping
    double normalizedX = screenPos.x() / width();
    double normalizedY = 1.0 - (screenPos.y() / height()); // Flip Y
    
    // Map screen coordinates back to world coordinates using time window
    double timeRange = m_visibleTimeEnd_ms - m_visibleTimeStart_ms;
    double timestamp = m_visibleTimeStart_ms + (normalizedX * timeRange);
    
    double priceRange = m_maxPrice - m_minPrice;
    double price = m_minPrice + (normalizedY * priceRange);
    
    return QPointF(timestamp, price);
}

void GPUChartWidget::applyPanZoomToPoint(GPUPoint& point, double rawTimestamp, double rawPrice) {
    QPointF screenPos = worldToScreen(rawTimestamp, rawPrice);
    point.x = screenPos.x();
    point.y = screenPos.y();
}

void GPUChartWidget::updateAutoScroll() {
    if (m_autoScrollEnabled) {
        // üî• PADDING FIX: Add 20% padding to right edge so candles aren't at the edge
        auto currentTime = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::system_clock::now().time_since_epoch()).count();
        double paddingMs = m_timeSpanMs * 0.2; // 20% padding from right edge
        m_visibleTimeEnd_ms = currentTime + static_cast<int64_t>(paddingMs);
        m_visibleTimeStart_ms = m_visibleTimeEnd_ms - m_timeSpanMs;
        emit viewChanged(m_visibleTimeStart_ms, m_visibleTimeEnd_ms, m_minPrice, m_maxPrice);
        m_geometryDirty.store(true);
        update();
    }
}

double GPUChartWidget::calculateInteractionLatency() const {
    if (m_interactionTimer.isValid()) {
        return static_cast<double>(m_interactionTimer.elapsed());
    }
    return 0.0;
}

// üî• NEW: Time window management functions (Option B)
void GPUChartWidget::initializeTimeWindow(int64_t firstTimestamp) {
    // üî• PADDING FIX: Initialize with padding so first candle isn't at edge
    double paddingMs = m_timeSpanMs * 0.2; // 20% padding from right edge
    m_visibleTimeEnd_ms = firstTimestamp + static_cast<int64_t>(paddingMs);
    m_visibleTimeStart_ms = m_visibleTimeEnd_ms - m_timeSpanMs;
    m_timeWindowInitialized = true;
    sLog_Chart("üî• Initialized time window with padding:" << m_visibleTimeStart_ms << "to" << m_visibleTimeEnd_ms);
}

void GPUChartWidget::updateTimeWindow(int64_t newTimestamp) {
    if (!m_timeWindowInitialized) {
        initializeTimeWindow(newTimestamp);
        return;
    }
    
    if (m_autoScrollEnabled) {
        // üî• PADDING FIX: Add 20% padding to right edge for better candle visibility
        double paddingMs = m_timeSpanMs * 0.2; // 20% padding from right edge
        m_visibleTimeEnd_ms = newTimestamp + static_cast<int64_t>(paddingMs);
        m_visibleTimeStart_ms = m_visibleTimeEnd_ms - m_timeSpanMs;
        emit viewChanged(m_visibleTimeStart_ms, m_visibleTimeEnd_ms, m_minPrice, m_maxPrice);
    }
}

// üî• REMOVED: calculateColumnBasedPosition function with problematic static variable
// Replaced with stateless worldToScreen coordinate system in Option B 

void GPUChartWidget::setDebugInfoVisible(bool visible) {
    if (m_debugInfoVisible != visible) {
        m_debugInfoVisible = visible;
        emit debugInfoVisibleChanged();
    }
}

void GPUChartWidget::updateDebugInfo() {
    if (!m_debugInfoVisible) {
        m_debugInfoText.clear();
        return;
    }
    
    // Calculate viewport metrics
    double timeSpanSec = (m_visibleTimeEnd_ms - m_visibleTimeStart_ms) / 1000.0;
    double priceRange = m_maxPrice - m_minPrice;
    
    // üöÄ PHASE 4: Calculate bandwidth metrics
    double totalMB = static_cast<double>(m_totalBytesUploaded.load()) / 1'000'000.0;
    int warnings = m_bandwidthWarnings.load();
    
    // Format debug text with GPU profiler metrics
    m_debugInfoText = QString(
        "üìä Frame:%1MB BW:%2MB/s Total:%3MB Warn:%4 | Points:%5"
    ).arg(m_mbPerFrame, 0, 'f', 3)
     .arg(m_mbPerFrame * 60.0, 0, 'f', 1)  // Assume 60 FPS
     .arg(totalMB, 0, 'f', 1)
     .arg(warnings)
     .arg(m_allRenderPoints.size());
    
    emit debugInfoChanged();
} 

// ======= libs/gui/gpuchartwidget.h =======
#pragma once

#include <QQuickItem>
#include <QSGGeometryNode>
#include <QSGFlatColorMaterial>
#include <QSGVertexColorMaterial>  // üöÄ NEW: For per-vertex colors
#include <QVariantList>
#include <vector>
#include <chrono>
#include <atomic>
#include <mutex>
#include "tradedata.h"

class GPUChartWidget : public QQuickItem {
    Q_OBJECT
    QML_ELEMENT

    // üöÄ PHASE 4: QML Property for auto-scroll state
    Q_PROPERTY(bool autoScrollEnabled READ autoScrollEnabled WRITE enableAutoScroll NOTIFY autoScrollEnabledChanged)
    Q_PROPERTY(bool debugInfoVisible READ debugInfoVisible WRITE setDebugInfoVisible NOTIFY debugInfoVisibleChanged)
    Q_PROPERTY(QString debugInfo READ debugInfo NOTIFY debugInfoChanged)

public:
    explicit GPUChartWidget(QQuickItem* parent = nullptr);

    // üî• SIMPLIFIED: Remove test data methods - Option B approach
    // Q_INVOKABLE void setTestPoints(const QVariantList& points);  // REMOVED
    
    // REAL DATA INTERFACE (connects to existing StreamController)
    Q_INVOKABLE void addTrade(const Trade& trade);
    Q_INVOKABLE void updateOrderBook(const OrderBook& book);
    Q_INVOKABLE void clearTrades();
    
    // üöÄ PHASE 1: Performance Configuration
    Q_INVOKABLE void setMaxPoints(int maxPoints);
    Q_INVOKABLE void setTimeSpan(double timeSpanSeconds);
    Q_INVOKABLE void setPriceRange(double minPrice, double maxPrice);
    
    // üéØ PHASE 2: Dynamic Price Scaling (NEW)
    Q_INVOKABLE void enableDynamicPriceZoom(bool enabled);
    Q_INVOKABLE void setDynamicPriceRange(double rangeSize);
    Q_INVOKABLE void resetPriceRange();
    
    // üöÄ PHASE 4: Property getters for QML
    bool autoScrollEnabled() const { return m_autoScrollEnabled; }
    void enableAutoScroll(bool enabled);
    
    // üöÄ DEBUG INFO: On-screen viewport debugging
    bool debugInfoVisible() const { return m_debugInfoVisible; }
    void setDebugInfoVisible(bool visible);
    QString debugInfo() const { return m_debugInfoText; }

public slots:
    // üî• REAL-TIME DATA INTEGRATION
    void onTradeReceived(const Trade& trade);
    void onOrderBookUpdated(const OrderBook& book);
    
    // üöÄ PHASE 4: PAN/ZOOM CONTROL METHODS
    Q_INVOKABLE void zoomIn();
    Q_INVOKABLE void zoomOut();
    Q_INVOKABLE void resetZoom();
    Q_INVOKABLE void centerOnPrice(double price);
    Q_INVOKABLE void centerOnTime(qint64 timestamp);

signals:
    // üöÄ PHASE 4: QML notification signals
    void autoScrollEnabledChanged();
    void zoomFactorChanged(double factor);
    void panOffsetChanged(double x, double y);
    
    // üî• GEMINI UNIFICATION: Broadcasts the camera's current time window
    void viewChanged(qint64 startTimeMs, qint64 endTimeMs, double minPrice, double maxPrice); // üî• FINAL POLISH: Include price range
    void debugInfoVisibleChanged();
    void debugInfoChanged();

protected:
    QSGNode* updatePaintNode(QSGNode* oldNode, UpdatePaintNodeData*) override;
    void geometryChanged(const QRectF &newGeometry, const QRectF &oldGeometry);
    
    // üöÄ PHASE 4: MOUSE/TOUCH INTERACTION EVENTS
    void mousePressEvent(QMouseEvent* event) override;
    void mouseMoveEvent(QMouseEvent* event) override;
    void mouseReleaseEvent(QMouseEvent* event) override;
    void wheelEvent(QWheelEvent* event) override;

private:
    struct GPUPoint {
        float x, y;           // Screen coordinates
        float r, g, b, a;     // Color (RGBA)
        float size;           // Point size
        int64_t timestamp_ms; // For aging/cleanup
        
        // üî• RAW DATA: Store original values before coordinate transformation
        double rawTimestamp = 0.0;  // Original timestamp for coordinate mapping
        double rawPrice = 0.0;      // Original price for coordinate mapping
    };
    
    // üî• PHASE 1: VBO TRIPLE-BUFFERING FOR MAXIMUM PERFORMANCE
    struct GPUBuffer {
        std::vector<GPUPoint> points;
        std::atomic<bool> dirty{false};
        std::atomic<bool> inUse{false};
    };
    
    // Triple-buffered GPU data
    static constexpr int BUFFER_COUNT = 3;
    GPUBuffer m_gpuBuffers[BUFFER_COUNT];
    std::atomic<int> m_writeBuffer{0};
    std::atomic<int> m_readBuffer{1};
    std::mutex m_bufferMutex;
    
    // üî• GEMINI FIX: Accumulate all trades for persistent rendering
    std::vector<GPUPoint> m_allRenderPoints;
    
    // REAL DATA STORAGE
    std::vector<Trade> m_recentTrades;
    OrderBook m_currentOrderBook;
    std::mutex m_dataMutex;
    
    // üéØ VIEW PARAMETERS - Dynamic price range (no hardcoded values)
    double m_minPrice = 107000.0;  // Current BTC range - will be updated dynamically
    double m_maxPrice = 109000.0;
    double m_timeSpanMs = 60000.0; // 60 seconds visible window
    int m_maxPoints = 100000;      // 100K points max (configurable)
    
    // üî• NEW: STATELESS TIME WINDOW (Option B approach)
    int64_t m_visibleTimeStart_ms = 0;  // Left edge of chart (oldest visible time)
    int64_t m_visibleTimeEnd_ms = 0;    // Right edge of chart (newest visible time)
    bool m_timeWindowInitialized = false;
    
    // üéØ PHASE 2: Dynamic Price Scaling (NEW)
    bool m_dynamicPriceZoom = true;        // Enable automatic price zoom
    double m_dynamicRangeSize = 50.0;      // Default $50 range for BTC (adjustable)
    double m_lastTradePrice = 0.0;         // Track most recent price for centering
    int m_priceUpdateCount = 0;            // Count trades for range adjustment frequency
    double m_staticMinPrice = 107000.0;    // Fallback static range - current BTC levels  
    double m_staticMaxPrice = 109000.0;    // Fallback static range - current BTC levels
    
    // üöÄ PHASE 4: PAN/ZOOM INTERACTION STATE
    double m_zoomFactor = 1.0;             // Zoom level (1.0 = no zoom)
    double m_panOffsetX = 0.0;             // Pan offset in time (milliseconds)
    double m_panOffsetY = 0.0;             // Pan offset in price
    bool m_autoScrollEnabled = true;       // Auto-scroll to follow latest data
    bool m_isDragging = false;             // Mouse drag state
    QPointF m_lastMousePos;                // Last mouse position for drag delta
    QElapsedTimer m_interactionTimer;      // Measure interaction latency
    
    // üéØ PHASE 4: Zoom constraints and smooth interaction
    static constexpr double MIN_ZOOM = 0.1;    // 10x zoom out
    static constexpr double MAX_ZOOM = 100.0;  // 100x zoom in
    static constexpr double ZOOM_FACTOR = 1.15; // 15% per wheel step
    
    // üöÄ PERFORMANCE OPTIMIZATION FLAGS
    std::atomic<bool> m_geometryDirty{true};
    std::atomic<bool> m_enableVBO{true};      // VBO optimization
    
    // üü° PRICE CHANGE TRACKING: For three-color system (uptick/downtick/no-change)
    double m_previousTradePrice = 0.0;        // Track previous price for color logic
    bool m_hasPreviousPrice = false;          // Flag to skip first trade color logic
    
    // üöÄ DEBUG INFO: On-screen display
    bool m_debugInfoVisible = true;  // Show debug info by default
    QString m_debugInfoText;
    
    // üöÄ PHASE 4: PCIe UPLOAD PROFILER
    mutable size_t m_bytesUploadedThisFrame = 0;
    mutable double m_mbPerFrame = 0.0;
    mutable std::atomic<size_t> m_totalBytesUploaded{0};
    mutable std::atomic<int> m_bandwidthWarnings{0};
    static constexpr double PCIE_BUDGET_MB_PER_SECOND = 200.0; // PCIe 3.0 x4 budget
    
    // Helper methods
    void convertTradeToGPUPoint(const Trade& trade, GPUPoint& point);
    void cleanupOldTrades();
    void swapBuffers();
    void updateDynamicPriceRange(double newPrice);
    bool isInCurrentPriceRange(double price) const;
    void updateDebugInfo();
    
    // üî• NEW: STATELESS COORDINATE SYSTEM (Option B)
    QPointF worldToScreen(int64_t timestamp_ms, double price) const;
    QPointF screenToWorld(const QPointF& screenPos) const;
    void updateTimeWindow(int64_t newTimestamp);
    void initializeTimeWindow(int64_t firstTimestamp);
    
    // üéØ PHASE 2: Dynamic Price Scaling (NEW)
    QColor determineDominantTradeColor(const std::vector<GPUPoint>& points) const;
    
    // üéØ PHASE 4: Pan/Zoom Coordinate Transformation
    void applyPanZoomToPoint(GPUPoint& point, double rawTimestamp, double rawPrice);
    void updateAutoScroll();
    double calculateInteractionLatency() const;
    
    // üî• PHASE 1: VBO Management
    void appendTradeToVBO(const Trade& trade);

    // üî• NEW: Share time window with heatmap for unified coordinates
    int64_t getVisibleTimeStart() const { return m_visibleTimeStart_ms; }
    int64_t getVisibleTimeEnd() const { return m_visibleTimeEnd_ms; }
    bool isTimeWindowInitialized() const { return m_timeWindowInitialized; }
}; 

// ======= libs/gui/gpudataadapter.cpp =======
#include "gpudataadapter.h"
#include "SentinelLogging.hpp"
#include <QDebug>
#include <QElapsedTimer>
#include <algorithm>
#include <chrono>
#include <QDateTime>
#include <cstdint>

GPUDataAdapter::GPUDataAdapter(QObject* parent)
    : QObject(parent)
    , m_processTimer(new QTimer(this))
    , m_candle100msTimer(new QTimer(this))
    , m_candle500msTimer(new QTimer(this))
    , m_candle1sTimer(new QTimer(this))
    , m_liveOrderBook("BTC-USD") // Initialize stateful order book
{
    sLog_Init("üöÄ GPUDataAdapter: Initializing lock-free data pipeline...");
    
    initializeBuffers();
    
    // Connect processing timers
    connect(m_processTimer, &QTimer::timeout, this, &GPUDataAdapter::processIncomingData);
    connect(m_candle100msTimer, &QTimer::timeout, this, &GPUDataAdapter::processHighFrequencyCandles);
    connect(m_candle500msTimer, &QTimer::timeout, this, &GPUDataAdapter::processMediumFrequencyCandles);
    connect(m_candle1sTimer, &QTimer::timeout, this, &GPUDataAdapter::processSecondCandles);
    
    // Start timers at their proper intervals
    m_processTimer->start(16);     // 16ms - Trade scatter + Order book heatmap
    m_candle100msTimer->start(100); // 100ms - High-frequency candles
    m_candle500msTimer->start(500); // 500ms - Medium-frequency candles  
    m_candle1sTimer->start(1000);   // 1000ms - Second candles
    
    sLog_Init("‚úÖ GPUDataAdapter: Lock-free pipeline initialized"
             << "- Reserve size:" << m_reserveSize 
             << "- Trade queue capacity: 65536"
             << "- OrderBook queue capacity: 16384"
             << "- Candle timers: 100ms, 500ms, 1s");
}

void GPUDataAdapter::initializeBuffers() {
    // Runtime-configurable buffer size (handle Intel UHD VRAM limits)
    QSettings settings;
    m_reserveSize = settings.value("chart/reserveSize", 2'000'000).toULongLong();
    
    // Pre-allocate once: std::max(expected, userPref)
    size_t actualSize = (m_reserveSize > 100000) ? m_reserveSize : 100000; // Minimum 100k
    
    sLog_Init("üîß GPUDataAdapter: Pre-allocating buffers - Trade buffer:" << actualSize
             << "Heatmap buffer:" << actualSize);

    m_tradeBuffer.reserve(actualSize);
    m_heatmapBuffer.reserve(actualSize);
    m_candleBuffer.reserve(actualSize);

    // Initialize with empty elements to avoid reallocations
    m_tradeBuffer.resize(actualSize);
    m_heatmapBuffer.resize(actualSize);
    m_candleBuffer.resize(actualSize);
    
    sLog_Init("üíæ GPUDataAdapter: Buffer allocation complete");
}

bool GPUDataAdapter::pushTrade(const Trade& trade) {
    if (m_tradeQueue.push(trade)) {
        m_pointsPushed.fetch_add(1, std::memory_order_relaxed);
        return true;
    } else {
        // Queue full - performance alert
        m_frameDrops.fetch_add(1, std::memory_order_relaxed);
        emit performanceAlert("Trade queue full - dropping data!");
        return false;
    }
}

bool GPUDataAdapter::pushOrderBook(const OrderBook& orderBook) {
    if (m_orderBookQueue.push(orderBook)) {
        return true;
    } else {
        // Queue full - performance alert
        m_frameDrops.fetch_add(1, std::memory_order_relaxed);
        emit performanceAlert("OrderBook queue full - dropping data!");
        return false;
    }
}

void GPUDataAdapter::processIncomingData() {
    static QElapsedTimer frameTimer;
    frameTimer.start();
    
    // ZERO MALLOC ZONE - rolling write cursor
    Trade trade;
    m_tradeWriteCursor = 0; // Reset cursor, DON'T clear()
    m_candleWriteCursor = 0;

    size_t tradesProcessed = 0;
    
    // Process trades with rate limiting based on firehose setting
    while (m_tradeQueue.pop(trade) && m_tradeWriteCursor < m_reserveSize) {
        if (Q_UNLIKELY(trade.trade_id.empty())) continue; // Guard clause

        // Convert to GPU point with coordinate mapping
        m_tradeBuffer[m_tradeWriteCursor++] = convertTradeToGPUPoint(trade);
        m_candleLOD.addTrade(trade);
        m_currentSymbol = trade.product_id;
        
        // üöÄ PHASE 2: Add trade to time-windowed history buffer
        {
            std::lock_guard<std::mutex> lock(m_tradeHistoryMutex);
            m_tradeHistory.push_back(trade);
        }
        
        tradesProcessed++;
        
        // Rate limiting for stress testing
        if (tradesProcessed >= static_cast<size_t>(m_firehoseRate / 60)) {
            break; // Limit to firehose_rate / 60 per frame (60 FPS assumption)
        }
    }

    // Candle processing moved to separate time-based timers
    // (100ms, 500ms, 1s timers handle their respective candle updates)
    
    // üöÄ STATEFUL: Process order books with LiveOrderBook
    OrderBook orderBook;
    m_heatmapWriteCursor = 0;
    
    size_t orderBooksProcessed = 0;
    while (m_orderBookQueue.pop(orderBook) && orderBooksProcessed < 10) { 
        // Initialize from snapshot or apply updates to LiveOrderBook
        if (orderBooksProcessed == 0) {
            // First order book is treated as a snapshot
            m_liveOrderBook.initializeFromSnapshot(orderBook);
        } else {
            // Subsequent order books are treated as updates
            for (const auto& bid : orderBook.bids) {
                m_liveOrderBook.applyUpdate("bid", bid.price, bid.size);
            }
            
            for (const auto& ask : orderBook.asks) {
                m_liveOrderBook.applyUpdate("ask", ask.price, ask.size);
            }
        }
        
        orderBooksProcessed++;
    }
    
    // Convert LiveOrderBook to GPU quads (only if data was updated)
    if (orderBooksProcessed > 0) {
        convertLiveOrderBookToQuads();
    }
    
    // üìä TRADE DISTRIBUTION TRACKING in lock-free pipeline
    static int gpuTotalBuys = 0, gpuTotalSells = 0, gpuTotalUnknown = 0;
    if (Q_LIKELY(m_tradeWriteCursor > 0)) {
        // Count colors in current buffer
        for (size_t i = 0; i < m_tradeWriteCursor; ++i) {
            const auto& point = m_tradeBuffer[i];
            if (point.g > 0.8f && point.r < 0.2f) gpuTotalBuys++;        // Green = Buy
            else if (point.r > 0.8f && point.g < 0.2f) gpuTotalSells++; // Red = Sell
            else gpuTotalUnknown++;                                      // Yellow/Other
        }
        
        // Log distribution every 50 trades
        static int gpuDistributionCounter = 0;
        if (++gpuDistributionCounter % 50 == 0) {
            int gpuTotalTrades = gpuTotalBuys + gpuTotalSells + gpuTotalUnknown;
            double gpuBuyPercent = gpuTotalTrades > 0 ? (gpuTotalBuys * 100.0 / gpuTotalTrades) : 0.0;
            double gpuSellPercent = gpuTotalTrades > 0 ? (gpuTotalSells * 100.0 / gpuTotalTrades) : 0.0;
            
            sLog_GPU("üìä GPU ADAPTER DISTRIBUTION: Total:" << gpuTotalTrades
                     << " Buys:" << gpuTotalBuys << "(" << QString::number(gpuBuyPercent, 'f', 1) << "%)"
                     << " Sells:" << gpuTotalSells << "(" << QString::number(gpuSellPercent, 'f', 1) << "%)"
                     << " Unknown:" << gpuTotalUnknown);
        }
        
        emit tradesReady(m_tradeBuffer.data(), m_tradeWriteCursor);
        m_processedTrades.fetch_add(tradesProcessed, std::memory_order_relaxed);
    }
    
    if (Q_LIKELY(m_heatmapWriteCursor > 0)) {
        emit heatmapReady(m_heatmapBuffer.data(), m_heatmapWriteCursor);
    }

    // Candle updates now emitted by separate time-based timers
    
    // üöÄ PHASE 2: Periodic cleanup of trade history buffer (every 5 seconds)
    int64_t currentTime_ms = QDateTime::currentMSecsSinceEpoch();
    if (currentTime_ms - m_lastHistoryCleanup_ms > CLEANUP_INTERVAL_MS) {
        cleanupOldTradeHistory();
        m_lastHistoryCleanup_ms = currentTime_ms;
    }
    
    // Performance monitoring
    qint64 frameTime = frameTimer.elapsed();
    if (frameTime > 16) { // >60 FPS threshold
        m_frameDrops.fetch_add(1, std::memory_order_relaxed);
        sLog_Performance("‚ö†Ô∏è GPUDataAdapter: Frame time exceeded:" << frameTime << "ms");
    }
    
    // Debug output every 1000 frames (~16.7 seconds at 60 FPS)
    static int frameCount = 0;
    if (++frameCount % 1000 == 0) {
        sLog_Performance("üìä GPUDataAdapter Stats:"
                 << "Trades processed:" << m_processedTrades.load()
                 << "Points pushed:" << m_pointsPushed.load()
                 << "Frame drops:" << m_frameDrops.load()
                 << "Trade queue size:" << m_tradeQueue.size()
                 << "OrderBook queue size:" << m_orderBookQueue.size());
    }
}

GPUTypes::Point GPUDataAdapter::convertTradeToGPUPoint(const Trade& trade) {
    // Update coordinate cache if needed
    updateCoordinateCache(trade.price);
    
    GPUTypes::Point point;
    
    // Time mapping (artificial spacing for now - will be natural in Phase 4)
    static double artificialTimeOffset = 0.0;
    artificialTimeOffset += 500.0; // 500ms spacing
    
    // For now, use simple time-based X coordinate
    double normalizedTime = artificialTimeOffset / m_coordCache.timeSpanMs;
    point.x = static_cast<float>(1.0 - fmod(normalizedTime, 1.0)); // Wrap around
    
    // Price mapping to Y coordinate
    if (m_coordCache.initialized) {
        double normalizedPrice = (trade.price - m_coordCache.minPrice) / 
                                (m_coordCache.maxPrice - m_coordCache.minPrice);
        normalizedPrice = std::max(0.05, std::min(0.95, normalizedPrice)); // Clamp
        point.y = static_cast<float>(1.0 - normalizedPrice); // Invert Y (top = high price)
    } else {
        point.y = 0.5f; // Center if no price range established
    }
    
    // üé® Color based on trade side
    const char* sideStr = "UNKNOWN";
    if (trade.side == AggressorSide::Buy) {
        point.r = 0.0f; point.g = 1.0f; point.b = 0.0f; point.a = 0.8f; // Green
        sideStr = "BUY";
    } else if (trade.side == AggressorSide::Sell) {
        point.r = 1.0f; point.g = 0.0f; point.b = 0.0f; point.a = 0.8f; // Red
        sideStr = "SELL";
    } else {
        // Unknown side - yellow for debugging
        point.r = 1.0f; point.g = 1.0f; point.b = 0.0f; point.a = 0.8f; // Yellow
        sideStr = "UNKNOWN";
    }
    
    // üîç DEBUG: Log first 10 GPU conversions in lock-free pipeline
    static int gpuConversionCount = 0;
    if (++gpuConversionCount <= 10) {
        sLog_GPU("üé® LEGACY SYSTEM #" << gpuConversionCount << ": Side:" << sideStr
                 << " Price:$" << trade.price << " -> X:" << point.x << " Y:" << point.y
                 << " Color RGBA:(" << point.r << "," << point.g << "," << point.b << "," << point.a << ")");
    }
    
    return point;
}

void GPUDataAdapter::updateCoordinateCache(double price) {
    if (!m_coordCache.initialized) {
        m_coordCache.minPrice = price * 0.98; // 2% buffer below
        m_coordCache.maxPrice = price * 1.02; // 2% buffer above
        m_coordCache.initialized = true;
    } else {
        // Auto-expand range if needed
        if (price < m_coordCache.minPrice) {
            m_coordCache.minPrice = price * 0.98;
        } else if (price > m_coordCache.maxPrice) {
            m_coordCache.maxPrice = price * 1.02;
        }
    }
}

void GPUDataAdapter::setReserveSize(size_t size) {
    m_reserveSize = size;
    // Note: Would need to reinitialize buffers in production
    sLog_GPU("üîß GPUDataAdapter: Reserve size set to" << size);
}

void GPUDataAdapter::resetWriteCursors() {
    m_tradeWriteCursor = 0;
    m_heatmapWriteCursor = 0;
}

// üéØ GRID REFRESH: Access historical data for re-aggregation
std::vector<Trade> GPUDataAdapter::getTradeHistory() const {
    std::lock_guard<std::mutex> lock(m_tradeHistoryMutex);
    return std::vector<Trade>(m_tradeHistory.begin(), m_tradeHistory.end());
}

void GPUDataAdapter::refreshGridData() {
    sLog_Chart("üîÑ GRID REFRESH: Triggering grid system refresh with historical data");
    emit gridRefreshRequested();
}

// üïØÔ∏è TIME-BASED CANDLE PROCESSING: Emit candle updates at proper intervals

void GPUDataAdapter::processHighFrequencyCandles() {
    // Process 100ms candles only
    processCandleTimeFrame(CandleLOD::TF_100ms);
}

void GPUDataAdapter::processMediumFrequencyCandles() {
    // Process 500ms candles only
    processCandleTimeFrame(CandleLOD::TF_500ms);
}

void GPUDataAdapter::processSecondCandles() {
    // Process 1s candles only
    processCandleTimeFrame(CandleLOD::TF_1sec);
}

void GPUDataAdapter::processCandleTimeFrame(CandleLOD::TimeFrame timeframe) {
    const auto& vec = m_candleLOD.getCandlesForTimeFrame(timeframe);
    if (vec.empty()) return;

    size_t tfIndex = static_cast<size_t>(timeframe);
    const OHLC& latestCandle = vec.back();
    
    // Only emit if candle has changed (time-based boundary crossed)
    if (latestCandle.timestamp_ms != m_lastEmittedCandleTime[tfIndex]) {
        CandleUpdate update;
        update.symbol = m_currentSymbol;
        update.timestamp_ms = latestCandle.timestamp_ms;
        update.timeframe = timeframe;
        update.candle = latestCandle;
        update.isNewCandle = true; // Always true for time-based updates
        
        m_lastEmittedCandleTime[tfIndex] = update.timestamp_ms;
        
        // Emit immediately for time-based candles
        std::vector<CandleUpdate> ready = {update};
        emit candlesReady(ready);
        
        // Debug logging for first few candles of each timeframe
        static std::array<int, CandleLOD::NUM_TIMEFRAMES> candleCount{};
        if (++candleCount[tfIndex] <= 5) {
            sLog_Candles("üïØÔ∏è TIME-BASED CANDLE EMIT #" << candleCount[tfIndex]
                     << "TimeFrame:" << CandleUtils::timeFrameName(timeframe)
                     << "Timestamp:" << update.timestamp_ms
                     << "OHLC:" << update.candle.open << update.candle.high 
                     << update.candle.low << update.candle.close);
        }
    }
}

// üöÄ PHASE 2: TIME-WINDOWED TRADE HISTORY CLEANUP
void GPUDataAdapter::cleanupOldTradeHistory() {
    std::lock_guard<std::mutex> lock(m_tradeHistoryMutex);
    
    if (m_tradeHistory.empty()) return;
    
    // Calculate cutoff time (10 minutes ago)
    auto now = std::chrono::system_clock::now();
    auto cutoffTime = now - HISTORY_WINDOW_SPAN;
    int64_t cutoff_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
        cutoffTime.time_since_epoch()).count();
    
    // Remove trades older than cutoff
    size_t initialSize = m_tradeHistory.size();
    
    while (!m_tradeHistory.empty()) {
        // Convert trade timestamp to milliseconds for comparison
        int64_t trade_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
            m_tradeHistory.front().timestamp.time_since_epoch()).count();
        
        if (trade_ms < cutoff_ms) {
            m_tradeHistory.pop_front();
        } else {
            break; // Remaining trades are newer
        }
    }
    
    size_t removedCount = initialSize - m_tradeHistory.size();
    
    // Log cleanup activity (throttled)
    static int cleanupCount = 0;
    if (++cleanupCount <= 10 || removedCount > 0) {
        sLog_GPU("üßπ PHASE 2 TRADE HISTORY CLEANUP #" << cleanupCount
                 << " Removed:" << removedCount << " old trades"
                 << " Current size:" << m_tradeHistory.size()
                 << " Window:" << HISTORY_WINDOW_SPAN.count() << " seconds");
    }
}

// üöÄ STATEFUL: Convert LiveOrderBook to GPU heatmap quads
void GPUDataAdapter::convertLiveOrderBookToQuads() {
    m_heatmapWriteCursor = 0;
    
    // Get bid levels from stateful order book
    auto bids = m_liveOrderBook.getAllBids();
    for (const auto& bid : bids) {
        if (m_heatmapWriteCursor >= m_reserveSize) break;
        
        GPUTypes::QuadInstance quad;
        quad.x = 0.0f; // Will be calculated in GPU widget
        quad.y = static_cast<float>(bid.price);
        quad.width = static_cast<float>(bid.size * 100.0); // Scale for visibility
        quad.height = 2.0f; // Fixed height
        quad.r = 0.0f; quad.g = 1.0f; quad.b = 0.0f; quad.a = 0.8f; // Green for bids
        
        m_heatmapBuffer[m_heatmapWriteCursor++] = quad;
    }
    
    // Get ask levels from stateful order book
    auto asks = m_liveOrderBook.getAllAsks();
    for (const auto& ask : asks) {
        if (m_heatmapWriteCursor >= m_reserveSize) break;
        
        GPUTypes::QuadInstance quad;
        quad.x = 0.0f; // Will be calculated in GPU widget
        quad.y = static_cast<float>(ask.price);
        quad.width = static_cast<float>(ask.size * 100.0); // Scale for visibility
        quad.height = 2.0f; // Fixed height
        quad.r = 1.0f; quad.g = 0.0f; quad.b = 0.0f; quad.a = 0.8f; // Red for asks
        
        m_heatmapBuffer[m_heatmapWriteCursor++] = quad;
    }
    
    // Log LiveOrderBook performance metrics
    static int heatmapUpdateCount = 0;
    if (++heatmapUpdateCount % 100 == 0) {
        sLog_GPU("üöÄ LIVE ORDER BOOK STATS #" << heatmapUpdateCount
                 << " Bid count:" << m_liveOrderBook.getBidCount()
                 << " Ask count:" << m_liveOrderBook.getAskCount()
                 << " Best bid:" << getBestBid()
                 << " Best ask:" << getBestAsk()
                 << " Spread:" << getSpread()
                 << " Heatmap quads:" << m_heatmapWriteCursor);
    }
}

// ======= libs/gui/gpudataadapter.h =======
#pragma once
#include <QObject>
#include <QTimer>
#include <QSettings>
#include <vector>
#include <array>
#include <atomic>
#include <deque>
#include <mutex>
#include <chrono>
#include "../core/lockfreequeue.h"
#include "../core/tradedata.h"
#include "candlelod.h"
#include "GPUTypes.h"

struct CandleUpdate {
    std::string symbol;
    int64_t timestamp_ms;
    CandleLOD::TimeFrame timeframe;
    OHLC candle;
    bool isNewCandle;
};

using CandleQueue = LockFreeQueue<CandleUpdate, 16384>;

class GPUDataAdapter : public QObject {
    Q_OBJECT

public:
    explicit GPUDataAdapter(QObject* parent = nullptr);
    
    // CLI flag: --firehose-rate for QA sweep testing
    void setFirehoseRate(int msgsPerSec) { m_firehoseRate = msgsPerSec; }
    
    // Lock-free push from WebSocket thread
    bool pushTrade(const Trade& trade);
    bool pushOrderBook(const OrderBook& orderBook);
    
    // Performance monitoring
    size_t getPointsThroughput() const { return m_pointsPushed.load(); }
    size_t getProcessedTrades() const { return m_processedTrades.load(); }
    bool hasDroppedFrames() const { return m_frameDrops.load() > 0; }
    
    // Configuration
    void setReserveSize(size_t size);
    size_t getReserveSize() const { return m_reserveSize; }
    
    // üöÄ LiveOrderBook Access
    const LiveOrderBook& getLiveOrderBook() const { return m_liveOrderBook; }
    double getBestBid() const { 
        auto bids = m_liveOrderBook.getAllBids();
        return bids.empty() ? 0.0 : bids.front().price;
    }
    double getBestAsk() const { 
        auto asks = m_liveOrderBook.getAllAsks();
        return asks.empty() ? 0.0 : asks.front().price;
    }
    double getSpread() const { return getBestAsk() - getBestBid(); }
    
    // üéØ GRID REFRESH: Access historical data for re-aggregation
    std::vector<Trade> getTradeHistory() const;
    void refreshGridData(); // Trigger grid system refresh

signals:
    void tradesReady(const GPUTypes::Point* points, size_t count);
    void heatmapReady(const GPUTypes::QuadInstance* quads, size_t count);
    void candlesReady(const std::vector<CandleUpdate>& candles);
    void performanceAlert(const QString& message);
    void gridRefreshRequested(); // üéØ Signal to trigger grid system refresh

private slots:
    void processIncomingData();           // Process trades + order books (16ms)
    void processHighFrequencyCandles();   // Process 100ms candles
    void processMediumFrequencyCandles(); // Process 500ms candles
    void processSecondCandles();          // Process 1s candles

private:
    // Lock-free queues
    TradeQueue m_tradeQueue;         // 65536 = 2^16 (3.3s buffer @ 20k msg/s)
    OrderBookQueue m_orderBookQueue; // 16384 = 2^14
    
    // üöÄ STATEFUL: LiveOrderBook for Professional Visualization
    LiveOrderBook m_liveOrderBook;
    
    // Zero-malloc buffers (pre-allocated, cursor-based)
    std::vector<GPUTypes::Point> m_tradeBuffer;
    std::vector<GPUTypes::QuadInstance> m_heatmapBuffer;
    std::vector<CandleUpdate> m_candleBuffer;
    size_t m_tradeWriteCursor = 0;
    size_t m_heatmapWriteCursor = 0;
    size_t m_candleWriteCursor = 0;
    
    // Configuration
    size_t m_reserveSize;
    int m_firehoseRate = 20000; // Default 20k msg/s, override with --firehose-rate
    
    // Performance monitoring
    std::atomic<size_t> m_pointsPushed{0};
    std::atomic<size_t> m_processedTrades{0};
    std::atomic<int> m_frameDrops{0};
    
    // Processing timers
    QTimer* m_processTimer;      // 16ms - Trade scatter + Order book heatmap
    QTimer* m_candle100msTimer;  // 100ms - High-frequency candles
    QTimer* m_candle500msTimer;  // 500ms - Medium-frequency candles  
    QTimer* m_candle1sTimer;     // 1000ms - Second candles

    CandleQueue m_candleQueue;
    CandleLOD m_candleLOD;
    std::array<int64_t, CandleLOD::NUM_TIMEFRAMES> m_lastEmittedCandleTime{};
    std::string m_currentSymbol;
    
    // Coordinate mapping (cached for performance)
    struct CoordinateCache {
        double minPrice = 0.0;
        double maxPrice = 0.0;
        double timeSpanMs = 60000.0; // 60 seconds
        bool initialized = false;
    } m_coordCache;
    
    // üöÄ PHASE 2: TIME-WINDOWED TRADE HISTORY BUFFER
    // Maintains rolling 10-minute window of trades for re-aggregation
    std::deque<Trade> m_tradeHistory;
    mutable std::mutex m_tradeHistoryMutex; // Mutable for const access
    static constexpr std::chrono::seconds HISTORY_WINDOW_SPAN{600}; // 10 minutes
    int64_t m_lastHistoryCleanup_ms = 0;
    static constexpr int64_t CLEANUP_INTERVAL_MS = 5000; // Clean up every 5 seconds
    
    // Helper methods
    void initializeBuffers();
    GPUTypes::Point convertTradeToGPUPoint(const Trade& trade);
    void updateCoordinateCache(double price);
    void resetWriteCursors();
    void processCandleTimeFrame(CandleLOD::TimeFrame timeframe);  // Time-based candle processing
    void cleanupOldTradeHistory(); // üöÄ PHASE 2: Time-based history cleanup
    void convertLiveOrderBookToQuads(); // üöÄ Convert LiveOrderBook to GPU quads
}; 

// ======= libs/gui/streamcontroller.cpp =======
#include "streamcontroller.h"
#include "SentinelLogging.hpp"
#include "gpudataadapter.h"
#include "MarketDataCore.hpp"
#include <QDebug>

StreamController::StreamController(QObject* parent)
    : QObject(parent)
    , m_client(nullptr)
    , m_pollTimer(nullptr)
    , m_orderBookPollTimer(nullptr)
{
    sLog_Init("StreamController created");
}

StreamController::~StreamController() {
    stop();
    sLog_Init("StreamController destroyed");
}

void StreamController::start(const std::vector<std::string>& symbols) {
    sLog_Init("Starting StreamController...");
    
    // Store the symbols for later use
    m_symbols = symbols;
    
    // Create the stream client (like instantiating a Python class)
    m_client = std::make_unique<CoinbaseStreamClient>();
    
    // Subscribe to the symbols
    m_client->subscribe(symbols);
    
    // Start the client
    m_client->start();
    
    // üî• NEW: Connect to real-time WebSocket signals instead of polling
    if (m_client->getMarketDataCore()) {
        connect(m_client->getMarketDataCore(), &MarketDataCore::tradeReceived,
                this, &StreamController::onTradeReceived, Qt::QueuedConnection);
        connect(m_client->getMarketDataCore(), &MarketDataCore::orderBookUpdated,
                this, &StreamController::onOrderBookUpdated, Qt::QueuedConnection);
        connect(m_client->getMarketDataCore(), &MarketDataCore::connectionStatusChanged,
                this, &StreamController::onConnectionStatusChanged, Qt::QueuedConnection);
        
        sLog_Init("‚úÖ Connected to real-time WebSocket signals");
    } else {
        sLog_Warning("‚ö†Ô∏è MarketDataCore not available, falling back to polling");
        
        // Fallback to polling if real-time signals not available
        m_pollTimer = new QTimer(this);
        connect(m_pollTimer, &QTimer::timeout, this, &StreamController::pollForTrades);
        m_pollTimer->start(100);

        m_orderBookPollTimer = new QTimer(this);
        connect(m_orderBookPollTimer, &QTimer::timeout, this, &StreamController::pollForOrderBooks);
        m_orderBookPollTimer->start(100);
    }
    
    // Emit connected signal
    emit connected();
    
    sLog_Init("StreamController started successfully");
}

void StreamController::stop() {
    sLog_Init("Stopping StreamController...");
    
    // 1. Reset the client first. This is critical.
    // This stops the underlying threads in MarketDataCore and ensures no
    // new work is done, even if a stray timer event fires.
    m_client.reset();
    
    // 2. Now that the client is gone, we can safely stop and delete the timers.
    if (m_pollTimer) {
        m_pollTimer->stop();
        m_pollTimer->deleteLater();
        m_pollTimer = nullptr;
    }
    if (m_orderBookPollTimer) {
        m_orderBookPollTimer->stop();
        m_orderBookPollTimer->deleteLater();
        m_orderBookPollTimer = nullptr;
    }
    
    // Clear tracking data
    m_lastTradeIds.clear();
    
    // Emit disconnected signal
    emit disconnected();
    
    sLog_Init("StreamController stopped");
}

// üî• NEW: Real-time signal handlers
void StreamController::onTradeReceived(const Trade& trade) {
    // üî• REAL-TIME: Process trade immediately from WebSocket
    // Log only the first 10 trades
    static int tradeCount = 0;
    if (tradeCount < 10) {
        sLog_Trades("üöÄ REAL-TIME: Received trade" << QString::fromStdString(trade.product_id) 
                   << "$" << trade.price << "size:" << trade.size);
        tradeCount++;
    }

    // üöÄ LOCK-FREE PIPELINE: Push to GPU adapter
    if (m_gpuAdapter && !m_gpuAdapter->pushTrade(trade)) {
        sLog_Warning("‚ö†Ô∏è StreamController: GPU trade queue full! Trade dropped.");
    }
    
    // Keep Qt signal for backward compatibility
    emit tradeReceived(trade);
}

void StreamController::onOrderBookUpdated(const OrderBook& orderBook) {
    // üî• REAL-TIME: Process order book immediately from WebSocket
    //sLog_Network("üî• REAL-TIME: Received order book for" << QString::fromStdString(orderBook.product_id)
                 //<< "Bids:" << orderBook.bids.size() << "Asks:" << orderBook.asks.size());
    
    // Emit to GUI components
    emit orderBookUpdated(orderBook);
}

void StreamController::onConnectionStatusChanged(bool connected) {
    if (connected) {
        sLog_Connection("‚úÖ WebSocket connection established");
    } else {
        sLog_Connection("‚ùå WebSocket connection lost");
    }
}

void StreamController::pollForTrades() {
    // Check if client exists
    if (!m_client) return;
    
    // Poll each symbol for new trades
    for (const auto& symbol : m_symbols) {
        // Get new trades since last seen trade ID
        std::string lastTradeId = m_lastTradeIds.count(symbol) ? m_lastTradeIds[symbol] : "";
        auto newTrades = m_client->getNewTrades(symbol, lastTradeId);
        
        // Debug logging
        if (!newTrades.empty()) {
            sLog_Trades("üöÄ StreamController: Found" << newTrades.size() << "new trades for" << QString::fromStdString(symbol));
        }
        
        // Process each new trade
        for (const auto& trade : newTrades) {
            // Update last seen trade ID
            m_lastTradeIds[symbol] = trade.trade_id;
            
            // üöÄ LOCK-FREE PIPELINE: Push to GPU adapter instead of Qt signals
            if (m_gpuAdapter && !m_gpuAdapter->pushTrade(trade)) {
                sLog_Warning("‚ö†Ô∏è StreamController: GPU trade queue full! Trade dropped.");
            }
            
            // üî• THROTTLED LOGGING: Only log every 50th trade processing to reduce spam
            static int processLogCount = 0;
            if (++processLogCount % 50 == 1) { // Log 1st, 51st, 101st trade, etc.
                sLog_Trades("üì§ Pushing trade to GPU queue:" << QString::fromStdString(trade.product_id) 
                         << "$" << trade.price << "size:" << trade.size 
                         << "[" << processLogCount << " trades processed]");
            }
            
            // Keep Qt signal for backward compatibility (will be removed in final version)
            emit tradeReceived(trade);
        }
    }
}

void StreamController::pollForOrderBooks() {
    if (!m_client) return;

    // qDebug() << "Polling for order books..."; // Let's be more specific
    for (const auto& symbol : m_symbols) {
        auto book = m_client->getOrderBook(symbol);
        
        // üî• THROTTLED LOGGING: Only log every 20th order book poll to reduce spam
        static int pollLogCount = 0;
        if (++pollLogCount % 20 == 1) { // Log 1st, 21st, 41st poll, etc.
            sLog_Network("Polled client for" << QString::fromStdString(symbol) 
                     << "order book. Bids:" << book.bids.size() << "Asks:" << book.asks.size()
                     << "[" << pollLogCount << " polls total]");
        }
        
        if (!book.bids.empty() || !book.asks.empty()) {
            emit orderBookUpdated(book);
        }
    }
}

